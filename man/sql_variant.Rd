% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/translate-sql-helpers.R, R/backend-.R,
%   R/backend-odbc.R
\docType{data}
\name{sql_variant}
\alias{sql_variant}
\alias{sql_translator}
\alias{base_scalar}
\alias{base_agg}
\alias{base_win}
\alias{base_no_win}
\alias{base_odbc_scalar}
\alias{base_odbc_agg}
\alias{base_odbc_win}
\title{Create an SQL translator}
\usage{
sql_variant(
  scalar = sql_translator(),
  aggregate = sql_translator(),
  window = sql_translator()
)

sql_translator(..., .funs = list(), .parent = new.env(parent = emptyenv()))

base_scalar

base_agg

base_win

base_no_win

base_odbc_scalar

base_odbc_agg

base_odbc_win
}
\arguments{
\item{scalar, aggregate, window}{The three families of functions that an SQL
variant can supply.}

\item{..., .funs}{Named functions, used to add custom converters from standard
R functions to SQL functions. Specify individually in \code{...}, or provide a
list of \code{.funs}.}

\item{.parent}{The SQL variant that this variant should inherit from.
Defaults to \code{base_agg} which provides a standard set of mappings for the
most common operators and functions.}
}
\description{
\code{sql_variant()} creates a SQL variant, a list of translators for scalar,
aggregate, and window functions. \code{sql_translator()} creates a translator,
an environment containing R to SQL translations. When creating a backend,
you'll use these functions to customize how R functions are converted to
SQL.

Learn more in \code{vignette("new-backend")}.
}
\section{Base translators}{


dbplyr provides the following base translators that implement standard SQL
semantics:
\itemize{
\item \code{base_scalar} - scalar functions and operators
\item \code{base_agg} - aggregate functions
\item \code{base_win} - window functions
\item \code{base_no_win} - versions of window functions that throw errors
}
}

\examples{
# An example of adding some mappings for the statistical functions that
# postgresql provides: http://bit.ly/K5EdTn
postgres_agg <- sql_translator(.parent = base_agg,
  cor = sql_aggregate_2("CORR"),
  cov = sql_aggregate_2("COVAR_SAMP"),
  sd =  sql_aggregate("STDDEV_SAMP", "sd"),
  var = sql_aggregate("VAR_SAMP", "var")
)

# Next we have to simulate a connection that uses this variant
con <- new_sql_dialect("test", quote = \(x) sql_quote(x, '"'))
sql_translation.sql_dialect_test <- function(x) {
  sql_variant(
    base_scalar,
    postgres_agg,
    base_no_win
  )
}

translate_sql(cor(x, y), con = con, window = FALSE)
translate_sql(sd(income / years, na.rm = TRUE), con = con, window = FALSE)
}
\seealso{
Other SQL translation helpers: 
\code{\link{sql_translation_agg}},
\code{\link{sql_translation_scalar}},
\code{\link{sql_translation_string}},
\code{\link{sql_translation_window}}
}
\concept{SQL translation helpers}
\keyword{datasets}
