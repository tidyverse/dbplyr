% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/verb-mutate.R
\name{mutate.tbl_lazy}
\alias{mutate.tbl_lazy}
\title{Create, modify, and delete columns}
\usage{
\method{mutate}{tbl_lazy}(
  .data,
  ...,
  .by = NULL,
  .order = NULL,
  .frame = NULL,
  .keep = c("all", "used", "unused", "none"),
  .before = NULL,
  .after = NULL
)
}
\arguments{
\item{.data}{A lazy data frame backed by a database query.}

\item{...}{<\code{\link[rlang:args_data_masking]{data-masking}}> Variables, or
functions of variables. Use \code{\link[dplyr:desc]{desc()}} to sort a variable in descending
order.}

\item{.by}{<\code{\link[dplyr:dplyr_tidy_select]{tidy-select}}> Optionally, a selection of columns to
group by for just this operation, functioning as an alternative to \code{\link[dplyr:group_by]{group_by()}}. For
details and examples, see \link[dplyr:dplyr_by]{?dplyr_by}.}

\item{.order}{<\code{\link[rlang:args_data_masking]{data-masking}}> A selection of
columns to control ordering for window functions within this
\code{\link[dplyr:mutate]{dplyr::mutate()}} call. Use \code{c()} to order by multiple columns, e.g.
\code{.order = c(x, y)}. Each column can be wrapped in \code{\link[dplyr:desc]{dplyr::desc()}} to specify
descending order. Equivalent to calling \code{\link[=window_order]{window_order()}} before and
clearing it after the \code{\link[dplyr:mutate]{dplyr::mutate()}}.}

\item{.frame}{A length-2 numeric vector specifying the bounds for
window function frames. The first element is the lower bound (use \code{-Inf}
for "unbounded preceding") and the second is the upper bound (use \code{Inf}
for "unbounded following", \code{0} for "current row"). Equivalent to calling
\code{\link[=window_frame]{window_frame()}} before and clearing it after the \code{\link[dplyr:mutate]{dplyr::mutate()}}.}

\item{.keep}{Control which columns from \code{.data} are retained in the output. Grouping
columns and columns created by \code{...} are always kept.
\itemize{
\item \code{"all"} retains all columns from \code{.data}. This is the default.
\item \code{"used"} retains only the columns used in \code{...} to create new
columns. This is useful for checking your work, as it displays inputs
and outputs side-by-side.
\item \code{"unused"} retains only the columns \emph{not} used in \code{...} to create new
columns. This is useful if you generate new columns, but no longer need
the columns used to generate them.
\item \code{"none"} doesn't retain any extra columns from \code{.data}. Only the grouping
variables and columns created by \code{...} are kept.
}}

\item{.before, .after}{<\code{\link[dplyr:dplyr_tidy_select]{tidy-select}}> Optionally, control where new columns
should appear (the default is to add to the right hand side). See
\code{\link[dplyr:relocate]{relocate()}} for more details.}
}
\value{
Another \code{tbl_lazy}. Use \code{\link[=show_query]{show_query()}} to see the generated
query, and use \code{\link[=collect.tbl_sql]{collect()}} to execute the query
and return data to R.
}
\description{
These are methods for the dplyr \code{\link[dplyr:mutate]{dplyr::mutate()}} and \code{\link[dplyr:transmute]{dplyr::transmute()}} generics.
They are translated to computed expressions in the \code{SELECT} clause of
the SQL query.
}
\examples{
library(dplyr, warn.conflicts = FALSE)

db <- memdb_frame(x = 1:5, y = 5:1)
db |>
  mutate(a = (x + y) / 2, b = sqrt(x^2L + y^2L)) |>
  show_query()

# dbplyr automatically creates subqueries as needed
db |>
  mutate(x1 = x + 1, x2 = x1 * 2) |>
  show_query()

# `.order` and `.frame` control window functions
db <- memdb_frame(g = c(1, 1, 2, 2, 2), x = c(5, 3, 1, 4, 2))
db |>
  mutate(rolling_sum = sum(x), .by = g, .order = x, .frame = c(-2, 2)) |>
  show_query()
}
