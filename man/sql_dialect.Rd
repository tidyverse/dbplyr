% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dialect.R
\name{sql_dialect}
\alias{sql_dialect}
\alias{new_sql_dialect}
\alias{dialect_ansi}
\title{SQL dialects}
\usage{
sql_dialect(con)

new_sql_dialect(
  dialect,
  quote_identifier,
  supports_window_clause = FALSE,
  supports_table_alias_with_as = TRUE
)

dialect_ansi()
}
\arguments{
\item{con}{A database connection or dialect object.}

\item{dialect}{A string giving the dialect name (e.g., "postgres", "mysql").}

\item{quote_identifier}{A function that quotes identifiers. Should accept
a character vector and return a \link{sql} vector.}

\item{supports_window_clause}{Does the backend support named window
definitions (the \code{WINDOW} clause)?}

\item{supports_table_alias_with_as}{Does the backend support using \code{AS}
when aliasing a table in a subquery?}
}
\value{
\itemize{
\item \code{sql_dialect()} returns a dialect object (class \code{sql_dialect}) or
the connection itself for backward compatibility.
\item \code{new_sql_dialect()} returns a dialect object with class
\code{c("sql_dialect_{name}", "sql_dialect")}.
}
}
\description{
The dialect system allows multiple database connection classes to share
SQL generation code. A dialect object encapsulates the SQL syntax rules
for a particular database, independent of the connection mechanism.
\itemize{
\item \code{sql_dialect()} returns the dialect for a connection. For connections
that haven't implemented a dialect method, returns the connection itself
for backward compatibility.
\item \code{new_sql_dialect()} creates a new dialect object. This is primarily
intended for dbplyr backend authors.
}
}
\examples{
# Get dialect for a connection
sql_dialect(dialect_postgres())

# Create a custom dialect
my_dialect <- new_sql_dialect(
  "custom",
  quote_identifier = function(x) sql_quote(x, "`"),
  supports_window_clause = TRUE
)
class(my_dialect)
}
