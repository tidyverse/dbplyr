% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sql-dialect.R
\name{sql_dialect}
\alias{sql_dialect}
\alias{new_sql_dialect}
\title{SQL dialects}
\usage{
sql_dialect(con)

new_sql_dialect(
  dialect,
  quote_identifier,
  has_window_clause = FALSE,
  has_table_alias_with_as = TRUE
)
}
\arguments{
\item{con}{A database connection or dialect object.}

\item{dialect}{A string giving the dialect name (e.g., "postgres", "mysql").}

\item{quote_identifier}{A function that quotes identifiers. Should accept
a character vector and return a \link{sql} vector.}

\item{has_window_clause}{Does the backend support named window
definitions (the \code{WINDOW} clause)?}

\item{has_table_alias_with_as}{Does the backend support using \code{AS}
when aliasing a table in a subquery?}
}
\value{
\itemize{
\item \code{sql_dialect()} returns a dialect object (class \code{sql_dialect}) or
the connection itself for backward compatibility.
\item \code{new_sql_dialect()} returns a dialect object with class
\code{c("sql_dialect_{name}", "sql_dialect")}.
}
}
\description{
The dialect system allows multiple database connection classes to share
SQL generation code. A dialect object encapsulates the SQL syntax rules
for a particular database, independent of the connection mechanism.
\itemize{
\item \code{sql_dialect()} returns the dialect for a connection. For connections
that haven't implemented a dialect method, returns the connection itself
for backward compatibility.
\item \code{new_sql_dialect()} creates a new dialect object. This is primarily
intended for dbplyr backend authors.
}
}
\section{Dispatching on dialect}{
For backward compatibility, all \code{sql_} generics (and a handful of others)
call \code{sql_dialect()} on the \code{con} argument in order to dispatch further on
the dialect object, if possible:

\if{html}{\out{<div class="sourceCode R">}}\preformatted{sql_generic <- function(con, arg1, arg2, ...) \{
  UseMethod("sql_generic", sql_dialect(con))
\}
}\if{html}{\out{</div>}}

Unfortunately, due to the way that \code{UseMethod()} works, this uses
\code{sql_dialect(con)} to control which method is selected, but still passes
the original \code{con} to the method. This means that if you are implementing
a method for a dialect and need to access dialect properties, you must call
\code{sql_dialect(con)} again inside the method.
}

\examples{
# Create a custom dialect
my_dialect <- new_sql_dialect(
  "custom",
  quote_identifier = function(x) sql_quote(x, "`"),
  has_window_clause = TRUE
)
class(my_dialect)
}
