% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/verb-pivot-wider.R
\name{pivot_wider.tbl_lazy}
\alias{pivot_wider.tbl_lazy}
\alias{dbplyr_pivot_wider_spec}
\title{Pivot data from long to wide}
\usage{
\method{pivot_wider}{tbl_lazy}(
  data,
  ...,
  id_cols = NULL,
  id_expand = FALSE,
  names_from = name,
  names_prefix = "",
  names_sep = "_",
  names_glue = NULL,
  names_sort = FALSE,
  names_vary = "fastest",
  names_expand = FALSE,
  names_repair = "check_unique",
  values_from = value,
  values_fill = NULL,
  values_fn = ~max(.x, na.rm = TRUE),
  unused_fn = NULL
)

dbplyr_pivot_wider_spec(
  data,
  spec,
  ...,
  names_repair = "check_unique",
  id_cols = NULL,
  id_expand = FALSE,
  values_fill = NULL,
  values_fn = ~max(.x, na.rm = TRUE),
  unused_fn = NULL,
  error_call = current_env()
)
}
\arguments{
\item{data}{A lazy data frame backed by a database query.}

\item{...}{Unused; included for compatibility with generic.}

\item{id_cols}{A set of columns that uniquely identifies each observation.}

\item{id_expand}{Unused; included for compatibility with the generic.}

\item{names_from, values_from}{A pair of
arguments describing which column (or columns) to get the name of the
output column (\code{names_from}), and which column (or columns) to get the
cell values from (\code{values_from}).

If \code{values_from} contains multiple values, the value will be added to the
front of the output column.}

\item{names_prefix}{String added to the start of every variable name.}

\item{names_sep}{If \code{names_from} or \code{values_from} contains multiple
variables, this will be used to join their values together into a single
string to use as a column name.}

\item{names_glue}{Instead of \code{names_sep} and \code{names_prefix}, you can supply
a glue specification that uses the \code{names_from} columns (and special
\code{.value}) to create custom column names.}

\item{names_sort}{Should the column names be sorted? If \code{FALSE}, the default,
column names are ordered by first appearance.}

\item{names_vary}{When \code{names_from} identifies a column (or columns) with
multiple unique values, and multiple \code{values_from} columns are provided,
in what order should the resulting column names be combined?
\itemize{
\item \code{"fastest"} varies \code{names_from} values fastest, resulting in a column
naming scheme of the form: \verb{value1_name1, value1_name2, value2_name1, value2_name2}. This is the default.
\item \code{"slowest"} varies \code{names_from} values slowest, resulting in a column
naming scheme of the form: \verb{value1_name1, value2_name1, value1_name2, value2_name2}.
}}

\item{names_expand}{Should the values in the \code{names_from} columns be expanded
by \code{\link[tidyr:expand]{tidyr::expand()}} before pivoting? This results in more columns, the output
will contain column names corresponding to a complete expansion of all
possible values in \code{names_from}. Additionally, the column names will be
sorted, identical to what \code{names_sort} would produce.}

\item{names_repair}{What happens if the output has invalid column names?}

\item{values_fill}{Optionally, a (scalar) value that specifies what each
\code{value} should be filled in with when missing. Be careful when using this
in combination with the default \code{values_fn}.}

\item{values_fn}{A function, the default is \code{max()}, applied to the \code{value}
in each cell in the output. In contrast to local data frames it must not be
\code{NULL}.}

\item{unused_fn}{Optionally, a function applied to summarize the values from
the unused columns (i.e. columns not identified by \code{id_cols},
\code{names_from}, or \code{values_from}).

The default drops all unused columns from the result.

This can be a named list if you want to apply different aggregations
to different unused columns.

\code{id_cols} must be supplied for \code{unused_fn} to be useful, since otherwise
all unspecified columns will be considered \code{id_cols}.

This is similar to grouping by the \code{id_cols} then summarizing the
unused columns using \code{unused_fn}.}

\item{spec}{A specification data frame. This is useful for more complex
pivots because it gives you greater control on how metadata stored in the
columns become column names in the result.

Must be a data frame containing character \code{.name} and \code{.value} columns.
Additional columns in \code{spec} should be named to match columns in the
long format of the dataset and contain values corresponding to columns
pivoted from the wide format.
The special \code{.seq} variable is used to disambiguate rows internally;
it is automatically removed after pivoting.}

\item{error_call}{The execution environment of a currently
running function, e.g. \code{caller_env()}. The function will be
mentioned in error messages as the source of the error. See the
\code{call} argument of \code{\link[rlang:abort]{abort()}} for more information.}
}
\description{
\code{pivot_wider()} "widens" data, increasing the number of columns and
decreasing the number of rows. The inverse transformation is
\code{pivot_longer()}. Learn more in \code{vignette("pivot", "tidyr")}.

\code{pivot_wider()} on database tables comes with some caveats, please make
sure to read below for details.
}
\section{Caveats}{
\subsection{\code{pivot_wider()} is eager}{

Note that \code{pivot_wider()} cannot be lazy because we need to look
at the data to figure out what the new column names will be.
If you have a long-running query you have two options:
\itemize{
\item Temporarily store the result of the query via \code{compute()}.
\item Create a spec before and use \code{dbplyr_pivot_wider_spec()} - dbplyr's version
of \code{tidyr::pivot_wider_spec()}.
}
}

\subsection{You must supply \code{values_fn}}{

The big difference to \code{pivot_wider()} for local data frames is that
\code{values_fn} must not be \code{NULL}. By default it is \code{max()} which yields
the same results as for local data frames if three conditions are true:
\enumerate{
\item The combination of \code{id_cols} and \code{value} uniquely identify an observation.
\item The column has a comparable type (e.g. numeric, date-time, or
(for most databases) string).
\item \code{values_fill} is \code{NULL}.
}

If either the second or third condition is not met, you must supply a
custom \code{values_fn}. Unfortunately there is no generally available alternative
and you'll need to look for something database specific, like \code{FIRST()}
or \code{ANY_VALUE()}.
}
}

\section{How does it work?}{
The translation to SQL code basically works as follows:
\enumerate{
\item Get unique keys in \code{names_from} column.
\item For each key value generate an expression of the form:

\if{html}{\out{<div class="sourceCode sql">}}\preformatted{values_fn(
  CASE WHEN (`names from column` == `key value`) THEN (`value column`) END
) AS `output column`
}\if{html}{\out{</div>}}
\item Group data by id columns.
\item Summarise the grouped data with the expressions from step 2.
}
}

\examples{
\dontshow{if (rlang::is_installed("tidyr", version = "1.0.0")) withAutoprint(\{ # examplesIf}
memdb_frame(
  id = 1,
  key = c("x", "y"),
  value = 1:2
) |>
  tidyr::pivot_wider(
    id_cols = id,
    names_from = key,
    values_from = value
  )
\dontshow{\}) # examplesIf}
}
