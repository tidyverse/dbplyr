[{"path":[]},{"path":"https://dbplyr.tidyverse.org/dev/CODE_OF_CONDUCT.html","id":"our-pledge","dir":"","previous_headings":"","what":"Our Pledge","title":"Contributor Covenant Code of Conduct","text":"members, contributors, leaders pledge make participation community harassment-free experience everyone, regardless age, body size, visible invisible disability, ethnicity, sex characteristics, gender identity expression, level experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, sexual identity orientation. pledge act interact ways contribute open, welcoming, diverse, inclusive, healthy community.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/CODE_OF_CONDUCT.html","id":"our-standards","dir":"","previous_headings":"","what":"Our Standards","title":"Contributor Covenant Code of Conduct","text":"Examples behavior contributes positive environment community include: Demonstrating empathy kindness toward people respectful differing opinions, viewpoints, experiences Giving gracefully accepting constructive feedback Accepting responsibility apologizing affected mistakes, learning experience Focusing best just us individuals, overall community Examples unacceptable behavior include: use sexualized language imagery, sexual attention advances kind Trolling, insulting derogatory comments, personal political attacks Public private harassment Publishing others’ private information, physical email address, without explicit permission conduct reasonably considered inappropriate professional setting","code":""},{"path":"https://dbplyr.tidyverse.org/dev/CODE_OF_CONDUCT.html","id":"enforcement-responsibilities","dir":"","previous_headings":"","what":"Enforcement Responsibilities","title":"Contributor Covenant Code of Conduct","text":"Community leaders responsible clarifying enforcing standards acceptable behavior take appropriate fair corrective action response behavior deem inappropriate, threatening, offensive, harmful. Community leaders right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct, communicate reasons moderation decisions appropriate.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/CODE_OF_CONDUCT.html","id":"scope","dir":"","previous_headings":"","what":"Scope","title":"Contributor Covenant Code of Conduct","text":"Code Conduct applies within community spaces, also applies individual officially representing community public spaces. Examples representing community include using official e-mail address, posting via official social media account, acting appointed representative online offline event.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/CODE_OF_CONDUCT.html","id":"enforcement","dir":"","previous_headings":"","what":"Enforcement","title":"Contributor Covenant Code of Conduct","text":"Instances abusive, harassing, otherwise unacceptable behavior may reported community leaders responsible enforcement codeofconduct@posit.co. complaints reviewed investigated promptly fairly. community leaders obligated respect privacy security reporter incident.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/CODE_OF_CONDUCT.html","id":"enforcement-guidelines","dir":"","previous_headings":"","what":"Enforcement Guidelines","title":"Contributor Covenant Code of Conduct","text":"Community leaders follow Community Impact Guidelines determining consequences action deem violation Code Conduct:","code":""},{"path":"https://dbplyr.tidyverse.org/dev/CODE_OF_CONDUCT.html","id":"id_1-correction","dir":"","previous_headings":"Enforcement Guidelines","what":"1. Correction","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Use inappropriate language behavior deemed unprofessional unwelcome community. Consequence: private, written warning community leaders, providing clarity around nature violation explanation behavior inappropriate. public apology may requested.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/CODE_OF_CONDUCT.html","id":"id_2-warning","dir":"","previous_headings":"Enforcement Guidelines","what":"2. Warning","title":"Contributor Covenant Code of Conduct","text":"Community Impact: violation single incident series actions. Consequence: warning consequences continued behavior. interaction people involved, including unsolicited interaction enforcing Code Conduct, specified period time. includes avoiding interactions community spaces well external channels like social media. Violating terms may lead temporary permanent ban.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/CODE_OF_CONDUCT.html","id":"id_3-temporary-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"3. Temporary Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: serious violation community standards, including sustained inappropriate behavior. Consequence: temporary ban sort interaction public communication community specified period time. public private interaction people involved, including unsolicited interaction enforcing Code Conduct, allowed period. Violating terms may lead permanent ban.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/CODE_OF_CONDUCT.html","id":"id_4-permanent-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"4. Permanent Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Demonstrating pattern violation community standards, including sustained inappropriate behavior, harassment individual, aggression toward disparagement classes individuals. Consequence: permanent ban sort public interaction within community.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/CODE_OF_CONDUCT.html","id":"attribution","dir":"","previous_headings":"","what":"Attribution","title":"Contributor Covenant Code of Conduct","text":"Code Conduct adapted Contributor Covenant, version 2.1, available https://www.contributor-covenant.org/version/2/1/code_of_conduct.html. Community Impact Guidelines inspired [Mozilla’s code conduct enforcement ladder][https://github.com/mozilla/inclusion]. answers common questions code conduct, see FAQ https://www.contributor-covenant.org/faq. Translations available https://www.contributor-covenant.org/translations.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/CONTRIBUTING.html","id":null,"dir":"","previous_headings":"","what":"Contributing to dbplyr","title":"Contributing to dbplyr","text":"outlines propose change dbplyr. detailed info contributing , tidyverse packages, please see development contributing guide.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/CONTRIBUTING.html","id":"fixing-typos","dir":"","previous_headings":"","what":"Fixing typos","title":"Contributing to dbplyr","text":"can fix typos, spelling mistakes, grammatical errors documentation directly using GitHub web interface, long changes made source file. generally means ’ll need edit roxygen2 comments .R, .Rd file. can find .R file generates .Rd reading comment first line.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/CONTRIBUTING.html","id":"bigger-changes","dir":"","previous_headings":"","what":"Bigger changes","title":"Contributing to dbplyr","text":"want make bigger change, ’s good idea first file issue make sure someone team agrees ’s needed. ’ve found bug, please file issue illustrates bug minimal reprex (also help write unit test, needed).","code":""},{"path":"https://dbplyr.tidyverse.org/dev/CONTRIBUTING.html","id":"pull-request-process","dir":"","previous_headings":"Bigger changes","what":"Pull request process","title":"Contributing to dbplyr","text":"Fork package clone onto computer. haven’t done , recommend using usethis::create_from_github(\"batpigandme/dbplyr\", fork = TRUE). Install development dependences devtools::install_dev_deps(), make sure package passes R CMD check running devtools::check(). R CMD check doesn’t pass cleanly, ’s good idea ask help continuing. Create Git branch pull request (PR). recommend using usethis::pr_init(\"brief-description--change\"). Make changes, commit git, create PR running usethis::pr_push(), following prompts browser. title PR briefly describe change. body PR contain Fixes #issue-number. user-facing changes, add bullet top NEWS.md (.e. just first header). Follow style described https://style.tidyverse.org/news.html.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/CONTRIBUTING.html","id":"code-style","dir":"","previous_headings":"Bigger changes","what":"Code style","title":"Contributing to dbplyr","text":"New code follow tidyverse style guide. can use styler package apply styles, please don’t restyle code nothing PR. use roxygen2, Markdown syntax, documentation. use testthat unit tests. Contributions test cases included easier accept.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/CONTRIBUTING.html","id":"code-of-conduct","dir":"","previous_headings":"","what":"Code of Conduct","title":"Contributing to dbplyr","text":"Please note dbplyr project released Contributor Code Conduct. contributing project agree abide terms.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2023 dbplyr authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/SUPPORT.html","id":null,"dir":"","previous_headings":"","what":"Getting help with dbplyr","title":"Getting help with dbplyr","text":"Thanks using dbplyr! filing issue, places explore pieces put together make process smooth possible.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/SUPPORT.html","id":"make-a-reprex","dir":"","previous_headings":"","what":"Make a reprex","title":"Getting help with dbplyr","text":"Start making minimal reproducible example using reprex package. haven’t heard used reprex , ’re treat! Seriously, reprex make R-question-asking endeavors easier (pretty insane ROI five ten minutes ’ll take learn ’s ). additional reprex pointers, check Get help! section tidyverse site.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/SUPPORT.html","id":"where-to-ask","dir":"","previous_headings":"","what":"Where to ask?","title":"Getting help with dbplyr","text":"Armed reprex, next step figure ask. ’s question: start community.rstudio.com, /StackOverflow. people answer questions. ’s bug: ’re right place, file issue. ’re sure: let community help figure ! problem bug feature request, can easily return report . opening new issue, sure search issues pull requests make sure bug hasn’t reported /already fixed development version. default, search pre-populated :issue :open. can edit qualifiers (e.g. :pr, :closed) needed. example, ’d simply remove :open search issues repo, open closed.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/SUPPORT.html","id":"what-happens-next","dir":"","previous_headings":"","what":"What happens next?","title":"Getting help with dbplyr","text":"efficient possible, development tidyverse packages tends bursty, shouldn’t worry don’t get immediate response. Typically don’t look repo sufficient quantity issues accumulates, ’s burst intense activity focus efforts. makes development efficient avoids expensive context switching problems, cost taking longer get back . process makes good reprex particularly important might multiple months initial report start working . can’t reproduce bug, can’t fix !","code":""},{"path":"https://dbplyr.tidyverse.org/dev/articles/dbplyr.html","id":"getting-started","dir":"Articles","previous_headings":"","what":"Getting started","title":"Introduction to dbplyr","text":"use databases dplyr need first install dbplyr: ’ll also need install DBI backend package. DBI package provides common interface allows dplyr work many different databases using code. DBI automatically installed dbplyr, need install specific backend database want connect . Five commonly used backends : RMariaDB connects MySQL MariaDB RPostgres connects Postgres Redshift. RSQLite embeds SQLite database. odbc connects many commercial databases via open database connectivity protocol. bigrquery connects Google’s BigQuery. database need connect listed , ’ll need investigation (.e. googling) . vignette, ’re going use RSQLite backend automatically installed install dbplyr. SQLite great way get started databases ’s completely embedded inside R package. Unlike systems, don’t need setup separate database server. SQLite great demos, surprisingly powerful, little practice can use easily work many gigabytes data.","code":"install.packages(\"dbplyr\")"},{"path":"https://dbplyr.tidyverse.org/dev/articles/dbplyr.html","id":"connecting-to-the-database","dir":"Articles","previous_headings":"","what":"Connecting to the database","title":"Introduction to dbplyr","text":"work database dplyr, must first connect , using DBI::dbConnect(). ’re going go details DBI package , ’s foundation upon dbplyr built. ’ll need learn need things database beyond scope dplyr. arguments DBI::dbConnect() vary database database, first argument always database backend. ’s RSQLite::SQLite() RSQLite, RMariaDB::MariaDB() RMariaDB, RPostgres::Postgres() RPostgres, odbc::odbc() odbc, bigrquery::bigquery() BigQuery. SQLite needs one argument: path database. use special string \":memory:\" causes SQLite make temporary -memory database. existing databases don’t live file, instead live another server. means real-life code look like : (’re using RStudio, ’ll need way securely retrieve password. never record analysis scripts type console. Securing Credentials provides best practices.) temporary database data , ’ll start copying nycflights13::flights using convenient copy_to() function. quick dirty way getting data database useful primarily demos small jobs. Now ’ve copied data, can use tbl() take reference : print , ’ll notice mostly looks like regular tibble: main difference can see ’s remote source SQLite database.","code":"library(dbplyr) library(dplyr, warn.conflicts = FALSE) con <- DBI::dbConnect(RSQLite::SQLite(), dbname = \":memory:\") con <- DBI::dbConnect(RMariaDB::MariaDB(),    host = \"database.rstudio.com\",   user = \"hadley\",   password = rstudioapi::askForPassword(\"Database password\") ) copy_to(con, nycflights13::flights, \"flights\", temporary = FALSE) flights_db <- tbl(con, \"flights\") flights_db  #> # A query:  ?? x 19 #> # Database: sqlite 3.51.1 [:memory:] #>    year month   day dep_time sched_dep_time dep_delay arr_time #>   <int> <int> <int>    <int>          <int>     <dbl>    <int> #> 1  2013     1     1      517            515         2      830 #> 2  2013     1     1      533            529         4      850 #> 3  2013     1     1      542            540         2      923 #> 4  2013     1     1      544            545        -1     1004 #> 5  2013     1     1      554            600        -6      812 #> 6  2013     1     1      554            558        -4      740 #> # ℹ more rows #> # ℹ 12 more variables: sched_arr_time <int>, arr_delay <dbl>, #> #   carrier <chr>, flight <int>, tailnum <chr>, origin <chr>, #> #   dest <chr>, air_time <dbl>, distance <dbl>, hour <dbl>, #> #   minute <dbl>, time_hour <dbl>"},{"path":"https://dbplyr.tidyverse.org/dev/articles/dbplyr.html","id":"generating-queries","dir":"Articles","previous_headings":"","what":"Generating queries","title":"Introduction to dbplyr","text":"interact database usually use SQL, Structured Query Language. SQL 40 years old, used pretty much every database existence. goal dbplyr automatically generate SQL ’re forced use . However, SQL large language dbplyr doesn’t everything. focusses SELECT statements, SQL write often analyst. time don’t need know anything SQL, can continue use dplyr verbs ’re already familiar : However, long-run, highly recommend least learn basics SQL. ’s valuable skill data scientist, help debug problems run problems dplyr’s automatic translation. ’re completely new SQL might start codeacademy tutorial. familiarity SQL ’d like learn , found indexes work SQLite 10 easy steps complete understanding SQL particularly helpful. important difference ordinary data frames remote database queries R code translated SQL executed database remote server, R local machine. working databases, dplyr tries lazy possible: never pulls data R unless explicitly ask . delays work last possible moment: collects together everything want sends database one step. example, take following code: Surprisingly, sequence operations never touches database. ’s ask data (e.g. printing tailnum_delay) dplyr generates SQL requests results database. Even tries little work possible pulls rows. Behind scenes, dplyr translating R code SQL. can see SQL ’s generating show_query(): might exactly ’d write hand, ’s probably pretty close. Typically, ’ll iterate times figure data need database. ’ve figured , use collect() pull data local tibble: collect() requires database work, may take long time complete. Otherwise, dplyr tries prevent accidentally performing expensive query operations: ’s generally way determine many rows query return unless actually run , nrow() always NA. can’t find last rows without executing whole query, can’t use tail(). can also ask database plans execute query explain(). output database dependent, can esoteric, learning bit can useful helps understand database can execute query efficiently, need create new indices.","code":"flights_db |>    select(year:day, dep_delay, arr_delay) #> # A query:  ?? x 5 #> # Database: sqlite 3.51.1 [:memory:] #>    year month   day dep_delay arr_delay #>   <int> <int> <int>     <dbl>     <dbl> #> 1  2013     1     1         2        11 #> 2  2013     1     1         4        20 #> 3  2013     1     1         2        33 #> 4  2013     1     1        -1       -18 #> 5  2013     1     1        -6       -25 #> 6  2013     1     1        -4        12 #> # ℹ more rows  flights_db |>    filter(dep_delay > 240) #> # A query:  ?? x 19 #> # Database: sqlite 3.51.1 [:memory:] #>    year month   day dep_time sched_dep_time dep_delay arr_time #>   <int> <int> <int>    <int>          <int>     <dbl>    <int> #> 1  2013     1     1      848           1835       853     1001 #> 2  2013     1     1     1815           1325       290     2120 #> 3  2013     1     1     1842           1422       260     1958 #> 4  2013     1     1     2115           1700       255     2330 #> 5  2013     1     1     2205           1720       285       46 #> 6  2013     1     1     2343           1724       379      314 #> # ℹ more rows #> # ℹ 12 more variables: sched_arr_time <int>, arr_delay <dbl>, #> #   carrier <chr>, flight <int>, tailnum <chr>, origin <chr>, #> #   dest <chr>, air_time <dbl>, distance <dbl>, hour <dbl>, #> #   minute <dbl>, time_hour <dbl>  flights_db |>    group_by(dest) |>   summarise(delay = mean(dep_delay, na.rm = TRUE)) #> # A query:  ?? x 2 #> # Database: sqlite 3.51.1 [:memory:] #>   dest  delay #>   <chr> <dbl> #> 1 ABQ   13.7  #> 2 ACK    6.46 #> 3 ALB   23.6  #> 4 ANC   12.9  #> 5 ATL   12.5  #> 6 AUS   13.0  #> # ℹ more rows tailnum_delay_db <- flights_db |>    group_by(tailnum) |>   summarise(     delay = mean(arr_delay),     n = n()   ) |>    arrange(desc(delay)) |>   filter(n > 100) tailnum_delay_db #> Warning: Missing values are always removed in SQL aggregation functions. #> Use `na.rm = TRUE` to silence this warning #> This warning is displayed once every 8 hours. #> # A query:    ?? x 3 #> # Database:   sqlite 3.51.1 [:memory:] #> # Ordered by: desc(delay) #>   tailnum delay     n #>   <chr>   <dbl> <int> #> 1 N11119   30.3   148 #> 2 N16919   29.9   251 #> 3 N14998   27.9   230 #> 4 N15910   27.6   280 #> 5 N13123   26.0   121 #> 6 N11192   25.9   154 #> # ℹ more rows tailnum_delay_db |> show_query() #> <SQL> #> SELECT `tailnum`, AVG(`arr_delay`) AS `delay`, COUNT(*) AS `n` #> FROM `flights` #> GROUP BY `tailnum` #> HAVING (COUNT(*) > 100.0) #> ORDER BY `delay` DESC tailnum_delay <- tailnum_delay_db |> collect() tailnum_delay #> # A tibble: 1,201 × 3 #>   tailnum delay     n #>   <chr>   <dbl> <int> #> 1 N11119   30.3   148 #> 2 N16919   29.9   251 #> 3 N14998   27.9   230 #> 4 N15910   27.6   280 #> 5 N13123   26.0   121 #> 6 N11192   25.9   154 #> # ℹ 1,195 more rows nrow(tailnum_delay_db) #> [1] NA  tail(tailnum_delay_db) #> Error in `tail()`: #> ! `tail()` is not supported on database backends."},{"path":"https://dbplyr.tidyverse.org/dev/articles/dbplyr.html","id":"why-use-dbplyr","dir":"Articles","previous_headings":"","what":"Why use dbplyr?","title":"Introduction to dbplyr","text":"already know SQL, use dbplyr? One nicety automatically generate subqueries want use freshly created variable mutate(): general, ’s much easier work iteratively dbplyr. can easily give intermediate queries names, reuse multiple places. common operation want many queries, can easily wrap function. ’s also easy chain count() end query check results expect.","code":"db <- lazy_frame(x = 1, y = 2)  db |>    mutate(     a = y * x,     b = a ^ 2,   ) #> <SQL> #> SELECT \"q01\".*, POWER(\"a\", 2.0) AS \"b\" #> FROM ( #>   SELECT \"df\".*, \"y\" * \"x\" AS \"a\" #>   FROM \"df\" #> ) AS \"q01\""},{"path":"https://dbplyr.tidyverse.org/dev/articles/dbplyr.html","id":"what-happens-when-dbplyr-fails","dir":"Articles","previous_headings":"","what":"What happens when dbplyr fails?","title":"Introduction to dbplyr","text":"dbplyr aims translate common R functions SQL equivalents, allowing ignore vagaries SQL dialect ’re working , can focus data analysis problem hand. different backends different capabilities, sometimes SQL functions don’t exact equivalents R. cases, ’ll need write SQL code directly. function dbplyr doesn’t know left : make clear ’re calling SQL function, R function, can use .sql pronoun: SQL functions tend greater variety syntax R. means number expressions can’t translated directly R code. insert queries, can use literal SQL inside sql(): Learn vignette(\"translation-function\").","code":"db |>   mutate(z = foofify(x, y)) #> <SQL> #> SELECT \"df\".*, foofify(\"x\", \"y\") AS \"z\" #> FROM \"df\"  db |>   filter(x %LIKE% \"%foo%\") #> <SQL> #> SELECT \"df\".* #> FROM \"df\" #> WHERE (\"x\" LIKE '%foo%') db |>   mutate(z = .sql$foofify(x, y)) #> <SQL> #> SELECT \"df\".*, foofify(\"x\", \"y\") AS \"z\" #> FROM \"df\" db |>   transmute(factorial = sql(\"x!\")) #> <SQL> #> SELECT x! AS \"factorial\" #> FROM \"df\"  db |>   transmute(factorial = sql(\"CAST(x AS FLOAT)\")) #> <SQL> #> SELECT CAST(x AS FLOAT) AS \"factorial\" #> FROM \"df\""},{"path":"https://dbplyr.tidyverse.org/dev/articles/dbplyr.html","id":"creating-your-own-database","dir":"Articles","previous_headings":"","what":"Creating your own database","title":"Introduction to dbplyr","text":"don’t already database, ’s advice experiences setting running . SQLite far easiest get started . PostgreSQL much harder use wide range built-functions. opinion, shouldn’t bother MySQL/MariaDB: ’s pain set , documentation subpar, ’s less featureful Postgres. Google BigQuery might good fit large data, ’re willing pay (small amount ) money someone ’ll look database. databases follow client-server model - computer connects database computer running database (two may one usually isn’t). Getting one databases running beyond scope article, plenty tutorials available web.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/articles/dbplyr.html","id":"mysqlmariadb","dir":"Articles","previous_headings":"Creating your own database","what":"MySQL/MariaDB","title":"Introduction to dbplyr","text":"terms functionality, MySQL lies somewhere SQLite PostgreSQL. provides wider range built-functions. gained support window functions 2018.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/articles/dbplyr.html","id":"postgresql","dir":"Articles","previous_headings":"Creating your own database","what":"PostgreSQL","title":"Introduction to dbplyr","text":"PostgreSQL considerably powerful database SQLite. much wider range built-functions, generally featureful database.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/articles/dbplyr.html","id":"bigquery","dir":"Articles","previous_headings":"Creating your own database","what":"BigQuery","title":"Introduction to dbplyr","text":"BigQuery hosted database server provided Google. connect, need provide project, dataset optionally project billing (billing project isn’t enabled). provides similar set functions Postgres designed specifically analytic workflows. ’s hosted solution, ’s setup involved, lot data, getting Google can ordeal (especially upload support R great currently). (lots data, can ship hard drives!)","code":""},{"path":"https://dbplyr.tidyverse.org/dev/articles/new-backend.html","id":"first-steps","dir":"Articles","previous_headings":"","what":"First steps","title":"Adding a new DBI backend","text":"interactive exploitation, attach dplyr DBI. ’re creating package, ’ll need import dplyr DBI. Check can create tbl connection, like: can’t, likely indicates problem DBI methods. Use DBItest narrow problem.","code":"library(dplyr) library(dbplyr) library(DBI) con <- DBI::dbConnect(RSQLite::SQLite(), path = \":memory:\") DBI::dbWriteTable(con, \"mtcars\", mtcars)  tbl(con, \"mtcars\") #> # A query:  ?? x 11 #> # Database: sqlite 3.51.1 [] #>     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb #>   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> #> 1  21       6   160   110  3.9   2.62  16.5     0     1     4     4 #> 2  21       6   160   110  3.9   2.88  17.0     0     1     4     4 #> 3  22.8     4   108    93  3.85  2.32  18.6     1     1     4     1 #> 4  21.4     6   258   110  3.08  3.22  19.4     1     0     3     1 #> 5  18.7     8   360   175  3.15  3.44  17.0     0     0     3     2 #> 6  18.1     6   225   105  2.76  3.46  20.2     1     0     3     1 #> # ℹ more rows"},{"path":"https://dbplyr.tidyverse.org/dev/articles/new-backend.html","id":"write-your-first-method","dir":"Articles","previous_headings":"","what":"Write your first method","title":"Adding a new DBI backend","text":"first method dbplyr backend always dbplyr_edition() generic: declares package uses version 2 API, version vignette documents.","code":"#' @importFrom dbplyr dbplyr_edition #' @export dbplyr_edition.myConnectionClass <- function(con) 2L"},{"path":"https://dbplyr.tidyverse.org/dev/articles/new-backend.html","id":"copying-computing-collecting-and-collapsing","dir":"Articles","previous_headings":"","what":"Copying, computing, collecting and collapsing","title":"Adding a new DBI backend","text":"Next, check copy_to(), collapse(), compute(), collect() work: copy_to() fails, probably need method sql_table_analyze() sql_table_index(). copy_to() fails creation tbl, may need method sql_query_fields(). collapse() fails, database non-standard way constructing subqueries. Add method sql_subquery(). compute() fails, database non-standard way saving queries temporary tables. Add method db_save_query().","code":""},{"path":"https://dbplyr.tidyverse.org/dev/articles/new-backend.html","id":"sql-translation-verbs","dir":"Articles","previous_headings":"","what":"SQL translation: verbs","title":"Adding a new DBI backend","text":"Make sure ’ve read vignette(\"translation-verb\") lay land. First check SQL translation key verbs work: summarise(), mutate(), filter() etc: powered sql_query_select() left_join(), inner_join(): powered sql_query_join() semi_join(), anti_join(): powered sql_query_semi_join() union(), intersect(), setdiff(): powered sql_query_set_op()","code":""},{"path":"https://dbplyr.tidyverse.org/dev/articles/new-backend.html","id":"building-sql-strings","dir":"Articles","previous_headings":"SQL translation: verbs","what":"Building SQL strings","title":"Adding a new DBI backend","text":"need generate SQL, recommend using sql_glue2(). uses glue syntax type markers safe SQL generation:","code":"con <- simulate_dbi()  # Create an index index_name <- \"index\" table <- I(\"schema.table\") columns <- c(\"column1\", \"column2\") sql_glue2(con, \"CREATE INDEX {.id index_name} ON {.tbl table} {.id columns*}\") #> <SQL> CREATE INDEX \"index\" ON schema.table (\"column1\", \"column2\")  # Insert values safely name <- \"O'Brien\" sql_glue2(con, \"INSERT INTO students (name) VALUES {name*}\") #> <SQL> INSERT INTO students (name) VALUES ('O''Brien')  # Build a query table <- \"my_table\" cols <- c(\"id\", \"name\", \"value\") sql_glue2(con, \"SELECT {.id cols} FROM {.tbl table}\") #> <SQL> SELECT \"id\", \"name\", \"value\" FROM \"my_table\""},{"path":"https://dbplyr.tidyverse.org/dev/articles/new-backend.html","id":"sql-translation-vectors","dir":"Articles","previous_headings":"","what":"SQL translation: vectors","title":"Adding a new DBI backend","text":"Finally, may provide custom R -> SQL translation functions work vectors within verbs. can providing method sql_translation(), return object created sql_variant(). sql_variant() function creates container three types function translations: translator inherits base (ANSI SQL) translator overrides ’s different backend:","code":"sql_translation.myConnectionClass <- function(con) {   sql_variant(     scalar = sql_translator(base_scalar, ...), # Functions in SELECT (non-aggregated)     aggregate = sql_translator(base_aggregate, ...), # Aggregation functions (mean, sum, etc.)     window = sql_translator(base_win, ...) # Window functions (lead, lag, rank, etc.)   ) } sql_translator(   base_scalar, # Inherit most translations   # Override specific functions for your backend   `+` = sql_infix(\"+\"),   mean = sql_aggregate(\"AVERAGE\", \"mean\") )"},{"path":"https://dbplyr.tidyverse.org/dev/articles/new-backend.html","id":"scalar-function-helpers","dir":"Articles","previous_headings":"SQL translation: vectors","what":"Scalar function helpers","title":"Adding a new DBI backend","text":"dbplyr provides several helper functions make easier translate R functions SQL: sql_prefix(f, n = NULL): standard SQL functions. n argument optionally specifies number arguments. sql_infix(f): infix operators like +, *, ==. sql_cast(type): type casting functions. sql_not_supported(f): functions SQL translation. ’s example showing helpers use:","code":"sql_translation.myConnectionClass <- function(con) {   sql_variant(     scalar = sql_translator(       base_scalar,       # Standard SQL functions       cos = sql_prefix(\"COS\", 1),       round = sql_prefix(\"ROUND\", 2),       # Infix operators       `+` = sql_infix(\"+\"),       `*` = sql_infix(\"*\"),       `==` = sql_infix(\"=\"),       # Type casting       as.numeric = sql_cast(\"NUMERIC\"),       as.character = sql_cast(\"VARCHAR\")     ),     aggregate = sql_translator(base_agg),     window = sql_translator(base_win)   ) }"},{"path":"https://dbplyr.tidyverse.org/dev/articles/new-backend.html","id":"aggregation-function-helpers","dir":"Articles","previous_headings":"SQL translation: vectors","what":"Aggregation function helpers","title":"Adding a new DBI backend","text":"sql_aggregate(f, f_r = f): single-argument SQL aggregate functions. f_r argument gives name R function. sql_aggregate_2(f): two-argument SQL aggregate functions. sql_aggregate_n(f, f_r = f): variadic SQL aggregate functions.","code":"sql_translation.myConnectionClass <- function(con) {   sql_variant(     scalar = sql_translator(base_scalar),     aggregate = sql_translator(       .parent = base_agg,       # Single-argument aggregates       mean = sql_aggregate(\"AVG\", \"mean\"),       var = sql_aggregate(\"VAR_SAMP\", \"var\"),       # Two-argument aggregates       cov = sql_aggregate_2(\"COVAR_SAMP\"),       # Variadic aggregates       pmin = sql_aggregate_n(\"LEAST\", \"pmin\"),       pmax = sql_aggregate_n(\"GREATEST\", \"pmax\"),       # Unsupported functions       median = sql_not_supported(\"median\")     ),     window = sql_translator(base_win)   ) }"},{"path":"https://dbplyr.tidyverse.org/dev/articles/new-backend.html","id":"window-function-helpers","dir":"Articles","previous_headings":"SQL translation: vectors","what":"Window function helpers","title":"Adding a new DBI backend","text":"Window functions set helpers: win_rank(f): ranking functions. win_aggregate(f): aggregate functions used window functions. win_cumulative(f): cumulative functions. win_absent(f): backends don’t support certain window functions. ’s example showing helpers use:","code":"window = sql_translator(   base_win,   # Ranking functions   row_number = win_rank(\"ROW_NUMBER\"),   rank = win_rank(\"RANK\"),   dense_rank = win_rank(\"DENSE_RANK\"),   # Aggregate functions as window functions   mean = win_aggregate(\"AVG\"),   sum = win_aggregate(\"SUM\"),   # Cumulative functions   cumsum = win_cumulative(\"SUM\"),   # Absent functions   cume_dist = win_absent(\"cume_dist\") )"},{"path":"https://dbplyr.tidyverse.org/dev/articles/new-backend.html","id":"custom-translation-functions","dir":"Articles","previous_headings":"SQL translation: vectors","what":"Custom translation functions","title":"Adding a new DBI backend","text":"complex translations, can write custom functions return SQL expressions using sql_glue(). uses glue syntax string interpolation automatic escaping.","code":"scalar = sql_translator(   base_scalar,    # Custom log function with change of base   log = function(x, base = exp(1)) {     if (isTRUE(all.equal(base, exp(1)))) {       sql_glue(\"LN({x})\")     } else {       sql_glue(\"LOG({x}) / LOG({base})\")     }   },    # Custom paste function using CONCAT   paste = function(..., sep = \" \") {     sql_glue(\"CONCAT_WS({sep}, {...})\")   } )"},{"path":"https://dbplyr.tidyverse.org/dev/articles/reprex.html","id":"using-memdb_frame","dir":"Articles","previous_headings":"","what":"Using memdb_frame()","title":"Reprexes for dbplyr","text":"first place start SQLite. SQLite particularly appealing ’s completely embedded instead R package doesn’t external dependencies. SQLite designed small simple, can’t demonstrate problems, ’s easy try great place start. can easily create SQLite -memory database table using memdb_frame(): Reprexes easiest understand create small custom data, want use existing data frame can use copy_to() + memdb():","code":"mf <- memdb_frame(g = c(1, 1, 2, 2, 2), x = 1:5, y = 5:1) mf #> # A query:  ?? x 3 #> # Database: sqlite 3.51.1 [:memory:] #>       g     x     y #>   <dbl> <int> <int> #> 1     1     1     5 #> 2     1     2     4 #> 3     2     3     3 #> 4     2     4     2 #> 5     2     5     1  mf |>    group_by(g) |>    summarise_all(mean, na.rm = TRUE) #> # A query:  ?? x 3 #> # Database: sqlite 3.51.1 [:memory:] #>       g     x     y #>   <dbl> <dbl> <dbl> #> 1     1   1.5   4.5 #> 2     2   4     2 mtcars_db <- copy_to(memdb(), mtcars) mtcars_db |>    group_by(cyl) |>    summarise(n = n()) |>    show_query() #> <SQL> #> SELECT `cyl`, COUNT(*) AS `n` #> FROM `mtcars` #> GROUP BY `cyl`"},{"path":"https://dbplyr.tidyverse.org/dev/articles/reprex.html","id":"translating-verbs","dir":"Articles","previous_headings":"","what":"Translating verbs","title":"Reprexes for dbplyr","text":"Many problems dbplyr come incorrect SQL generation. Fortunately, ’s possible generate SQL without database using lazy_frame() tbl_lazy(). take con argument takes database “simulator” like simulate_postgres(), simulate_sqlite(), etc. isolate problem incorrect SQL generation, helpful also suggest appropriate SQL.","code":"x <- c(\"abc\", \"def\", \"ghif\")  lazy_frame(x = x, con = simulate_postgres()) |>    head(5) |>    show_query() #> <SQL> #> SELECT \"df\".* #> FROM \"df\" #> LIMIT 5  lazy_frame(x = x, con = simulate_mssql()) |>    head(5) |>    show_query() #> Warning in scan(text = x, what = character(), quote = quote_char, #> quiet = TRUE, : EOF within quoted string #> Warning in scan(text = x, what = character(), quote = quote_char, #> quiet = TRUE, : EOF within quoted string #> Warning in scan(text = x, what = character(), quote = quote_char, #> quiet = TRUE, : EOF within quoted string #> <SQL> #> SELECT TOP 5 [df]] #> ].* #> FROM [df]"},{"path":"https://dbplyr.tidyverse.org/dev/articles/reprex.html","id":"translating-individual-expressions","dir":"Articles","previous_headings":"","what":"Translating individual expressions","title":"Reprexes for dbplyr","text":"cases, might able track problem incorrect translation single column expression. case, can make reprex even simpler translate_sql():","code":"translate_sql(substr(x, 1, 2), con = simulate_postgres()) #> <SQL> SUBSTR(\"x\", 1, 2) translate_sql(substr(x, 1, 2), con = simulate_sqlite()) #> <SQL> SUBSTR(`x`, 1, 2)"},{"path":"https://dbplyr.tidyverse.org/dev/articles/translation-function.html","id":"getting-started-with-translations","dir":"Articles","previous_headings":"","what":"Getting started with translations","title":"Function translation","text":"vignette, ’ll use lazy_frame() create toy lazy table allows us see translation without needing connect real database: default lazy_frame() uses generic database generates (approximately) SQL-92 compliant SQL. can use simulate_*() connections see translations used different backends. Different databases generate slightly different SQL; see vignette(\"new-backend\") details. One key difference dbplyr-generated SQL hand-written SQL dbplyr always quotes table column names. verbose necessary column names database tables can string, including SQL reserved words like select . Quoting names ensures dbplyr-generated SQL always works regardless table column names involved. general, perfect translation possible databases don’t functions R . goal dbplyr provide semantic rather literal translation: mean, rather precisely done. fact, even functions exist databases R, shouldn’t expect results identical; database programmers different priorities R core programmers. example, R order get higher level numerical accuracy, mean() loops data twice. R’s mean() also provides trim option computing trimmed means; something databases provide. ’re interested translate_sql() implemented, basic techniques underlie implementation translate_sql() described “Advanced R”.","code":"lf <- lazy_frame(x = 1, y = 2, g = \"a\") lf |> mutate(z = (x + y) / 2) #> <SQL> #> SELECT \"df\".*, (\"x\" + \"y\") / 2.0 AS \"z\" #> FROM \"df\" lf_sqlite <- lazy_frame(x = 1, con = simulate_sqlite()) lf_access <- lazy_frame(x = 1, con = simulate_access())  lf_sqlite |> transmute(z = x^2) #> <SQL> #> SELECT POWER(`x`, 2.0) AS `z` #> FROM `df` lf_access |> transmute(z = x^2) #> <SQL> #> SELECT \"x\" ^ 2.0 AS \"z\" #> FROM \"df\""},{"path":"https://dbplyr.tidyverse.org/dev/articles/translation-function.html","id":"basic-differences","dir":"Articles","previous_headings":"","what":"Basic differences","title":"Function translation","text":"two fundamental differences R SQL: \" ' mean different things. R can use either \" ' strings, ANSI SQL, must \" used names must ' used strings. R SQL different defaults integers reals. R, 1 real, 1L integer. SQL, 1 integer, 1.0 real.","code":"lf |> filter(x == \"x\") #> <SQL> #> SELECT \"df\".* #> FROM \"df\" #> WHERE (\"x\" = 'x') lf |> transmute(z = 1) #> <SQL> #> SELECT 1.0 AS \"z\" #> FROM \"df\" lf |> transmute(z = 1L) #> <SQL> #> SELECT 1 AS \"z\" #> FROM \"df\""},{"path":[]},{"path":"https://dbplyr.tidyverse.org/dev/articles/translation-function.html","id":"mathematics","dir":"Articles","previous_headings":"Known functions","what":"Mathematics","title":"Function translation","text":"basic math operators: +, -, *, /, ^ trigonometry: acos(), asin(), atan(), atan2(), cos(), cot(), tan(), sin() hyperbolic: cosh(), coth(), sinh(), tanh() logarithmic: log(), log10(), exp() misc: abs(), ceiling(), floor(), sqrt(), sign(), round()","code":"lf |> transmute(x = x / 2, y = x^2 + y^2) #> <SQL> #> SELECT \"x\", (POWER(\"x\", 2.0)) + POWER(\"y\", 2.0) AS \"y\" #> FROM ( #>   SELECT \"x\" / 2.0 AS \"x\", \"y\", \"g\" #>   FROM \"df\" #> ) AS \"q01\"  lf |> transmute(x = log(x), y = round(y, 1)) #> <SQL> #> SELECT LN(\"x\") AS \"x\", ROUND(\"y\", 1) AS \"y\" #> FROM \"df\""},{"path":"https://dbplyr.tidyverse.org/dev/articles/translation-function.html","id":"modulo-arithmetic","dir":"Articles","previous_headings":"Known functions","what":"Modulo arithmetic","title":"Function translation","text":"dbplyr translates %% SQL equivalents note ’s precisely : databases use truncated division modulo operator takes sign dividend, R using mathematically preferred floored division modulo sign taking sign divisor. dbplyr longer translates %/% ’s robust cross-database translation available.","code":"df <- tibble(   x = c(10L, 10L, -10L, -10L),   y = c(3L, -3L, 3L, -3L) ) db <- copy_to(memdb(), df)  df |> mutate(x %% y) #> # A tibble: 4 × 3 #>       x     y `x%%y` #>   <int> <int>  <int> #> 1    10     3      1 #> 2    10    -3     -2 #> 3   -10     3      2 #> 4   -10    -3     -1 db |> mutate(x %% y) #> # A query:  ?? x 3 #> # Database: sqlite 3.51.1 [:memory:] #>       x     y `x%%y` #>   <int> <int>  <int> #> 1    10     3      1 #> 2    10    -3      1 #> 3   -10     3     -1 #> 4   -10    -3     -1"},{"path":"https://dbplyr.tidyverse.org/dev/articles/translation-function.html","id":"logical-comparisons-and-boolean-operations","dir":"Articles","previous_headings":"Known functions","what":"Logical comparisons and boolean operations","title":"Function translation","text":"logical comparisons: <, <=, !=, >=, >, ==, %%, () boolean operations: &, &&, |, ||, !, xor()","code":"lf |> filter(x > 5 | y == 2) #> <SQL> #> SELECT \"df\".* #> FROM \"df\" #> WHERE (\"x\" > 5.0 OR \"y\" = 2.0)  lf |> filter(x %in% c(1, 2, 3)) #> <SQL> #> SELECT \"df\".* #> FROM \"df\" #> WHERE (\"x\" IN (1.0, 2.0, 3.0))  lf |> filter(between(x, 1, 5)) #> <SQL> #> SELECT \"df\".* #> FROM \"df\" #> WHERE (\"x\" BETWEEN 1.0 AND 5.0)"},{"path":"https://dbplyr.tidyverse.org/dev/articles/translation-function.html","id":"bitwise-operations","dir":"Articles","previous_headings":"Known functions","what":"Bitwise operations","title":"Function translation","text":"bitwNot(), bitwAnd(), bitwOr(), bitwXor(), bitwShiftL(), bitwShiftR() supported:","code":"lf |> transmute(x = bitwAnd(x, 3L), y = bitwShiftL(x, 2L)) #> <SQL> #> SELECT \"x\", \"x\" << 2 AS \"y\" #> FROM ( #>   SELECT \"x\" & 3 AS \"x\", \"y\", \"g\" #>   FROM \"df\" #> ) AS \"q01\""},{"path":"https://dbplyr.tidyverse.org/dev/articles/translation-function.html","id":"type-coercion","dir":"Articles","previous_headings":"Known functions","what":"Type coercion","title":"Function translation","text":"Type coercion functions use corresponding SQL CAST() call: integer types: .integer(), .integer64() floating point: .numeric(), .double() character: .character() logical: .logical() date/time: .Date(), .POSIXct()","code":"lf |> transmute(x = as.integer(y), y = as.character(x)) #> <SQL> #> SELECT \"x\", CAST(\"x\" AS TEXT) AS \"y\" #> FROM ( #>   SELECT CAST(\"y\" AS INTEGER) AS \"x\", \"y\", \"g\" #>   FROM \"df\" #> ) AS \"q01\""},{"path":"https://dbplyr.tidyverse.org/dev/articles/translation-function.html","id":"nullna-handling","dir":"Articles","previous_headings":"Known functions","what":"NULL/NA handling","title":"Function translation","text":".na(), .null(): test NULL. na_if(): replace value NULL. coalesce(): replace NULL default value.","code":"lf |> filter(!is.na(x)) #> <SQL> #> SELECT \"df\".* #> FROM \"df\" #> WHERE (NOT((\"x\" IS NULL)))  lf |> transmute(x = coalesce(x, 0L)) #> <SQL> #> SELECT COALESCE(\"x\", 0) AS \"x\" #> FROM \"df\"  lf |> transmute(x = na_if(x, 0L)) #> <SQL> #> SELECT NULLIF(\"x\", 0) AS \"x\" #> FROM \"df\""},{"path":"https://dbplyr.tidyverse.org/dev/articles/translation-function.html","id":"aggregation","dir":"Articles","previous_headings":"Known functions","what":"Aggregation","title":"Function translation","text":"databases provide translation basic aggregations: mean(), sum(), min(), max(). Databases automatically drop NULLs (equivalent missing values) whereas R ask nicely. aggregation functions warn important difference: Note aggregation functions used inside mutate() filter() generate window translation: backends also support: sd(), var(), cor(), cov() median(), quantile() n(), n_distinct() (), () str_flatten()","code":"lf |> summarise(z = mean(x)) #> Warning: Missing values are always removed in SQL aggregation functions. #> Use `na.rm = TRUE` to silence this warning #> This warning is displayed once every 8 hours. #> <SQL> #> SELECT AVG(\"x\") AS \"z\" #> FROM \"df\" lf |> summarise(z = mean(x, na.rm = TRUE)) #> <SQL> #> SELECT AVG(\"x\") AS \"z\" #> FROM \"df\" lf |> mutate(z = mean(x, na.rm = TRUE)) #> <SQL> #> SELECT \"df\".*, AVG(\"x\") OVER () AS \"z\" #> FROM \"df\" lf |> filter(mean(x, na.rm = TRUE) > 0) #> <SQL> #> SELECT \"x\", \"y\", \"g\" #> FROM ( #>   SELECT \"df\".*, AVG(\"x\") OVER () AS \"col01\" #>   FROM \"df\" #> ) AS \"q01\" #> WHERE (\"col01\" > 0.0)"},{"path":"https://dbplyr.tidyverse.org/dev/articles/translation-function.html","id":"conditional-evaluation","dir":"Articles","previous_headings":"Known functions","what":"Conditional evaluation","title":"Function translation","text":", ifelse(), if_else() translated CASE : case_when(), case_match(), switch() also supported:","code":"lf |> transmute(z = ifelse(x > 5, \"big\", \"small\")) #> <SQL> #> SELECT CASE WHEN (\"x\" > 5.0) THEN 'big' WHEN NOT (\"x\" > 5.0) THEN 'small' END AS \"z\" #> FROM \"df\" lf |>    mutate(z = case_when(     x > 10 ~ \"medium\",     x > 30 ~ \"big\",      .default = \"small\"   )) #> <SQL> #> SELECT #>   \"df\".*, #>   CASE #> WHEN (\"x\" > 10.0) THEN 'medium' #> WHEN (\"x\" > 30.0) THEN 'big' #> ELSE 'small' #> END AS \"z\" #> FROM \"df\"  lf |> mutate(z = switch(g, a = 1L, b = 2L, 3L)) #> <SQL> #> SELECT #>   \"df\".*, #>   CASE \"g\" WHEN ('a') THEN (1) WHEN ('b') THEN (2) ELSE (3) END AS \"z\" #> FROM \"df\""},{"path":"https://dbplyr.tidyverse.org/dev/articles/translation-function.html","id":"string-functions","dir":"Articles","previous_headings":"Known functions","what":"String functions","title":"Function translation","text":"Base R string functions stringr equivalents widely supported: nchar(), str_length() tolower(), toupper(), str_to_lower(), str_to_upper(), str_to_title() trimws(), str_trim() paste(), paste0(), str_c() substr(), substring(), str_sub() Many backends also support regular expression functions like str_detect(), str_replace(), str_replace_all(), str_remove(), str_remove_all(), str_squish(), str_like(). Support varies backend; see individual backend documentation details.","code":"lf |> transmute(x = paste0(g, \" dog\")) #> <SQL> #> SELECT CONCAT_WS('', \"g\", ' dog') AS \"x\" #> FROM \"df\"  lf |> transmute(x = substr(g, 1L, 2L)) #> <SQL> #> SELECT SUBSTR(\"g\", 1, 2) AS \"x\" #> FROM \"df\""},{"path":"https://dbplyr.tidyverse.org/dev/articles/translation-function.html","id":"datetime-functions","dir":"Articles","previous_headings":"Known functions","what":"Date/time functions","title":"Function translation","text":"dbplyr supports many lubridate functions extracting date components: today(), now() year(), month(), day(), mday(), hour(), minute(), second() backends also support additional lubridate functions including yday(), wday(), week(), isoweek(), quarter(), isoyear(), floor_date(), period functions like seconds(), minutes(), hours(), days(), weeks(), months(), years(). Several backends (including PostgreSQL, Snowflake, SQL Server, Redshift, Spark SQL) support clock functions date arithmetic. add_days(), add_years() date_build() get_year(), get_month(), get_day() date_count_between() difftime() clock functions tend easier translate lubridate functions specific.","code":"lf_dt <- lazy_frame(dt = Sys.time())  lf_dt |> transmute(   year = year(dt),   month = month(dt),   day = day(dt) ) #> <SQL> #> SELECT #>   EXTRACT(year FROM \"dt\") AS \"year\", #>   EXTRACT(month FROM \"dt\") AS \"month\", #>   EXTRACT(day FROM \"dt\") AS \"day\" #> FROM \"df\""},{"path":"https://dbplyr.tidyverse.org/dev/articles/translation-function.html","id":"other-functions","dir":"Articles","previous_headings":"Known functions","what":"Other functions","title":"Function translation","text":"pmin(), pmax() parallel min/max desc() descending order cut() binning numeric values categories","code":""},{"path":"https://dbplyr.tidyverse.org/dev/articles/translation-function.html","id":"unknown-functions","dir":"Articles","previous_headings":"","what":"Unknown functions","title":"Function translation","text":"function dbplyr doesn’t know convert left . means database functions covered dbplyr can often used directly.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/articles/translation-function.html","id":"prefix-functions","dir":"Articles","previous_headings":"Unknown functions","what":"Prefix functions","title":"Function translation","text":"function dbplyr doesn’t know left : make clear ’re deliberately calling SQL function, recommend using .sql pronoun: ’re working inside package, also makes easier avoid R CMD CHECK notes. Just import .sql dbplyr using roxygen2 tag like @importFrom dbplyr .sql","code":"lf |> mutate(z = foofify(x, y)) #> <SQL> #> SELECT \"df\".*, foofify(\"x\", \"y\") AS \"z\" #> FROM \"df\" lf |> transmute(z = .sql$foofify(x, y)) #> <SQL> #> SELECT foofify(\"x\", \"y\") AS \"z\" #> FROM \"df\""},{"path":"https://dbplyr.tidyverse.org/dev/articles/translation-function.html","id":"infix-functions","dir":"Articles","previous_headings":"Unknown functions","what":"Infix functions","title":"Function translation","text":"well prefix functions (name function comes arguments), dbplyr also translates infix functions. allows use expressions like LIKE, limited form pattern matching: can also use str_like() common case: use %||% string concatenation, cases ’s R-like use paste() paste0():","code":"lf |> filter(x %LIKE% \"%foo%\") #> <SQL> #> SELECT \"df\".* #> FROM \"df\" #> WHERE (\"x\" LIKE '%foo%') lf |> filter(str_like(x, \"%foo%\")) #> <SQL> #> SELECT \"df\".* #> FROM \"df\" #> WHERE (\"x\" LIKE '%foo%') lf |> transmute(z = x %||% y) #> <SQL> #> SELECT \"x\" || \"y\" AS \"z\" #> FROM \"df\" lf |> transmute(z = paste0(x, y)) #> <SQL> #> SELECT CONCAT_WS('', \"x\", \"y\") AS \"z\" #> FROM \"df\" lf |> transmute(z = paste(x, y)) #> <SQL> #> SELECT CONCAT_WS(' ', \"x\", \"y\") AS \"z\" #> FROM \"df\""},{"path":"https://dbplyr.tidyverse.org/dev/articles/translation-function.html","id":"special-forms","dir":"Articles","previous_headings":"Unknown functions","what":"Special forms","title":"Function translation","text":"SQL functions tend greater variety syntax R. means number expressions can’t translated directly R code. insert queries, can use literal SQL inside sql(): gives lot freedom generate SQL need:","code":"lf |> transmute(z = sql(\"x!\")) #> <SQL> #> SELECT x! AS \"z\" #> FROM \"df\" lf |> transmute(z = x == sql(\"ANY VALUES(1, 2, 3)\")) #> <SQL> #> SELECT \"x\" = ANY VALUES(1, 2, 3) AS \"z\" #> FROM \"df\" lf |> transmute(factorial = sql(\"x!\")) #> <SQL> #> SELECT x! AS \"factorial\" #> FROM \"df\" lf |> transmute(factorial = sql(\"CAST(x AS FLOAT)\")) #> <SQL> #> SELECT CAST(x AS FLOAT) AS \"factorial\" #> FROM \"df\""},{"path":"https://dbplyr.tidyverse.org/dev/articles/translation-function.html","id":"error-for-unknown-translations","dir":"Articles","previous_headings":"Unknown functions","what":"Error for unknown translations","title":"Function translation","text":"needed, can also use dplyr.strict_sql option force dbplyr error doesn’t know translate function:","code":"options(dplyr.strict_sql = TRUE) lf |> mutate(z = glob(x, y)) #> Error in `glob()`: #> ! Don't know how to translate `glob()`"},{"path":"https://dbplyr.tidyverse.org/dev/articles/translation-function.html","id":"window-functions","dir":"Articles","previous_headings":"","what":"Window functions","title":"Function translation","text":"Things get little trickier window functions, SQL’s window functions considerably expressive specific variants provided base R dplyr. form [expression] ([partition clause] [order clause] [frame_clause]): expression combination variable names window functions. Support window functions varies database database, support: ranking: row_number(), min_rank(), rank(), dense_rank(), percent_rank(), cume_dist(), ntile(); offsets: lead(), lag(), first(), last(), nth(); aggregates: mean(), sum(), min(), max(), n(), n_distinct(); cumulative: cummean(), cumsum(), cummin(), cummax(). partition clause specifies window function broken groups. plays analogous role GROUP aggregate functions, group_by() dplyr. possible different window functions partitioned different groups, databases support , neither dplyr. order clause controls ordering (makes difference). important ranking functions since specifies variables rank , ’s also needed cumulative functions lead. Whenever ’re thinking SQL, must always tell variable defines order. order clause missing needed, databases fail error message others return non-deterministic results. frame clause defines rows, frame, passed window function, describing rows (relative current row) included. frame clause provides two offsets determine start end frame. three special values: -Inf means include preceding rows (SQL, “unbounded preceding”), 0 means current row (“current row”), Inf means following rows (“unbounded following”). complete set options comprehensive, fairly confusing, summarised visually .  many possible specifications, three commonly used. select aggregation variants: Recycled: UNBOUND PRECEDING UNBOUND FOLLOWING Cumulative: UNBOUND PRECEDING CURRENT ROW Rolling: 2 PRECEDING 2 FOLLOWING dbplyr generates frame clause based whether ’re using recycled aggregate cumulative aggregate. see individual window functions translated SQL, can use transmute(): lazy frame grouped arranged previously pipeline, dbplyr use information set “partition ” “order ” clauses: challenges translating window functions R SQL, dbplyr tries keep window functions similar possible existing R analogues SQL functions. means three ways control order clause depending window function ’re using: ranking functions, ordering variable first argument: rank(x), ntile(y, 2). omitted NULL, use default ordering associated tbl (set arrange()). Accumulating aggregates take single argument (vector aggregate). control ordering, use order_by(). Aggregates implemented dplyr (lead(), lag(), nth(), first(), last()) order_by argument. Supply override default ordering. three options illustrated snippet : Currently way order multiple variables, except setting default ordering arrange(). added future release.","code":"lf <- lazy_frame(g = 1, year = 2020, id = 3, con = simulate_dbi())  lf |> transmute(   mean = mean(g),    rank = min_rank(g),    cumsum = cumsum(g),   lag = lag(g) ) #> Warning: Windowed expression `SUM(\"g\")` does not have explicit order. #> ℹ Please use `arrange()`, `window_order()`, or `.order` to make #>   deterministic. #> <SQL> #> SELECT #>   AVG(\"g\") OVER () AS \"mean\", #>   CASE #> WHEN (NOT((\"g\" IS NULL))) THEN RANK() OVER (PARTITION BY (CASE WHEN ((\"g\" IS NULL)) THEN 1 ELSE 0 END) ORDER BY \"g\") #> END AS \"rank\", #>   SUM(\"g\") OVER (ROWS UNBOUNDED PRECEDING) AS \"cumsum\", #>   LAG(\"g\", 1, NULL) OVER () AS \"lag\" #> FROM \"df\" lf |> arrange(year) |> mutate(z = cummean(g)) #> <SQL> #> SELECT \"df\".*, AVG(\"g\") OVER (ORDER BY \"year\" ROWS UNBOUNDED PRECEDING) AS \"z\" #> FROM \"df\" #> ORDER BY \"year\" lf |> group_by(id) |> mutate(z = rank()) #> <SQL> #> SELECT \"df\".*, RANK() OVER (PARTITION BY \"id\") AS \"z\" #> FROM \"df\" lf |> transmute(   x1 = min_rank(g),   x2 = order_by(year, cumsum(g)),   x3 = lead(g, order_by = year) ) #> <SQL> #> SELECT #>   CASE #> WHEN (NOT((\"g\" IS NULL))) THEN RANK() OVER (PARTITION BY (CASE WHEN ((\"g\" IS NULL)) THEN 1 ELSE 0 END) ORDER BY \"g\") #> END AS \"x1\", #>   SUM(\"g\") OVER (ORDER BY \"year\" ROWS UNBOUNDED PRECEDING) AS \"x2\", #>   LEAD(\"g\", 1, NULL) OVER (ORDER BY \"year\") AS \"x3\" #> FROM \"df\""},{"path":"https://dbplyr.tidyverse.org/dev/articles/translation-verb.html","id":"single-table-verbs","dir":"Articles","previous_headings":"","what":"Single table verbs","title":"Verb translation","text":"select() mutate() modify SELECT clause: filter() generates clause: arrange() generates ORDER clause: summarise() group_by() work together generate GROUP clause:","code":"flights |>   select(contains(\"delay\")) |>   show_query() #> <SQL> #> SELECT `dep_delay`, `arr_delay` #> FROM `nycflights13::flights`  flights |>   select(distance, air_time) |>     mutate(speed = distance / (air_time / 60)) |>   show_query() #> <SQL> #> SELECT `distance`, `air_time`, `distance` / (`air_time` / 60.0) AS `speed` #> FROM `nycflights13::flights` flights |>    filter(month == 1, day == 1) |>   show_query() #> <SQL> #> SELECT `nycflights13::flights`.* #> FROM `nycflights13::flights` #> WHERE (`month` = 1.0) AND (`day` = 1.0) flights |>    arrange(carrier, desc(arr_delay)) |>   show_query() #> <SQL> #> SELECT `nycflights13::flights`.* #> FROM `nycflights13::flights` #> ORDER BY `carrier`, `arr_delay` DESC flights |>   group_by(month, day) |>   summarise(delay = mean(dep_delay, na.rm = TRUE)) |>   show_query() #> `summarise()` has grouped output by \"month\". You can override using #> the `.groups` argument. #> <SQL> #> SELECT `month`, `day`, AVG(`dep_delay`) AS `delay` #> FROM `nycflights13::flights` #> GROUP BY `month`, `day`"},{"path":"https://dbplyr.tidyverse.org/dev/articles/translation-verb.html","id":"subqueries","dir":"Articles","previous_headings":"","what":"Subqueries","title":"Verb translation","text":"’s always possible translate single dplyr verb single SQL query. example, SQL, variables SELECT clause come another table; can’t refer variable just created. reason, dbplyr create subqueries needed: ’s also possible use CTE desire: Sometimes dbplyr create subquery ’s strictly necessary. strive avoid much possible, analysis generated SQL always complete, ’ll typically err side safety (creating subqueries) rather performance. ’s important know SQL dialects either error include LIMIT ORDER statements inside subqueries. reason, always put head() arrange() late possible pipeline.","code":"flights |>   select(distance, air_time) |>     mutate(     air_time_h = air_time / 60,     speed = distance / air_time_h) |>   show_query() #> <SQL> #> SELECT `q01`.*, `distance` / `air_time_h` AS `speed` #> FROM ( #>   SELECT `distance`, `air_time`, `air_time` / 60.0 AS `air_time_h` #>   FROM `nycflights13::flights` #> ) AS `q01` flights |>   select(distance, air_time) |>     mutate(     air_time_h = air_time / 60,     speed = distance / air_time_h) |>   show_query(sql_options = sql_options(cte = TRUE)) #> <SQL> #> WITH `q01` AS ( #>   SELECT `distance`, `air_time`, `air_time` / 60.0 AS `air_time_h` #>   FROM `nycflights13::flights` #> ) #> SELECT `q01`.*, `distance` / `air_time_h` AS `speed` #> FROM `q01`"},{"path":"https://dbplyr.tidyverse.org/dev/articles/translation-verb.html","id":"dual-table-verbs","dir":"Articles","previous_headings":"","what":"Dual table verbs","title":"Verb translation","text":"x y don’t tables database. specify copy = TRUE, dplyr copy y table location x variable. useful ’ve downloaded summarised dataset determined subset interest now want full data . can use semi_join(x, y, copy = TRUE) upload indices interest temporary table database x, perform efficient semi join database. ’re working large data, maybe also helpful set auto_index = TRUE. automatically add index join variables temporary table.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/articles/translation-verb.html","id":"behind-the-scenes","dir":"Articles","previous_headings":"","what":"Behind the scenes","title":"Verb translation","text":"verb level SQL translation implemented top tbl_lazy, basically tracks operations perform pipeline (see lazy-ops.R). Turning SQL query takes place three steps: sql_build() recurses lazy op data structure building query objects (select_query(), join_query(), set_op_query() etc) represent different subtypes SELECT queries might generate. sql_optimise() takes pass SQL objects, looking potential optimisations. Currently involves removing subqueries possible. sql_render() calls SQL generation function (sql_query_select(), sql_query_join(), sql_query_semi_join(), sql_query_set_op(), …) produce actual SQL. functions generic, taking connection argument, translation can customised different databases.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Hadley Wickham. Author, maintainer. Maximilian Girlich. Author. Edgar Ruiz. Author. . Copyright holder, funder.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Wickham H, Girlich M, Ruiz E (2025). dbplyr: 'dplyr' Back End Databases. R package version 2.5.1.9000, https://dbplyr.tidyverse.org/.","code":"@Manual{,   title = {dbplyr: A 'dplyr' Back End for Databases},   author = {Hadley Wickham and Maximilian Girlich and Edgar Ruiz},   year = {2025},   note = {R package version 2.5.1.9000},   url = {https://dbplyr.tidyverse.org/}, }"},{"path":[]},{"path":"https://dbplyr.tidyverse.org/dev/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"A dplyr backend for databases","text":"dbplyr database backend dplyr. allows use remote database tables -memory data frames automatically converting dplyr code SQL. learn might use dbplyr instead writing SQL, see vignette(\"sql\"). learn details SQL translation, see vignette(\"translation-verb\") vignette(\"translation-function\").","code":""},{"path":"https://dbplyr.tidyverse.org/dev/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"A dplyr backend for databases","text":"","code":"# The easiest way to get dbplyr is to install the whole tidyverse: install.packages(\"tidyverse\")  # Alternatively, install just dbplyr: install.packages(\"dbplyr\")  # Or the development version from GitHub: # install.packages(\"pak\") pak::pak(\"tidyverse/dbplyr\")"},{"path":"https://dbplyr.tidyverse.org/dev/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"A dplyr backend for databases","text":"dbplyr designed work database tables local data frames. demonstrate ’ll first create -memory SQLite database copy dataset: Note don’t actually need load dbplyr library(dbplyr); dplyr automatically loads sees working database. Database connections coordinated DBI package. Learn https://dbi.r-dbi.org/ Now can retrieve table using tbl() (see ?tbl_dbi details). Printing just retrieves first rows: dplyr calls evaluated lazily, generating SQL sent database request data.","code":"library(dplyr, warn.conflicts = FALSE)  con <- DBI::dbConnect(RSQLite::SQLite(), \":memory:\") copy_to(con, mtcars) mtcars2 <- tbl(con, \"mtcars\") mtcars2 #> # Source:   table<`mtcars`> [?? x 11] #> # Database: sqlite 3.50.4 [:memory:] #>      mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb #>    <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> #>  1  21       6  160    110  3.9   2.62  16.5     0     1     4     4 #>  2  21       6  160    110  3.9   2.88  17.0     0     1     4     4 #>  3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1 #>  4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1 #>  5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2 #>  6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1 #>  7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4 #>  8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2 #>  9  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2 #> 10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4 #> # ℹ more rows # lazily generates query summary <- mtcars2 |>    group_by(cyl) |>    summarise(mpg = mean(mpg, na.rm = TRUE)) |>    arrange(desc(mpg))  # see query summary |> show_query() #> <SQL> #> SELECT `cyl`, AVG(`mpg`) AS `mpg` #> FROM `mtcars` #> GROUP BY `cyl` #> ORDER BY `mpg` DESC  # execute query and retrieve results summary |> collect() #> # A tibble: 3 × 2 #>     cyl   mpg #>   <dbl> <dbl> #> 1     4  26.7 #> 2     6  19.7 #> 3     8  15.1"},{"path":"https://dbplyr.tidyverse.org/dev/index.html","id":"code-of-conduct","dir":"","previous_headings":"","what":"Code of Conduct","title":"A dplyr backend for databases","text":"Please note dbplyr project released Contributor Code Conduct. contributing project, agree abide terms.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/arrange.tbl_lazy.html","id":null,"dir":"Reference","previous_headings":"","what":"Arrange rows by column values — arrange.tbl_lazy","title":"Arrange rows by column values — arrange.tbl_lazy","text":"method dplyr dplyr::arrange() generic. generates ORDER clause SQL query. also affects window_order() windowed expressions mutate.tbl_lazy(). Note ORDER clauses can generally appear subqueries, means arrange() late possible pipelines.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/arrange.tbl_lazy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Arrange rows by column values — arrange.tbl_lazy","text":"","code":"# S3 method for class 'tbl_lazy' arrange(.data, ..., .by_group = FALSE)"},{"path":"https://dbplyr.tidyverse.org/dev/reference/arrange.tbl_lazy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Arrange rows by column values — arrange.tbl_lazy","text":".data lazy data frame backed database query. ... <data-masking> Variables, functions variables. Use desc() sort variable descending order. .by_group TRUE, sort first grouping variable. Applies grouped data frames .","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/arrange.tbl_lazy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Arrange rows by column values — arrange.tbl_lazy","text":"Another tbl_lazy. Use show_query() see generated query, use collect() execute query return data R.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/arrange.tbl_lazy.html","id":"missing-values","dir":"Reference","previous_headings":"","what":"Missing values","title":"Arrange rows by column values — arrange.tbl_lazy","text":"Unlike R, databases sorts NA (NULLs) front. can can override behaviour explicitly sorting .na(x).","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/arrange.tbl_lazy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Arrange rows by column values — arrange.tbl_lazy","text":"","code":"library(dplyr, warn.conflicts = FALSE)  db <- memdb_frame(a = c(3, 4, 1, 2), b = c(5, 1, 2, NA)) db |> arrange(a) |> show_query() #> <SQL> #> SELECT `dbplyr_tmp_lKLUUEdLie`.* #> FROM `dbplyr_tmp_lKLUUEdLie` #> ORDER BY `a`  # Note that NAs are sorted first db |> arrange(b) #> # A query:    ?? x 2 #> # Database:   sqlite 3.51.1 [:memory:] #> # Ordered by: b #>       a     b #>   <dbl> <dbl> #> 1     2    NA #> 2     4     1 #> 3     1     2 #> 4     3     5 # override by sorting on is.na() first db |> arrange(is.na(b), b) #> # A query:    ?? x 2 #> # Database:   sqlite 3.51.1 [:memory:] #> # Ordered by: is.na(b), b #>       a     b #>   <dbl> <dbl> #> 1     4     1 #> 2     1     2 #> 3     3     5 #> 4     2    NA"},{"path":[]},{"path":"https://dbplyr.tidyverse.org/dev/reference/as.sql.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert to sql (deprecated) — as.sql","text":"","code":"as.sql(x, con)"},{"path":"https://dbplyr.tidyverse.org/dev/reference/as.sql.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert to sql (deprecated) — as.sql","text":"x Object coerce con Needed x directly supplied user schema specifications can quoted using correct identifiers.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/backend-access.html","id":null,"dir":"Reference","previous_headings":"","what":"Backend: MS Access — backend-access","title":"Backend: MS Access — backend-access","text":"See vignette(\"translation-function\") vignette(\"translation-verb\") details overall translation technology. Key differences backend : SELECT uses TOP, LIMIT Non-standard types mathematical functions String concatenation uses & ANALYZE equivalent TRUE FALSE converted 1 0 Use simulate_access() lazy_frame() see simulated SQL without converting live access database.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/backend-access.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Backend: MS Access — backend-access","text":"","code":"simulate_access()"},{"path":"https://dbplyr.tidyverse.org/dev/reference/backend-access.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Backend: MS Access — backend-access","text":"","code":"library(dplyr, warn.conflicts = FALSE) lf <- lazy_frame(x = 1, y = 2, z = \"a\", con = simulate_access())  lf |> head() #> <SQL> #> SELECT TOP 6 \"df\".* #> FROM \"df\" lf |> mutate(y = as.numeric(y), z = sqrt(x^2 + 10)) #> <SQL> #> SELECT \"x\", CDBL(\"y\") AS \"y\", SQR((\"x\" ^ 2.0) + 10.0) AS \"z\" #> FROM \"df\" lf |> mutate(a = paste0(z, \" times\")) #> <SQL> #> SELECT \"df\".*, \"z\" & ' times' AS \"a\" #> FROM \"df\""},{"path":"https://dbplyr.tidyverse.org/dev/reference/backend-hana.html","id":null,"dir":"Reference","previous_headings":"","what":"Backend: SAP HANA — backend-hana","title":"Backend: SAP HANA — backend-hana","text":"See vignette(\"translation-function\") vignette(\"translation-verb\") details overall translation technology. Key differences backend : Temporary tables get # prefix use LOCAL TEMPORARY COLUMN. table analysis performed dplyr::copy_to(). paste() uses || Note create new boolean columns logical expressions; need wrap explicit ifelse: ifelse(x > y, TRUE, FALSE). Use simulate_hana() lazy_frame() see simulated SQL without converting live access database.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/backend-hana.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Backend: SAP HANA — backend-hana","text":"","code":"simulate_hana()"},{"path":"https://dbplyr.tidyverse.org/dev/reference/backend-hana.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Backend: SAP HANA — backend-hana","text":"","code":"library(dplyr, warn.conflicts = FALSE)  lf <- lazy_frame(a = TRUE, b = 1, c = 2, d = \"z\", con = simulate_hana()) lf |> transmute(x = paste0(d, \" times\")) #> <SQL> #> SELECT \"d\" || ' times' AS \"x\" #> FROM \"df\""},{"path":"https://dbplyr.tidyverse.org/dev/reference/backend-hive.html","id":null,"dir":"Reference","previous_headings":"","what":"Backend: Hive — backend-hive","title":"Backend: Hive — backend-hive","text":"See vignette(\"translation-function\") vignette(\"translation-verb\") details overall translation technology. Key differences backend scattering custom translations provided users. Use simulate_hive() lazy_frame() see simulated SQL without converting live access database.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/backend-hive.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Backend: Hive — backend-hive","text":"","code":"simulate_hive()"},{"path":"https://dbplyr.tidyverse.org/dev/reference/backend-hive.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Backend: Hive — backend-hive","text":"","code":"library(dplyr, warn.conflicts = FALSE)  lf <- lazy_frame(a = TRUE, b = 1, d = 2, c = \"z\", con = simulate_hive()) lf |> transmute(x = cot(b)) #> <SQL> #> SELECT 1.0 / TAN(\"b\") AS \"x\" #> FROM \"df\" lf |> transmute(x = bitwShiftL(c, 1L)) #> <SQL> #> SELECT SHIFTLEFT(\"c\", 1) AS \"x\" #> FROM \"df\" lf |> transmute(x = str_replace_all(c, \"a\", \"b\")) #> <SQL> #> SELECT REGEXP_REPLACE(\"c\", 'a', 'b') AS \"x\" #> FROM \"df\"  lf |> summarise(x = median(d, na.rm = TRUE)) #> <SQL> #> SELECT PERCENTILE(\"d\", 0.5) AS \"x\" #> FROM \"df\" lf |> summarise(x = var(c, na.rm = TRUE)) #> <SQL> #> SELECT VARIANCE(\"c\") AS \"x\" #> FROM \"df\""},{"path":"https://dbplyr.tidyverse.org/dev/reference/backend-impala.html","id":null,"dir":"Reference","previous_headings":"","what":"Backend: Impala — backend-impala","title":"Backend: Impala — backend-impala","text":"See vignette(\"translation-function\") vignette(\"translation-verb\") details overall translation technology. Key differences backend scattering custom translations provided users, mostly focussed bitwise operations. Use simulate_impala() lazy_frame() see simulated SQL without converting live access database.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/backend-impala.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Backend: Impala — backend-impala","text":"","code":"simulate_impala()"},{"path":"https://dbplyr.tidyverse.org/dev/reference/backend-impala.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Backend: Impala — backend-impala","text":"","code":"library(dplyr, warn.conflicts = FALSE)  lf <- lazy_frame(a = TRUE, b = 1, c = 2, d = \"z\", con = simulate_impala()) lf |> transmute(X = bitwNot(bitwOr(b, c))) #> <SQL> #> SELECT BITNOT(BITOR(\"b\", \"c\")) AS \"X\" #> FROM \"df\""},{"path":"https://dbplyr.tidyverse.org/dev/reference/backend-mssql.html","id":null,"dir":"Reference","previous_headings":"","what":"Backend: SQL server — backend-mssql","title":"Backend: SQL server — backend-mssql","text":"See vignette(\"translation-function\") vignette(\"translation-verb\") details overall translation technology. Key differences backend : SELECT uses TOP LIMIT Automatically prefixes # create temporary tables. Add prefix avoid message. String basics: paste(), substr(), nchar() Custom types .* functions Lubridate extraction functions, year(), month(), day() etc Semi-automated bit <-> boolean translation (see ) stringr functions str_detect(), str_starts(), str_ends() fixed() patterns work versions; regular expression patterns require SQL Server 2025+ (version 17.0) stringr functions str_replace(), str_replace_all(), str_remove(), str_remove_all(), str_extract(), str_count() require SQL Server 2025+ (version 17.0) Use simulate_mssql() lazy_frame() see simulated SQL without converting live access database.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/backend-mssql.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Backend: SQL server — backend-mssql","text":"","code":"simulate_mssql(version = \"15.0\")"},{"path":"https://dbplyr.tidyverse.org/dev/reference/backend-mssql.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Backend: SQL server — backend-mssql","text":"version Version MS SQL simulate. Currently, 11.0 use TRY_CAST() instead CAST(), 17.0 support regular expression patterns stringr functions.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/backend-mssql.html","id":"bit-vs-boolean","dir":"Reference","previous_headings":"","what":"Bit vs boolean","title":"Backend: SQL server — backend-mssql","text":"SQL server uses two incompatible types represent TRUE FALSE values: BOOLEAN type result logical comparisons (e.g. x > y) can used create new columns SELECT. https://learn.microsoft.com/en-us/sql/t-sql/language-elements/comparison-operators-transact-sql BIT type special type numeric column used store TRUE FALSE values, used clauses. https://learn.microsoft.com/en-us/sql/t-sql/data-types/bit-transact-sql?view=sql-server-ver15 dbplyr best automatically create correct type needed, 100% correctly full type inference system. means many need manually conversions time time. convert bit boolean use x == 1 convert boolean bit use .logical((x, 0, 1))","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/backend-mssql.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Backend: SQL server — backend-mssql","text":"","code":"library(dplyr, warn.conflicts = FALSE)  lf <- lazy_frame(a = TRUE, b = 1, c = 2, d = \"z\", con = simulate_mssql()) lf |> head() #> Warning: EOF within quoted string #> Warning: EOF within quoted string #> Warning: EOF within quoted string #> <SQL> #> SELECT TOP 6 [df]] #> ].* #> FROM [df] lf |> transmute(x = paste(b, c, d)) #> Warning: EOF within quoted string #> Warning: EOF within quoted string #> <SQL> #> SELECT [b] + ' ' + [c] + ' ' + [d] AS [x] #> FROM [df]  # Can use boolean as is: lf |> filter(c > d) #> Warning: EOF within quoted string #> Warning: EOF within quoted string #> Warning: EOF within quoted string #> <SQL> #> SELECT [df]] #> ].* #> FROM [df] #> WHERE ([c] > [d]) # Need to convert from boolean to bit: lf |> transmute(x = c > d) #> Warning: EOF within quoted string #> Warning: EOF within quoted string #> <SQL> #> SELECT CAST(IIF([c] > [d], 1, 0) AS BIT) AS [x] #> FROM [df] # Can use boolean as is: lf |> transmute(x = ifelse(c > d, \"c\", \"d\")) #> Warning: EOF within quoted string #> Warning: EOF within quoted string #> <SQL> #> SELECT CASE WHEN ([c] > [d]) THEN 'c' WHEN NOT ([c] > [d]) THEN 'd' END AS [x] #> FROM [df]"},{"path":"https://dbplyr.tidyverse.org/dev/reference/backend-mysql.html","id":null,"dir":"Reference","previous_headings":"","what":"Backend: MySQL/MariaDB — backend-mysql","title":"Backend: MySQL/MariaDB — backend-mysql","text":"See vignette(\"translation-function\") vignette(\"translation-verb\") details overall translation technology. Key differences backend : paste() uses CONCAT_WS() String translations str_detect(), str_locate(), str_replace_all() Clear error message unsupported full joins Use simulate_mysql() lazy_frame() see simulated SQL without converting live access database.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/backend-mysql.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Backend: MySQL/MariaDB — backend-mysql","text":"","code":"simulate_mysql()  simulate_mariadb()"},{"path":"https://dbplyr.tidyverse.org/dev/reference/backend-mysql.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Backend: MySQL/MariaDB — backend-mysql","text":"","code":"library(dplyr, warn.conflicts = FALSE)  lf <- lazy_frame(a = TRUE, b = 1, c = 2, d = \"z\", con = simulate_mysql()) lf |> transmute(x = paste0(d, \" times\")) #> <SQL> #> SELECT CONCAT_WS('', `d`, ' times') AS `x` #> FROM `df`"},{"path":"https://dbplyr.tidyverse.org/dev/reference/backend-odbc.html","id":null,"dir":"Reference","previous_headings":"","what":"Backend: ODBC — backend-odbc","title":"Backend: ODBC — backend-odbc","text":"See vignette(\"translation-function\") vignette(\"translation-verb\") details overall translation technology. Key differences backend minor translations common data types. Use simulate_odbc() lazy_frame() see simulated SQL without converting live access database.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/backend-odbc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Backend: ODBC — backend-odbc","text":"","code":"simulate_odbc()"},{"path":"https://dbplyr.tidyverse.org/dev/reference/backend-odbc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Backend: ODBC — backend-odbc","text":"","code":"library(dplyr, warn.conflicts = FALSE)  lf <- lazy_frame(a = TRUE, b = 1, d = 2, c = \"z\", con = simulate_odbc()) lf |> transmute(x = as.numeric(b)) #> <SQL> #> SELECT CAST(\"b\" AS DOUBLE) AS \"x\" #> FROM \"df\" lf |> transmute(x = as.integer(b)) #> <SQL> #> SELECT CAST(\"b\" AS INT) AS \"x\" #> FROM \"df\" lf |> transmute(x = as.character(b)) #> <SQL> #> SELECT CAST(\"b\" AS STRING) AS \"x\" #> FROM \"df\""},{"path":"https://dbplyr.tidyverse.org/dev/reference/backend-oracle.html","id":null,"dir":"Reference","previous_headings":"","what":"Backend: Oracle — backend-oracle","title":"Backend: Oracle — backend-oracle","text":"See vignette(\"translation-function\") vignette(\"translation-verb\") details overall translation technology. Key differences backend : Use FETCH FIRST instead LIMIT Custom types paste() uses || Custom subquery generation () setdiff() uses MINUS instead EXCEPT Note versions Oracle prior 23c limited supported TRUE FALSE may need use 1 0 instead. See https://oracle-base.com/articles/23/boolean-data-type-23 details. Use simulate_oracle() lazy_frame() see simulated SQL without converting live access database.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/backend-oracle.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Backend: Oracle — backend-oracle","text":"","code":"simulate_oracle()"},{"path":"https://dbplyr.tidyverse.org/dev/reference/backend-oracle.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Backend: Oracle — backend-oracle","text":"","code":"library(dplyr, warn.conflicts = FALSE)  lf <- lazy_frame(a = TRUE, b = 1, c = 2, d = \"z\", con = simulate_oracle()) lf |> transmute(x = paste0(c, \" times\")) #> <SQL> #> SELECT \"c\" || ' times' AS \"x\" #> FROM \"df\" lf |> setdiff(lf) #> <SQL> #> ( #>   SELECT * #>   FROM \"df\" #> ) #> MINUS #> ( #>   SELECT * #>   FROM \"df\" #> )"},{"path":"https://dbplyr.tidyverse.org/dev/reference/backend-postgres.html","id":null,"dir":"Reference","previous_headings":"","what":"Backend: PostgreSQL — backend-postgres","title":"Backend: PostgreSQL — backend-postgres","text":"See vignette(\"translation-function\") vignette(\"translation-verb\") details overall translation technology. Key differences backend : Many stringr functions lubridate date-time extraction functions standard statistical summaries Use simulate_postgres() lazy_frame() see simulated SQL without converting live access database.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/backend-postgres.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Backend: PostgreSQL — backend-postgres","text":"","code":"simulate_postgres()"},{"path":"https://dbplyr.tidyverse.org/dev/reference/backend-postgres.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Backend: PostgreSQL — backend-postgres","text":"","code":"library(dplyr, warn.conflicts = FALSE)  lf <- lazy_frame(a = TRUE, b = 1, c = 2, d = \"z\", con = simulate_postgres()) lf |> summarise(x = sd(b, na.rm = TRUE)) #> <SQL> #> SELECT STDDEV_SAMP(\"b\") AS \"x\" #> FROM \"df\" lf |> summarise(y = cor(b, c), z = cov(b, c)) #> <SQL> #> SELECT CORR(\"b\", \"c\") AS \"y\", COVAR_SAMP(\"b\", \"c\") AS \"z\" #> FROM \"df\""},{"path":"https://dbplyr.tidyverse.org/dev/reference/backend-redshift.html","id":null,"dir":"Reference","previous_headings":"","what":"Backend: Redshift — backend-redshift","title":"Backend: Redshift — backend-redshift","text":"Base translations come PostgreSQL backend. generally differences, apart string manipulation. Use simulate_redshift() lazy_frame() see simulated SQL without converting live access database.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/backend-redshift.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Backend: Redshift — backend-redshift","text":"","code":"simulate_redshift()"},{"path":"https://dbplyr.tidyverse.org/dev/reference/backend-redshift.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Backend: Redshift — backend-redshift","text":"","code":"library(dplyr, warn.conflicts = FALSE)  lf <- lazy_frame(a = TRUE, b = 1, c = 2, d = \"z\", con = simulate_redshift()) lf |> transmute(x = paste(c, \" times\")) #> <SQL> #> SELECT \"c\" || ' ' || ' times' AS \"x\" #> FROM \"df\" lf |> transmute(x = substr(c, 2, 3)) #> <SQL> #> SELECT SUBSTRING(\"c\", 2, 2) AS \"x\" #> FROM \"df\" lf |> transmute(x = str_replace_all(c, \"a\", \"z\")) #> <SQL> #> SELECT REGEXP_REPLACE(\"c\", 'a', 'z') AS \"x\" #> FROM \"df\""},{"path":"https://dbplyr.tidyverse.org/dev/reference/backend-snowflake.html","id":null,"dir":"Reference","previous_headings":"","what":"Backend: Snowflake — backend-snowflake","title":"Backend: Snowflake — backend-snowflake","text":"See vignette(\"translation-function\") vignette(\"translation-verb\") details overall translation technology. Use simulate_snowflake() lazy_frame() see simulated SQL without converting live access database.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/backend-snowflake.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Backend: Snowflake — backend-snowflake","text":"","code":"simulate_snowflake()"},{"path":"https://dbplyr.tidyverse.org/dev/reference/backend-snowflake.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Backend: Snowflake — backend-snowflake","text":"","code":"library(dplyr, warn.conflicts = FALSE)  lf <- lazy_frame(a = TRUE, b = 1, c = 2, d = \"z\", con = simulate_snowflake()) lf |> transmute(x = paste0(d, \" times\")) #> <SQL> #> SELECT ARRAY_TO_STRING(ARRAY_CONSTRUCT_COMPACT(\"d\", ' times'), '') AS \"x\" #> FROM \"df\""},{"path":"https://dbplyr.tidyverse.org/dev/reference/backend-spark-sql.html","id":null,"dir":"Reference","previous_headings":"","what":"Backend: Databricks Spark SQL — backend-spark-sql","title":"Backend: Databricks Spark SQL — backend-spark-sql","text":"See vignette(\"translation-function\") vignette(\"translation-verb\") details overall translation technology. Key differences backend better translation statistical aggregate functions (e.g. var(), median()) use temporary views instead temporary tables copying data. Use simulate_spark_sql() lazy_frame() see simulated SQL without converting live access database.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/backend-spark-sql.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Backend: Databricks Spark SQL — backend-spark-sql","text":"","code":"simulate_spark_sql()"},{"path":"https://dbplyr.tidyverse.org/dev/reference/backend-spark-sql.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Backend: Databricks Spark SQL — backend-spark-sql","text":"","code":"library(dplyr, warn.conflicts = FALSE)  lf <- lazy_frame(a = TRUE, b = 1, d = 2, c = \"z\", con = simulate_spark_sql())  lf |> summarise(x = median(d, na.rm = TRUE)) #> <SQL> #> SELECT MEDIAN(\"d\") AS \"x\" #> FROM \"df\" lf |> summarise(x = var(c, na.rm = TRUE), .by = d) #> <SQL> #> SELECT \"d\", VARIANCE(\"c\") AS \"x\" #> FROM \"df\" #> GROUP BY \"d\"  lf |> mutate(x = first(c)) #> <SQL> #> SELECT \"df\".*, FIRST_VALUE(\"c\") OVER () AS \"x\" #> FROM \"df\" lf |> mutate(x = first(c), .by = d) #> <SQL> #> SELECT \"df\".*, FIRST_VALUE(\"c\") OVER (PARTITION BY \"d\") AS \"x\" #> FROM \"df\""},{"path":"https://dbplyr.tidyverse.org/dev/reference/backend-sqlite.html","id":null,"dir":"Reference","previous_headings":"","what":"Backend: SQLite — backend-sqlite","title":"Backend: SQLite — backend-sqlite","text":"See vignette(\"translation-function\") vignette(\"translation-verb\") details overall translation technology. Key differences backend : Uses non-standard LOG() function Date-time extraction functions lubridate Custom median translation Right full joins simulated using left joins Use simulate_sqlite() lazy_frame() see simulated SQL without converting live access database.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/backend-sqlite.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Backend: SQLite — backend-sqlite","text":"","code":"simulate_sqlite()"},{"path":"https://dbplyr.tidyverse.org/dev/reference/backend-sqlite.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Backend: SQLite — backend-sqlite","text":"","code":"library(dplyr, warn.conflicts = FALSE)  lf <- lazy_frame(a = TRUE, b = 1, c = 2, d = \"z\", con = simulate_sqlite()) lf |> transmute(x = paste(c, \" times\")) #> <SQL> #> SELECT `c` || ' ' || ' times' AS `x` #> FROM `df` lf |> transmute(x = log(b), y = log(b, base = 2)) #> <SQL> #> SELECT LOG(`b`) AS `x`, LOG(`b`) / LOG(2.0) AS `y` #> FROM `df`"},{"path":"https://dbplyr.tidyverse.org/dev/reference/backend-teradata.html","id":null,"dir":"Reference","previous_headings":"","what":"Backend: Teradata — backend-teradata","title":"Backend: Teradata — backend-teradata","text":"See vignette(\"translation-function\") vignette(\"translation-verb\") details overall translation technology. Key differences backend : Uses TOP instead LIMIT Selection user supplied translations Use simulate_teradata() lazy_frame() see simulated SQL without converting live access database.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/backend-teradata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Backend: Teradata — backend-teradata","text":"","code":"simulate_teradata()"},{"path":"https://dbplyr.tidyverse.org/dev/reference/backend-teradata.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Backend: Teradata — backend-teradata","text":"","code":"library(dplyr, warn.conflicts = FALSE)  lf <- lazy_frame(a = TRUE, b = 1, c = 2, d = \"z\", con = simulate_teradata()) lf |> head() #> <SQL> #> SELECT TOP 6 \"df\".* #> FROM \"df\""},{"path":"https://dbplyr.tidyverse.org/dev/reference/build_sql.html","id":null,"dir":"Reference","previous_headings":"","what":"Build a SQL string. — build_sql","title":"Build a SQL string. — build_sql","text":"build_sql() superseded favor sql_glue2(). convenience function prevent sql injection attacks (context dplyr likely accidental deliberate) automatically escaping expressions input, treating bare strings sql. unlikely prevent serious attack, make unlikely produce invalid sql. function used generating SELECT clauses, high level queries, syntax R equivalent. individual function translations, prefer sql_expr().","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/build_sql.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build a SQL string. — build_sql","text":"","code":"build_sql(..., .env = parent.frame(), con = sql_current_con())"},{"path":"https://dbplyr.tidyverse.org/dev/reference/build_sql.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Build a SQL string. — build_sql","text":"... input convert SQL. Use sql() preserve user input (dangerous), ident() label user input sql identifiers (safe) .env environment evaluate arguments. needed typical use. con database connection; used select correct quoting characters.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/build_sql.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Build a SQL string. — build_sql","text":"","code":"con <- simulate_dbi()  # Old: build_sql(\"SELECT * FROM \", ident(\"table\"), con = con) #> Warning: `build_sql()` was deprecated in dbplyr 2.6.0. #> ℹ Please use `sql_glue2()` instead. #> <SQL> SELECT * FROM \"table\" # New: sql_glue2(con, \"SELECT * FROM {.tbl 'table'}\") #> <SQL> SELECT * FROM \"table\"  # Old: name <- \"Robert\" build_sql(\"INSERT INTO students (name) VALUES (\", name, \")\", con = con) #> <SQL> INSERT INTO students (name) VALUES ('Robert') # New: sql_glue2(con, \"INSERT INTO students (name) VALUES ({name})\") #> <SQL> INSERT INTO students (name) VALUES ('Robert')"},{"path":"https://dbplyr.tidyverse.org/dev/reference/collapse.tbl_sql.html","id":null,"dir":"Reference","previous_headings":"","what":"Collapse a query into a subquery — collapse.tbl_sql","title":"Collapse a query into a subquery — collapse.tbl_sql","text":"collapse() forces computation lazy query wrapping subquery. generally needed, can useful need work around database/dbplyr limitations.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/collapse.tbl_sql.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Collapse a query into a subquery — collapse.tbl_sql","text":"","code":"# S3 method for class 'tbl_sql' collapse(x, ...)"},{"path":"https://dbplyr.tidyverse.org/dev/reference/collapse.tbl_sql.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Collapse a query into a subquery — collapse.tbl_sql","text":"x lazy data frame backed database query. ... Ignored.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/collapse.tbl_sql.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Collapse a query into a subquery — collapse.tbl_sql","text":"","code":"library(dplyr, warn.conflicts = FALSE)  db <- memdb_frame(a = c(3, 4, 1, 2), b = c(5, 1, 2, NA)) db |> filter(a <= 2) |> show_query() #> <SQL> #> SELECT `dbplyr_tmp_BVkzIbwPcL`.* #> FROM `dbplyr_tmp_BVkzIbwPcL` #> WHERE (`a` <= 2.0) db |> filter(a <= 2) |> collapse() |> show_query() #> <SQL> #> SELECT `dbplyr_tmp_BVkzIbwPcL`.* #> FROM `dbplyr_tmp_BVkzIbwPcL` #> WHERE (`a` <= 2.0)"},{"path":"https://dbplyr.tidyverse.org/dev/reference/collect.tbl_sql.html","id":null,"dir":"Reference","previous_headings":"","what":"Collect results into a local data frame — collect.tbl_sql","title":"Collect results into a local data frame — collect.tbl_sql","text":"collect() executes query retrieves results local tibble. brings data database R's memory, useful done much possible database, now need use R functions.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/collect.tbl_sql.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Collect results into a local data frame — collect.tbl_sql","text":"","code":"# S3 method for class 'tbl_sql' collect(x, ..., n = Inf, warn_incomplete = TRUE, cte = FALSE)"},{"path":"https://dbplyr.tidyverse.org/dev/reference/collect.tbl_sql.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Collect results into a local data frame — collect.tbl_sql","text":"x lazy data frame backed database query. ... Ignored. n Number rows fetch. Defaults Inf, meaning rows. warn_incomplete Warn n less number result rows? cte Use common table expressions generated SQL?","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/collect.tbl_sql.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Collect results into a local data frame — collect.tbl_sql","text":"","code":"library(dplyr, warn.conflicts = FALSE)  db <- memdb_frame(a = c(3, 4, 1, 2), b = c(5, 1, 2, NA)) db |> filter(a <= 2) |> collect() #> # A tibble: 2 × 2 #>       a     b #>   <dbl> <dbl> #> 1     1     2 #> 2     2    NA"},{"path":"https://dbplyr.tidyverse.org/dev/reference/complete.tbl_lazy.html","id":null,"dir":"Reference","previous_headings":"","what":"Complete a SQL table with missing combinations of data — complete.tbl_lazy","title":"Complete a SQL table with missing combinations of data — complete.tbl_lazy","text":"Turns implicit missing values explicit missing values. method tidyr::complete() generic.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/complete.tbl_lazy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Complete a SQL table with missing combinations of data — complete.tbl_lazy","text":"","code":"# S3 method for class 'tbl_lazy' complete(data, ..., fill = list())"},{"path":"https://dbplyr.tidyverse.org/dev/reference/complete.tbl_lazy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Complete a SQL table with missing combinations of data — complete.tbl_lazy","text":"data lazy data frame backed database query. ... Specification columns expand. See tidyr::expand details. fill named list variable supplies single value use instead NA missing combinations.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/complete.tbl_lazy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Complete a SQL table with missing combinations of data — complete.tbl_lazy","text":"Another tbl_lazy. Use show_query() see generated query, use collect() execute query return data R.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/complete.tbl_lazy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Complete a SQL table with missing combinations of data — complete.tbl_lazy","text":"","code":"df <- memdb_frame(   group = c(1:2, 1),   item_id = c(1:2, 2),   item_name = c(\"a\", \"b\", \"b\"),   value1 = 1:3,   value2 = 4:6 )  df |> tidyr::complete(group, nesting(item_id, item_name)) #> # A query:  ?? x 5 #> # Database: sqlite 3.51.1 [:memory:] #>   group item_id item_name value1 value2 #>   <dbl>   <dbl> <chr>      <int>  <int> #> 1     1       1 a              1      4 #> 2     1       2 b              3      6 #> 3     2       1 a             NA     NA #> 4     2       2 b              2      5  # You can also choose to fill in missing values df |> tidyr::complete(group, nesting(item_id, item_name), fill = list(value1 = 0)) #> # A query:  ?? x 5 #> # Database: sqlite 3.51.1 [:memory:] #>   group item_id item_name value1 value2 #>   <dbl>   <dbl> <chr>      <dbl>  <int> #> 1     1       1 a              1      4 #> 2     1       2 b              3      6 #> 3     2       1 a              0     NA #> 4     2       2 b              2      5"},{"path":"https://dbplyr.tidyverse.org/dev/reference/compute.tbl_sql.html","id":null,"dir":"Reference","previous_headings":"","what":"Save results into a new remote table — compute.tbl_sql","title":"Save results into a new remote table — compute.tbl_sql","text":"compute() executes query stores results new remote table. useful want cache intermediate results reuse improve performance avoiding repeated computation complex queries.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/compute.tbl_sql.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Save results into a new remote table — compute.tbl_sql","text":"","code":"# S3 method for class 'tbl_sql' compute(   x,   name = NULL,   temporary = TRUE,   overwrite = FALSE,   unique_indexes = list(),   indexes = list(),   analyze = TRUE,   ...,   cte = FALSE )"},{"path":"https://dbplyr.tidyverse.org/dev/reference/compute.tbl_sql.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Save results into a new remote table — compute.tbl_sql","text":"x lazy data frame backed database query. name Name new remote table. Use string create table current catalog/schema. Use () create table specific catalog/schema, e.g. (\"schema.table\"). temporary TRUE, create temporary table local connection automatically deleted connection expires overwrite TRUE, overwrite existing table name name. FALSE, throw error name already exists. unique_indexes list character vectors. element list create new unique index specified column(s). Duplicate rows result failure. indexes list character vectors. element list create new index. analyze TRUE (default), automatically ANALYZE new table query optimiser useful information. ... Ignored. cte Use common table expressions generated SQL?","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/compute.tbl_sql.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Save results into a new remote table — compute.tbl_sql","text":"","code":"library(dplyr, warn.conflicts = FALSE)  db <- memdb_frame(a = c(3, 4, 1, 2), b = c(5, 1, 2, NA)) db |> filter(a <= 2) |> show_query() #> <SQL> #> SELECT `dbplyr_tmp_N1WRZorR1u`.* #> FROM `dbplyr_tmp_N1WRZorR1u` #> WHERE (`a` <= 2.0) db |> filter(a <= 2) |> compute() |> show_query() #> <SQL> #> SELECT * #> FROM `dbplyr_tmp_qwECZ3jx2i`"},{"path":"https://dbplyr.tidyverse.org/dev/reference/copy_inline.html","id":null,"dir":"Reference","previous_headings":"","what":"Use a local data frame in a dbplyr query — copy_inline","title":"Use a local data frame in a dbplyr query — copy_inline","text":"alternative dplyr::copy_to() need write access faster small data.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/copy_inline.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Use a local data frame in a dbplyr query — copy_inline","text":"","code":"copy_inline(con, df, types = NULL)"},{"path":"https://dbplyr.tidyverse.org/dev/reference/copy_inline.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Use a local data frame in a dbplyr query — copy_inline","text":"con database connection. df local data frame. data written directly SQL query small. types named character vector SQL data types use columns. data types backend specific. example Postgres c(id = \"bigint\", created_at = \"timestamp\", values = \"integer[]\"). NULL, default, types determined df.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/copy_inline.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Use a local data frame in a dbplyr query — copy_inline","text":"tbl_lazy.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/copy_inline.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Use a local data frame in a dbplyr query — copy_inline","text":"writes data directly SQL query via VALUES clause.","code":""},{"path":[]},{"path":"https://dbplyr.tidyverse.org/dev/reference/copy_inline.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Use a local data frame in a dbplyr query — copy_inline","text":"","code":"df <- data.frame(x = 1:3, y = c(\"a\", \"b\", \"c\")) con <- DBI::dbConnect(RSQLite::SQLite(), \":memory:\")  copy_inline(con, df) #> # A query:  ?? x 2 #> # Database: sqlite 3.51.1 [:memory:] #>       x y     #>   <int> <chr> #> 1     1 a     #> 2     2 b     #> 3     3 c      copy_inline(con, df) |> dplyr::show_query() #> <SQL> #> SELECT CAST(`x` AS INTEGER) AS `x`, CAST(`y` AS TEXT) AS `y` #> FROM ( #>   SELECT NULL AS `x`, NULL AS `y` #>   WHERE (0 = 1) #>  #>   UNION ALL #>  #>   VALUES (1, 'a'), (2, 'b'), (3, 'c') #> ) AS `values_table`"},{"path":"https://dbplyr.tidyverse.org/dev/reference/copy_to.src_sql.html","id":null,"dir":"Reference","previous_headings":"","what":"Copy a local data frame to a remote database — copy_to.src_sql","title":"Copy a local data frame to a remote database — copy_to.src_sql","text":"implementation dplyr dplyr::copy_to() generic mostly wrapper around DBI::dbWriteTable(). useful copying small amounts data database examples, experiments, joins. default, creates temporary tables visible within current connection database.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/copy_to.src_sql.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Copy a local data frame to a remote database — copy_to.src_sql","text":"","code":"# S3 method for class 'src_sql' copy_to(   dest,   df,   name = deparse(substitute(df)),   overwrite = FALSE,   types = NULL,   temporary = TRUE,   unique_indexes = NULL,   indexes = NULL,   analyze = TRUE,   ...,   in_transaction = TRUE )"},{"path":"https://dbplyr.tidyverse.org/dev/reference/copy_to.src_sql.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Copy a local data frame to a remote database — copy_to.src_sql","text":"dest remote data source df local data frame, tbl_sql source, tbl_sql another source. another source, data must transition R one pass, suitable transferring small amounts data. name Name new remote table. Use string create table current catalog/schema. Use () create table specific catalog/schema, e.g. (\"schema.table\"). overwrite TRUE, overwrite existing table name name. FALSE, throw error name already exists. types character vector giving variable types use columns. See https://www.sqlite.org/datatype3.html available types. temporary TRUE, create temporary table local connection automatically deleted connection expires unique_indexes list character vectors. element list create new unique index specified column(s). Duplicate rows result failure. indexes list character vectors. element list create new index. analyze TRUE (default), automatically ANALYZE new table query optimiser useful information. ... parameters passed methods. in_transaction table creation wrapped transaction? typically makes things faster, may want suppress database support transactions, wrapping transaction higher (database support nested transactions.)","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/copy_to.src_sql.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Copy a local data frame to a remote database — copy_to.src_sql","text":"Another tbl_lazy. Use show_query() see generated query, use collect() execute query return data R.","code":""},{"path":[]},{"path":"https://dbplyr.tidyverse.org/dev/reference/copy_to.src_sql.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Copy a local data frame to a remote database — copy_to.src_sql","text":"","code":"library(dplyr, warn.conflicts = FALSE)  df <- data.frame(x = 1:5, y = letters[5:1]) db <- copy_to(memdb(), df) db #> # A query:  ?? x 2 #> # Database: sqlite 3.51.1 [:memory:] #>       x y     #>   <int> <chr> #> 1     1 e     #> 2     2 d     #> 3     3 c     #> 4     4 b     #> 5     5 a      df2 <- data.frame(y = c(\"a\", \"d\"), fruit = c(\"apple\", \"date\")) # copy_to() is called automatically if you set copy = TRUE # in the join functions db |> left_join(df2, copy = TRUE) #> Joining with `by = join_by(y)` #> # A query:  ?? x 3 #> # Database: sqlite 3.51.1 [:memory:] #>       x y     fruit #>   <int> <chr> <chr> #> 1     1 e     NA    #> 2     2 d     date  #> 3     3 c     NA    #> 4     4 b     NA    #> 5     5 a     apple"},{"path":"https://dbplyr.tidyverse.org/dev/reference/count.tbl_lazy.html","id":null,"dir":"Reference","previous_headings":"","what":"Count observations by group — count.tbl_lazy","title":"Count observations by group — count.tbl_lazy","text":"methods dplyr dplyr::count() dplyr::tally() generics. wrap group_by.tbl_lazy(), summarise.tbl_lazy() , optionally, arrange.tbl_lazy().","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/count.tbl_lazy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Count observations by group — count.tbl_lazy","text":"","code":"# S3 method for class 'tbl_lazy' count(x, ..., wt = NULL, sort = FALSE, name = NULL)  # S3 method for class 'tbl_lazy' add_count(x, ..., wt = NULL, sort = FALSE, name = NULL, .drop = NULL)  # S3 method for class 'tbl_lazy' tally(x, wt = NULL, sort = FALSE, name = NULL)"},{"path":"https://dbplyr.tidyverse.org/dev/reference/count.tbl_lazy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Count observations by group — count.tbl_lazy","text":"x data frame, data frame extension (e.g. tibble), lazy data frame (e.g. dbplyr dtplyr). ... <data-masking> Variables, functions variables. Use desc() sort variable descending order. wt <data-masking> Frequency weights. Can NULL variable: NULL (default), counts number rows group. variable, computes sum(wt) group. sort TRUE, show largest groups top. name name new column output. omitted, default n. already column called n, use nn. column called n nn, 'll use nnn, , adding ns gets new name. .drop supported lazy tables.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/count.tbl_lazy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Count observations by group — count.tbl_lazy","text":"","code":"library(dplyr, warn.conflicts = FALSE)  db <- memdb_frame(g = c(1, 1, 1, 2, 2), x = c(4, 3, 6, 9, 2)) db |> count(g) |> show_query() #> <SQL> #> SELECT `g`, COUNT(*) AS `n` #> FROM `dbplyr_tmp_9H5PXKstDn` #> GROUP BY `g` db |> count(g, wt = x) |> show_query() #> <SQL> #> SELECT `g`, SUM(`x`) AS `n` #> FROM `dbplyr_tmp_9H5PXKstDn` #> GROUP BY `g` db |> count(g, wt = x, sort = TRUE) |> show_query() #> <SQL> #> SELECT `g`, SUM(`x`) AS `n` #> FROM `dbplyr_tmp_9H5PXKstDn` #> GROUP BY `g` #> ORDER BY `n` DESC"},{"path":"https://dbplyr.tidyverse.org/dev/reference/db-io.html","id":null,"dir":"Reference","previous_headings":"","what":"Database I/O generics — db-io","title":"Database I/O generics — db-io","text":"generics responsible getting data database. used last resort - use make backend work providing methods DBI generics, dbplyr's SQL generation generics. tend needed backend special handling temporary tables. db_copy_to() implements copy_to.src_sql() calling db_write_table() (calls DBI::dbWriteTable()) transfer data, optionally adds indexes (via sql_table_index()) analyses (via sql_table_analyze()). db_compute() implements compute.tbl_sql() calling sql_query_save() create table, optionally adds indexes (via sql_table_index()) analyses (via sql_table_analyze()). db_collect() implements collect.tbl_sql() using DBI::dbSendQuery() DBI::dbFetch(). db_table_temporary() used databases special naming schemes temporary tables (e.g. SQL server SAP HANA require temporary tables start #)","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/db-io.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Database I/O generics — db-io","text":"","code":"db_copy_to(   con,   table,   values,   ...,   overwrite = FALSE,   types = NULL,   temporary = TRUE,   unique_indexes = NULL,   indexes = NULL,   analyze = TRUE,   in_transaction = TRUE )  db_compute(   con,   table,   sql,   ...,   overwrite = FALSE,   temporary = TRUE,   unique_indexes = list(),   indexes = list(),   analyze = TRUE,   in_transaction = TRUE )  db_collect(con, sql, n = -1, warn_incomplete = TRUE, ...)  db_table_temporary(con, table, temporary, ...)"},{"path":[]},{"path":"https://dbplyr.tidyverse.org/dev/reference/db-misc.html","id":null,"dir":"Reference","previous_headings":"","what":"Miscellaneous database generics — db-misc","title":"Miscellaneous database generics — db-misc","text":"db_connection_describe() provides short string describing database connection, helping users tell database table comes . single line, ideally less 60 characters wide.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/db-misc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Miscellaneous database generics — db-misc","text":"","code":"db_connection_describe(con, ...)  sql_join_suffix(con, suffix, ...)  db_sql_render(con, sql, ..., cte = FALSE, sql_options = NULL)  db_col_types(con, table, call)  dbplyr_edition(con)"},{"path":"https://dbplyr.tidyverse.org/dev/reference/db-misc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Miscellaneous database generics — db-misc","text":"dbplyr_edition() declares version dbplyr API want. See details. db_col_types() returns column types table.","code":""},{"path":[]},{"path":"https://dbplyr.tidyverse.org/dev/reference/db-quote.html","id":null,"dir":"Reference","previous_headings":"","what":"SQL escaping/quoting generics — db-quote","title":"SQL escaping/quoting generics — db-quote","text":"generics translate individual values SQL. core generics DBI::dbQuoteIdentifier() DBI::dbQuoteString quoting identifiers strings, dbplyr needs additional tools inserting logical, date, date-time, raw values queries.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/db-quote.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SQL escaping/quoting generics — db-quote","text":"","code":"sql_escape_logical(con, x)  sql_escape_date(con, x)  sql_escape_datetime(con, x)  sql_escape_raw(con, x)"},{"path":[]},{"path":"https://dbplyr.tidyverse.org/dev/reference/db-quote.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"SQL escaping/quoting generics — db-quote","text":"","code":"con <- simulate_dbi() sql_escape_logical(con, c(TRUE, FALSE, NA)) #> [1] \"TRUE\"  \"FALSE\" \"NULL\"  sql_escape_date(con, Sys.Date()) #> [1] \"'2025-12-18'\" sql_escape_date(con, Sys.time()) #> [1] \"'2025-12-18 22:33:00.917905'\" sql_escape_raw(con, charToRaw(\"hi\")) #> [1] \"X'6869'\""},{"path":"https://dbplyr.tidyverse.org/dev/reference/db-sql.html","id":null,"dir":"Reference","previous_headings":"","what":"SQL generation generics — db-sql","title":"SQL generation generics — db-sql","text":"SQL translation: sql_expr_matches(con, x, y) generates alternative x = y pair NULLs match. default translation uses CASE described https://modern-sql.com/feature/-distinct-. sql_translation(con) generates SQL translation environment. Deprecated: sql_random(con) generates SQL get random number can used select random rows slice_sample(). now replaced adding translation runif(n()). supports_window_clause(con) backend support named windows? db_supports_table_alias_with_as(con) backend support using using table alias? Tables: sql_table_analyze(con, table) generates SQL \"analyzes\" table, ensuring database --date statistics use query planner. called dplyr::copy_to() analyze = TRUE. sql_table_index() generates SQL adding index table. Query manipulation: sql_query_explain(con, sql) generates SQL \"explains\" query, .e. generates query plan describing indexes etc database use. can return character vector, case first n elements used generate plan final element used return query plan. sql_query_fields() generates SQL 0-row result used capture field names tbl_sql() sql_query_save(con, sql) generates SQL saving query (temporary) table. sql_query_wrap(con, ) generates SQL wrapping query subquery. Query indentation: sql_indent_subquery(, con, lvl) helps indenting subquery. Query generation: sql_query_select() generates SQL SELECT query sql_query_join() generates SQL joins sql_query_semi_join() generates SQL semi- anti-joins sql_query_set_op() generates SQL UNION, INTERSECT, EXCEPT queries. Query generation manipulation: sql_query_insert() sql_query_append() generate SQL INSERT query. sql_query_update_from() generates SQL UPDATE query. sql_query_upsert() generates SQL UPSERT query. sql_query_delete() generates SQL DELETE query sql_returning_cols() generates SQL RETURNING clause","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/db-sql.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SQL generation generics — db-sql","text":"","code":"sql_expr_matches(con, x, y, ...)  sql_translation(con)  sql_random(con)  sql_table_analyze(con, table, ...)  sql_table_index(   con,   table,   columns,   name = NULL,   unique = FALSE,   ...,   call = caller_env() )  sql_query_explain(con, sql, ...)  sql_query_fields(con, sql, ...)  sql_query_save(con, sql, name, temporary = TRUE, ...)  sql_query_wrap(con, from, name = NULL, ..., lvl = 0)  sql_indent_subquery(from, con, lvl = 0)  sql_query_rows(con, sql, ...)  supports_window_clause(con)  db_supports_table_alias_with_as(con)  sql_query_select(   con,   select,   from,   where = NULL,   group_by = NULL,   having = NULL,   window = NULL,   order_by = NULL,   limit = NULL,   distinct = FALSE,   ...,   subquery = FALSE,   lvl = 0 )  sql_query_join(   con,   x,   y,   select,   type = \"inner\",   by = NULL,   na_matches = FALSE,   ...,   lvl = 0 )  sql_query_multi_join(con, x, joins, table_names, by_list, select, ..., lvl = 0)  sql_query_semi_join(con, x, y, anti, by, where, vars, ..., lvl = 0)  sql_query_set_op(con, x, y, method, ..., all = FALSE, lvl = 0)  sql_query_union(con, x, unions, ..., lvl = 0)  sql_returning_cols(con, cols, table, ...)"},{"path":[]},{"path":"https://dbplyr.tidyverse.org/dev/reference/dbplyr-package.html","id":null,"dir":"Reference","previous_headings":"","what":"dbplyr: A 'dplyr' Back End for Databases — dbplyr-package","title":"dbplyr: A 'dplyr' Back End for Databases — dbplyr-package","text":"'dplyr' back end databases allows work remote database tables -memory data frames. Basic features works database 'DBI' back end; advanced features require 'SQL' translation provided package author.","code":""},{"path":[]},{"path":"https://dbplyr.tidyverse.org/dev/reference/dbplyr-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"dbplyr: A 'dplyr' Back End for Databases — dbplyr-package","text":"Maintainer: Hadley Wickham hadley@posit.co Authors: Maximilian Girlich Edgar Ruiz contributors: Posit Software, PBC [copyright holder, funder]","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/dbplyr-slice.html","id":null,"dir":"Reference","previous_headings":"","what":"Subset rows using their positions — dbplyr-slice","title":"Subset rows using their positions — dbplyr-slice","text":"methods dplyr generics dplyr::slice_min(), dplyr::slice_max(), dplyr::slice_sample(). translated SQL using dplyr::filter() window functions (ROWNUMBER, MIN_RANK, CUME_DIST depending arguments). slice(), slice_head(), slice_tail() supported since database tables intrinsic order. data grouped, operation performed group (e.g.) slice_min(db, x, n = 3) select three rows smallest value x group.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/dbplyr-slice.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Subset rows using their positions — dbplyr-slice","text":"","code":"# S3 method for class 'tbl_lazy' slice_min(   .data,   order_by,   ...,   n,   prop,   by = NULL,   with_ties = TRUE,   na_rm = TRUE )  # S3 method for class 'tbl_lazy' slice_max(   .data,   order_by,   ...,   n,   by = NULL,   prop,   with_ties = TRUE,   na_rm = TRUE )  # S3 method for class 'tbl_lazy' slice_sample(.data, ..., n, prop, by = NULL, weight_by = NULL, replace = FALSE)"},{"path":"https://dbplyr.tidyverse.org/dev/reference/dbplyr-slice.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Subset rows using their positions — dbplyr-slice","text":".data lazy data frame backed database query. order_by Variable function variables order . ... used. n, prop Provide either n, number rows, prop, proportion rows select. neither supplied, n = 1 used. n greater number rows group (prop > 1), result silently truncated group size. proportion group size integer, rounded .  <tidy-select> Optionally, selection columns group just operation, functioning alternative group_by(). details examples, see ?dplyr_by. with_ties ties kept together? default, TRUE, may return rows request. Use FALSE ignore ties, return first n rows. na_rm missing values order_by removed result? FALSE, NA values sorted end (like arrange()), included insufficient non-missing values reach n/prop. weight_by, replace supported database backends.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/dbplyr-slice.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Subset rows using their positions — dbplyr-slice","text":"","code":"library(dplyr, warn.conflicts = FALSE)  db <- memdb_frame(x = 1:3, y = c(1, 1, 2)) db |> slice_min(x) |> show_query() #> <SQL> #> SELECT `x`, `y` #> FROM ( #>   SELECT #>     `dbplyr_tmp_pYJGCySHwm`.*, #>     CASE #> WHEN (NOT((`x` IS NULL))) THEN RANK() OVER (PARTITION BY (CASE WHEN ((`x` IS NULL)) THEN 1 ELSE 0 END) ORDER BY `x`) #> END AS `col01` #>   FROM `dbplyr_tmp_pYJGCySHwm` #> ) AS `q01` #> WHERE (`col01` <= 1) db |> slice_max(x) |> show_query() #> <SQL> #> SELECT `x`, `y` #> FROM ( #>   SELECT #>     `dbplyr_tmp_pYJGCySHwm`.*, #>     CASE #> WHEN (NOT((`x` IS NULL))) THEN RANK() OVER (PARTITION BY (CASE WHEN ((`x` IS NULL)) THEN 1 ELSE 0 END) ORDER BY `x` DESC) #> END AS `col01` #>   FROM `dbplyr_tmp_pYJGCySHwm` #> ) AS `q01` #> WHERE (`col01` <= 1) db |> slice_sample() |> show_query() #> <SQL> #> SELECT `x`, `y` #> FROM ( #>   SELECT #>     `dbplyr_tmp_pYJGCySHwm`.*, #>     CASE #> WHEN (NOT((((0.5 + RANDOM() / 18446744073709551616.0)) IS NULL))) THEN ROW_NUMBER() OVER (PARTITION BY (CASE #> WHEN ((((0.5 + RANDOM() / 18446744073709551616.0)) IS NULL)) THEN 1 #> ELSE 0 #> END) ORDER BY (0.5 + RANDOM() / 18446744073709551616.0)) #> END AS `col01` #>   FROM `dbplyr_tmp_pYJGCySHwm` #> ) AS `q01` #> WHERE (`col01` <= 1)  db |> group_by(y) |> slice_min(x) |> show_query() #> <SQL> #> SELECT `x`, `y` #> FROM ( #>   SELECT #>     `dbplyr_tmp_pYJGCySHwm`.*, #>     CASE #> WHEN (NOT((`x` IS NULL))) THEN RANK() OVER (PARTITION BY `y`, (CASE WHEN ((`x` IS NULL)) THEN 1 ELSE 0 END) ORDER BY `x`) #> END AS `col01` #>   FROM `dbplyr_tmp_pYJGCySHwm` #> ) AS `q01` #> WHERE (`col01` <= 1)  # By default, ties are includes so you may get more rows # than you expect db |> slice_min(y, n = 1) #> # A query:  ?? x 2 #> # Database: sqlite 3.51.1 [:memory:] #>       x     y #>   <int> <dbl> #> 1     1     1 #> 2     2     1 db |> slice_min(y, n = 1, with_ties = FALSE) #> # A query:  ?? x 2 #> # Database: sqlite 3.51.1 [:memory:] #>       x     y #>   <int> <dbl> #> 1     1     1  # Non-integer group sizes are rounded down db |> slice_min(x, prop = 0.5) #> # A query:  ?? x 2 #> # Database: sqlite 3.51.1 [:memory:] #>       x     y #>   <int> <dbl> #> 1     1     1"},{"path":"https://dbplyr.tidyverse.org/dev/reference/dbplyr_uncount.html","id":null,"dir":"Reference","previous_headings":"","what":"","title":"","text":"method tidyr uncount() generic. uses temporary table, database user needs permissions create one.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/dbplyr_uncount.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"","text":"","code":"dbplyr_uncount(data, weights, .remove = TRUE, .id = NULL)"},{"path":"https://dbplyr.tidyverse.org/dev/reference/dbplyr_uncount.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"","text":"data lazy data frame backed database query. weights vector weights. Evaluated context data; supports quasiquotation. .remove TRUE, weights name column data, column removed. .id Supply string create new variable gives unique identifier created row.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/dbplyr_uncount.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"","text":"","code":"df <- memdb_frame(x = c(\"a\", \"b\"), n = c(1, 2)) dbplyr_uncount(df, n) #> # A query:  ?? x 1 #> # Database: sqlite 3.51.1 [:memory:] #>   x     #>   <chr> #> 1 a     #> 2 b     #> 3 b     dbplyr_uncount(df, n, .id = \"id\") #> # A query:  ?? x 2 #> # Database: sqlite 3.51.1 [:memory:] #>   x        id #>   <chr> <int> #> 1 a         1 #> 2 b         1 #> 3 b         2  # You can also use constants dbplyr_uncount(df, 2) #> # A query:  ?? x 2 #> # Database: sqlite 3.51.1 [:memory:] #>   x         n #>   <chr> <dbl> #> 1 a         1 #> 2 a         1 #> 3 b         2 #> 4 b         2  # Or expressions dbplyr_uncount(df, 2 / n) #> # A query:  ?? x 2 #> # Database: sqlite 3.51.1 [:memory:] #>   x         n #>   <chr> <dbl> #> 1 a         1 #> 2 a         1 #> 3 b         2"},{"path":"https://dbplyr.tidyverse.org/dev/reference/distinct.tbl_lazy.html","id":null,"dir":"Reference","previous_headings":"","what":"Subset distinct/unique rows — distinct.tbl_lazy","title":"Subset distinct/unique rows — distinct.tbl_lazy","text":"method dplyr dplyr::distinct() generic. adds DISTINCT clause SQL query.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/distinct.tbl_lazy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Subset distinct/unique rows — distinct.tbl_lazy","text":"","code":"# S3 method for class 'tbl_lazy' distinct(.data, ..., .keep_all = FALSE)"},{"path":"https://dbplyr.tidyverse.org/dev/reference/distinct.tbl_lazy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Subset distinct/unique rows — distinct.tbl_lazy","text":".data lazy data frame backed database query. ... <data-masking> Variables, functions variables. Use desc() sort variable descending order. .keep_all TRUE, keep variables .data. combination ... distinct, keeps first row values.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/distinct.tbl_lazy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Subset distinct/unique rows — distinct.tbl_lazy","text":"Another tbl_lazy. Use show_query() see generated query, use collect() execute query return data R.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/distinct.tbl_lazy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Subset distinct/unique rows — distinct.tbl_lazy","text":"","code":"library(dplyr, warn.conflicts = FALSE)  db <- memdb_frame(x = c(1, 1, 2, 2), y = c(1, 2, 1, 1)) db |> distinct() |> show_query() #> <SQL> #> SELECT DISTINCT `dbplyr_tmp_1qeoeBlLyC`.* #> FROM `dbplyr_tmp_1qeoeBlLyC` db |> distinct(x) |> show_query() #> <SQL> #> SELECT DISTINCT `x` #> FROM `dbplyr_tmp_1qeoeBlLyC`"},{"path":"https://dbplyr.tidyverse.org/dev/reference/do.tbl_sql.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform arbitrary computation on remote backend — do.tbl_sql","title":"Perform arbitrary computation on remote backend — do.tbl_sql","text":"Perform arbitrary computation remote backend","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/do.tbl_sql.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform arbitrary computation on remote backend — do.tbl_sql","text":"","code":"# S3 method for class 'tbl_sql' do(.data, ..., .chunk_size = 10000L)"},{"path":"https://dbplyr.tidyverse.org/dev/reference/do.tbl_sql.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Perform arbitrary computation on remote backend — do.tbl_sql","text":".data tbl ... Expressions apply group. named, results stored new column. unnamed, must return data frame. can use . refer current group. can mix named unnamed arguments. .chunk_size size chunk pull R. number big, process slow R allocate free lot memory. small, slow, overhead talking database.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/dot-sql.html","id":null,"dir":"Reference","previous_headings":"","what":"Flag SQL function usage — .sql","title":"Flag SQL function usage — .sql","text":"Use .sql$foo(x, y) make clear calling SQL foo() function, R foo() function. also makes easier reduce R CMD check notes packages; just import .sql dbplyr e.g. @importFrom dbplyr .sql. Note .sql nothing just NULL; automatically removed dbplyr translates R code SQL.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/dot-sql.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Flag SQL function usage — .sql","text":"","code":".sql"},{"path":"https://dbplyr.tidyverse.org/dev/reference/dot-sql.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Flag SQL function usage — .sql","text":"","code":"library(dplyr, warn.conflicts = FALSE)  db <- lazy_frame(x = 1, y = 2) db |> mutate(z = .sql$CUMULATIVE_SUM(x, 1)) #> <SQL> #> SELECT \"df\".*, CUMULATIVE_SUM(\"x\", 1.0) AS \"z\" #> FROM \"df\""},{"path":"https://dbplyr.tidyverse.org/dev/reference/escape.html","id":null,"dir":"Reference","previous_headings":"","what":"Escape/quote a string. — escape","title":"Escape/quote a string. — escape","text":"escape() requires provide database connection control details escaping. escape_ansi() uses SQL 92 ANSI standard.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/escape.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Escape/quote a string. — escape","text":"","code":"escape(x, parens = NA, collapse = \" \", con = NULL)  escape_ansi(x, parens = NA, collapse = \"\")  sql_vector(x, parens = NA, collapse = \" \", con = NULL)"},{"path":"https://dbplyr.tidyverse.org/dev/reference/escape.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Escape/quote a string. — escape","text":"x object escape. Existing sql vectors left , character vectors escaped single quotes, numeric vectors trailing .0 added whole numbers, identifiers escaped double quotes. parens, collapse Controls behaviour multiple values supplied. parens logical flag, NA, wrap parens length > 1. Default behaviour: lists always wrapped parens separated commas, identifiers separated commas never wrapped, atomic vectors separated spaces wrapped parens needed. con Database connection.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/escape.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Escape/quote a string. — escape","text":"","code":"# Doubles vs. integers escape_ansi(1:5) #> <SQL> (12345) escape_ansi(c(1, 5.4)) #> <SQL> (1.05.4)  # String vs known sql vs. sql identifier escape_ansi(\"X\") #> <SQL> 'X' escape_ansi(sql(\"X\")) #> <SQL> X escape_ansi(ident(\"X\")) #> <SQL> \"X\"  # Escaping is idempotent escape_ansi(\"X\") #> <SQL> 'X' escape_ansi(escape_ansi(\"X\")) #> <SQL> 'X' escape_ansi(escape_ansi(escape_ansi(\"X\"))) #> <SQL> 'X'"},{"path":"https://dbplyr.tidyverse.org/dev/reference/expand.tbl_lazy.html","id":null,"dir":"Reference","previous_headings":"","what":"Expand SQL tables to include all possible combinations of values — expand.tbl_lazy","title":"Expand SQL tables to include all possible combinations of values — expand.tbl_lazy","text":"method tidyr::expand generics. sort result explicitly, order might different expand() returns data frames.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/expand.tbl_lazy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Expand SQL tables to include all possible combinations of values — expand.tbl_lazy","text":"","code":"# S3 method for class 'tbl_lazy' expand(data, ..., .name_repair = \"check_unique\")"},{"path":"https://dbplyr.tidyverse.org/dev/reference/expand.tbl_lazy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Expand SQL tables to include all possible combinations of values — expand.tbl_lazy","text":"data lazy data frame backed database query. ... Specification columns expand. See tidyr::expand details. .name_repair Treatment problematic column names: \"minimal\": name repair checks, beyond basic existence, \"unique\": Make sure names unique empty, \"check_unique\": (default value), name repair, check unique, \"universal\": Make names unique syntactic \"unique_quiet\": \"unique\", \"quiet\" \"universal_quiet\": \"universal\", \"quiet\" function: apply custom name repair (e.g., .name_repair = make.names names style base R). purrr-style anonymous function, see rlang::as_function() argument passed repair vctrs::vec_as_names(). See details terms strategies used enforce .","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/expand.tbl_lazy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Expand SQL tables to include all possible combinations of values — expand.tbl_lazy","text":"Another tbl_lazy. Use show_query() see generated query, use collect() execute query return data R.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/expand.tbl_lazy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Expand SQL tables to include all possible combinations of values — expand.tbl_lazy","text":"","code":"fruits <- memdb_frame(   type   = c(\"apple\", \"orange\", \"apple\", \"orange\", \"orange\", \"orange\"),   year   = c(2010, 2010, 2012, 2010, 2010, 2012),   size = c(\"XS\", \"S\",  \"M\", \"S\", \"S\", \"M\"),   weights = rnorm(6) )  # All possible combinations --------------------------------------- fruits |> tidyr::expand(type) #> # A query:  ?? x 1 #> # Database: sqlite 3.51.1 [:memory:] #>   type   #>   <chr>  #> 1 apple  #> 2 orange fruits |> tidyr::expand(type, size) #> # A query:  ?? x 2 #> # Database: sqlite 3.51.1 [:memory:] #>   type   size  #>   <chr>  <chr> #> 1 apple  XS    #> 2 apple  S     #> 3 apple  M     #> 4 orange XS    #> 5 orange S     #> 6 orange M      # Only combinations that already appear in the data --------------- fruits |> tidyr::expand(nesting(type, size)) #> # A query:  ?? x 2 #> # Database: sqlite 3.51.1 [:memory:] #>   type   size  #>   <chr>  <chr> #> 1 apple  XS    #> 2 orange S     #> 3 apple  M     #> 4 orange M"},{"path":"https://dbplyr.tidyverse.org/dev/reference/fill.tbl_lazy.html","id":null,"dir":"Reference","previous_headings":"","what":"Fill in missing values with previous or next value — fill.tbl_lazy","title":"Fill in missing values with previous or next value — fill.tbl_lazy","text":"Fill missing values previous next value","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/fill.tbl_lazy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fill in missing values with previous or next value — fill.tbl_lazy","text":"","code":"# S3 method for class 'tbl_lazy' fill(.data, ..., .direction = c(\"down\", \"up\", \"updown\", \"downup\"))"},{"path":"https://dbplyr.tidyverse.org/dev/reference/fill.tbl_lazy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fill in missing values with previous or next value — fill.tbl_lazy","text":".data lazy data frame backed database query. ... Columns fill. .direction Direction fill missing values. Currently either \"\" (default) \"\". Note \"\" work .data sorted non-numeric columns. workaround revert order beforehand; example replace arrange(x, desc(y)) arrange(desc(x), y).","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/fill.tbl_lazy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fill in missing values with previous or next value — fill.tbl_lazy","text":"","code":"library(dplyr, warn.conflicts = FALSE)  squirrels <- tibble::tribble(   ~group,    ~name,     ~role,     ~n_squirrels, ~ n_squirrels2,   1,      \"Sam\",    \"Observer\",   NA,                 1,   1,     \"Mara\", \"Scorekeeper\",    8,                NA,   1,    \"Jesse\",    \"Observer\",   NA,                NA,   1,      \"Tom\",    \"Observer\",   NA,                 4,   2,     \"Mike\",    \"Observer\",   NA,                NA,   2,  \"Rachael\",    \"Observer\",   NA,                 6,   2,  \"Sydekea\", \"Scorekeeper\",   14,                NA,   2, \"Gabriela\",    \"Observer\",   NA,                NA,   3,  \"Derrick\",    \"Observer\",   NA,                NA,   3,     \"Kara\", \"Scorekeeper\",    9,                 10,   3,    \"Emily\",    \"Observer\",   NA,                NA,   3, \"Danielle\",    \"Observer\",   NA,                NA ) squirrels$id <- 1:12  squirrels_db <- copy_to(memdb(), squirrels) squirrels_db |>   window_order(id) |>   tidyr::fill(n_squirrels, n_squirrels2) #> # A query:    ?? x 6 #> # Database:   sqlite 3.51.1 [:memory:] #> # Ordered by: id #>    group name     role        n_squirrels n_squirrels2    id #>    <dbl> <chr>    <chr>             <dbl>        <dbl> <int> #>  1     1 Sam      Observer             NA            1     1 #>  2     1 Mara     Scorekeeper           8            1     2 #>  3     1 Jesse    Observer              8            1     3 #>  4     1 Tom      Observer              8            4     4 #>  5     2 Mike     Observer              8            4     5 #>  6     2 Rachael  Observer              8            6     6 #>  7     2 Sydekea  Scorekeeper          14            6     7 #>  8     2 Gabriela Observer             14            6     8 #>  9     3 Derrick  Observer             14            6     9 #> 10     3 Kara     Scorekeeper           9           10    10 #> 11     3 Emily    Observer              9           10    11 #> 12     3 Danielle Observer              9           10    12"},{"path":"https://dbplyr.tidyverse.org/dev/reference/filter.tbl_lazy.html","id":null,"dir":"Reference","previous_headings":"","what":"Subset rows using column values — filter.tbl_lazy","title":"Subset rows using column values — filter.tbl_lazy","text":"method dplyr dplyr::filter() generic. generates clause SQL query.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/filter.tbl_lazy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Subset rows using column values — filter.tbl_lazy","text":"","code":"# S3 method for class 'tbl_lazy' filter(.data, ..., .by = NULL, .preserve = FALSE)"},{"path":"https://dbplyr.tidyverse.org/dev/reference/filter.tbl_lazy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Subset rows using column values — filter.tbl_lazy","text":".data lazy data frame backed database query. ... <data-masking> Variables, functions variables. Use desc() sort variable descending order. . <tidy-select> Optionally, selection columns group just operation, functioning alternative group_by(). details examples, see ?dplyr_by. .preserve supported method.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/filter.tbl_lazy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Subset rows using column values — filter.tbl_lazy","text":"Another tbl_lazy. Use show_query() see generated query, use collect() execute query return data R.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/filter.tbl_lazy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Subset rows using column values — filter.tbl_lazy","text":"","code":"library(dplyr, warn.conflicts = FALSE)  db <- memdb_frame(x = c(2, NA, 5, NA, 10), y = 1:5) db |> filter(x < 5) |> show_query() #> <SQL> #> SELECT `dbplyr_tmp_yiq6RTXYj8`.* #> FROM `dbplyr_tmp_yiq6RTXYj8` #> WHERE (`x` < 5.0) db |> filter(is.na(x)) |> show_query() #> <SQL> #> SELECT `dbplyr_tmp_yiq6RTXYj8`.* #> FROM `dbplyr_tmp_yiq6RTXYj8` #> WHERE ((`x` IS NULL))"},{"path":"https://dbplyr.tidyverse.org/dev/reference/get_returned_rows.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract and check the RETURNING rows — get_returned_rows","title":"Extract and check the RETURNING rows — get_returned_rows","text":"get_returned_rows() extracts RETURNING rows produced dplyr::rows_insert(), dplyr::rows_append(), dplyr::rows_update(), dplyr::rows_upsert(), dplyr::rows_delete() called returning argument. error raised information available. has_returned_rows() checks x stored RETURNING rows produced dplyr::rows_insert(), dplyr::rows_append(), dplyr::rows_update(), dplyr::rows_upsert(), dplyr::rows_delete().","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/get_returned_rows.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract and check the RETURNING rows — get_returned_rows","text":"","code":"get_returned_rows(x)  has_returned_rows(x)"},{"path":"https://dbplyr.tidyverse.org/dev/reference/get_returned_rows.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract and check the RETURNING rows — get_returned_rows","text":"x lazy tbl.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/get_returned_rows.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract and check the RETURNING rows — get_returned_rows","text":"get_returned_rows(), tibble. has_returned_rows(), scalar logical.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/get_returned_rows.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract and check the RETURNING rows — get_returned_rows","text":"","code":"library(dplyr)  con <- DBI::dbConnect(RSQLite::SQLite(), \":memory:\") DBI::dbExecute(con, \"CREATE TABLE Info (    id INTEGER PRIMARY KEY AUTOINCREMENT,    number INTEGER )\") #> [1] 0 info <- tbl(con, \"Info\")  rows1 <- copy_inline(con, data.frame(number = c(1, 5))) rows_insert(info, rows1, conflict = \"ignore\", in_place = TRUE) #> Matching, by = \"number\" info #> # A query:  ?? x 2 #> # Database: sqlite 3.51.1 [:memory:] #>      id number #>   <int>  <int> #> 1     1      1 #> 2     2      5  # If the table has an auto incrementing primary key, you can use # the returning argument + `get_returned_rows()` its value rows2 <- copy_inline(con, data.frame(number = c(13, 27))) info <- rows_insert(   info,   rows2,   conflict = \"ignore\",   in_place = TRUE,   returning = id ) #> Matching, by = \"number\" info #> # A query:  ?? x 2 #> # Database: sqlite 3.51.1 [:memory:] #>      id number #>   <int>  <int> #> 1     1      1 #> 2     2      5 #> 3     3     13 #> 4     4     27 get_returned_rows(info) #> # A tibble: 2 × 1 #>      id #>   <int> #> 1     3 #> 2     4"},{"path":"https://dbplyr.tidyverse.org/dev/reference/group_by.tbl_lazy.html","id":null,"dir":"Reference","previous_headings":"","what":"Group by one or more variables — group_by.tbl_lazy","title":"Group by one or more variables — group_by.tbl_lazy","text":"method dplyr dplyr::group_by() generic. translated GROUP clause SQL query used summarise() PARTITION clause window functions used mutate().","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/group_by.tbl_lazy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Group by one or more variables — group_by.tbl_lazy","text":"","code":"# S3 method for class 'tbl_lazy' group_by(.data, ..., .add = FALSE, .drop = TRUE)"},{"path":"https://dbplyr.tidyverse.org/dev/reference/group_by.tbl_lazy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Group by one or more variables — group_by.tbl_lazy","text":".data lazy data frame backed database query. ... <data-masking> Variables, functions variables. Use desc() sort variable descending order. .add FALSE, default, group_by() override existing groups. add existing groups, use .add = TRUE. argument previously called add, prevented creating new grouping variable called add, conflicts naming conventions. .drop supported method.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/group_by.tbl_lazy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Group by one or more variables — group_by.tbl_lazy","text":"","code":"library(dplyr, warn.conflicts = FALSE)  db <- memdb_frame(g = c(1, 1, 1, 2, 2), x = c(4, 3, 6, 9, 2)) db |>   group_by(g) |>   summarise(n()) |>   show_query() #> <SQL> #> SELECT `g`, COUNT(*) AS `n()` #> FROM `dbplyr_tmp_7izdkFTvzI` #> GROUP BY `g`  db |>   group_by(g) |>   mutate(x2 = x / sum(x, na.rm = TRUE)) |>   show_query() #> <SQL> #> SELECT `dbplyr_tmp_7izdkFTvzI`.*, `x` / SUM(`x`) OVER (PARTITION BY `g`) AS `x2` #> FROM `dbplyr_tmp_7izdkFTvzI`"},{"path":"https://dbplyr.tidyverse.org/dev/reference/head.tbl_lazy.html","id":null,"dir":"Reference","previous_headings":"","what":"Subset the first rows — head.tbl_lazy","title":"Subset the first rows — head.tbl_lazy","text":"method head() generic. usually translated LIMIT clause SQL query. LIMIT official part SQL specification, database use clauses like TOP FETCH ROWS. Note databases really sense row order, \"first\" means subject interpretation. databases respect ordering performed arrange(), guaranteed. tail() supported situation even murkier \"last\" rows. Additionally, LIMIT clauses can generally appear subqueries, means use head() late possible pipelines.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/head.tbl_lazy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Subset the first rows — head.tbl_lazy","text":"","code":"# S3 method for class 'tbl_lazy' head(x, n = 6L, ...)"},{"path":"https://dbplyr.tidyverse.org/dev/reference/head.tbl_lazy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Subset the first rows — head.tbl_lazy","text":"x lazy data frame backed database query. n Number rows return ... used.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/head.tbl_lazy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Subset the first rows — head.tbl_lazy","text":"Another tbl_lazy. Use show_query() see generated query, use collect() execute query return data R.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/head.tbl_lazy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Subset the first rows — head.tbl_lazy","text":"","code":"library(dplyr, warn.conflicts = FALSE)  db <- memdb_frame(x = 1:100) db |> head() |> show_query() #> <SQL> #> SELECT `dbplyr_tmp_CzqTiZvfqQ`.* #> FROM `dbplyr_tmp_CzqTiZvfqQ` #> LIMIT 6  # Pretend we have data in a SQL server database db2 <- lazy_frame(x = 1:100, con = simulate_mssql()) db2 |> head() |> show_query() #> Warning: EOF within quoted string #> Warning: EOF within quoted string #> Warning: EOF within quoted string #> <SQL> #> SELECT TOP 6 [df]] #> ].* #> FROM [df]"},{"path":"https://dbplyr.tidyverse.org/dev/reference/ident.html","id":null,"dir":"Reference","previous_headings":"","what":"Flag a character vector as SQL identifiers — ident","title":"Flag a character vector as SQL identifiers — ident","text":"ident() takes strings turns database identifiers (e.g. table column names) quoting using identifier rules database. ident_q() , assumes names already quoted, preventing quoted . generally internal use ; need supply table name qualified schema catalog, already quoted reason, use ().","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/ident.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Flag a character vector as SQL identifiers — ident","text":"","code":"ident(...)  is.ident(x)"},{"path":"https://dbplyr.tidyverse.org/dev/reference/ident.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Flag a character vector as SQL identifiers — ident","text":"... character vector, name-value pairs. x object.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/ident.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Flag a character vector as SQL identifiers — ident","text":"","code":"# SQL92 quotes strings with ' escape_ansi(\"x\") #> <SQL> 'x'  # And identifiers with \" ident(\"x\") #> <IDENT> x escape_ansi(ident(\"x\")) #> <SQL> \"x\"  # You can supply multiple inputs ident(a = \"x\", b = \"y\") #> <IDENT> x #> <IDENT> y ident_q(a = \"x\", b = \"y\") #> <IDENT> x #> <IDENT> y"},{"path":"https://dbplyr.tidyverse.org/dev/reference/ident_q.html","id":null,"dir":"Reference","previous_headings":"","what":"Declare a identifier as being pre-quoted. — ident_q","title":"Declare a identifier as being pre-quoted. — ident_q","text":"longer needed; please use sql() instead.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/ident_q.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Declare a identifier as being pre-quoted. — ident_q","text":"","code":"ident_q(...)"},{"path":"https://dbplyr.tidyverse.org/dev/reference/in_schema.html","id":null,"dir":"Reference","previous_headings":"","what":"Refer to a table in another schema/catalog — in_schema","title":"Refer to a table in another schema/catalog — in_schema","text":"in_schema() in_catalog() can used refer tables outside current catalog/schema. However, now recommend using () typically less typing.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/in_schema.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Refer to a table in another schema/catalog — in_schema","text":"","code":"in_schema(schema, table)  in_catalog(catalog, schema, table)"},{"path":"https://dbplyr.tidyverse.org/dev/reference/in_schema.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Refer to a table in another schema/catalog — in_schema","text":"catalog, schema, table Names catalog, schema, table. automatically quoted; use sql() pass raw name get quoted.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/in_schema.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Refer to a table in another schema/catalog — in_schema","text":"","code":"# Previously: in_schema(\"my_schema\", \"my_table\") #> <SCHEMA> \"my_schema\".\"my_table\" in_catalog(\"my_catalog\", \"my_schema\", \"my_table\") #> <CATALOG> \"my_catalog\".\"my_schema\".\"my_table\" in_schema(sql(\"my_schema\"), sql(\"my_table\")) #> <SCHEMA> my_schema.my_table  # Now I(\"my_schema.my_table\") #> [1] \"my_schema.my_table\" I(\"my_catalog.my_schema.my_table\") #> [1] \"my_catalog.my_schema.my_table\" I(\"my_schema.my_table\") #> [1] \"my_schema.my_table\"  # Example using schemas with SQLite con <- DBI::dbConnect(RSQLite::SQLite(), \":memory:\")  # Add auxiliary schema tmp <- tempfile() DBI::dbExecute(con, paste0(\"ATTACH '\", tmp, \"' AS aux\")) #> [1] 0  library(dplyr, warn.conflicts = FALSE) copy_to(con, iris, \"df\", temporary = FALSE) copy_to(con, mtcars, I(\"aux.df\"), temporary = FALSE)  con |> tbl(\"df\") #> # A query:  ?? x 5 #> # Database: sqlite 3.51.1 [:memory:] #>    Sepal.Length Sepal.Width Petal.Length Petal.Width Species #>           <dbl>       <dbl>        <dbl>       <dbl> <chr>   #>  1          5.1         3.5          1.4         0.2 setosa  #>  2          4.9         3            1.4         0.2 setosa  #>  3          4.7         3.2          1.3         0.2 setosa  #>  4          4.6         3.1          1.5         0.2 setosa  #>  5          5           3.6          1.4         0.2 setosa  #>  6          5.4         3.9          1.7         0.4 setosa  #>  7          4.6         3.4          1.4         0.3 setosa  #>  8          5           3.4          1.5         0.2 setosa  #>  9          4.4         2.9          1.4         0.2 setosa  #> 10          4.9         3.1          1.5         0.1 setosa  #> # ℹ more rows con |> tbl(I(\"aux.df\")) #> # A query:  ?? x 11 #> # Database: sqlite 3.51.1 [:memory:] #>      mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb #>    <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> #>  1  21       6  160    110  3.9   2.62  16.5     0     1     4     4 #>  2  21       6  160    110  3.9   2.88  17.0     0     1     4     4 #>  3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1 #>  4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1 #>  5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2 #>  6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1 #>  7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4 #>  8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2 #>  9  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2 #> 10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4 #> # ℹ more rows"},{"path":"https://dbplyr.tidyverse.org/dev/reference/intersect.tbl_lazy.html","id":null,"dir":"Reference","previous_headings":"","what":"SQL set operations — intersect.tbl_lazy","title":"SQL set operations — intersect.tbl_lazy","text":"methods dplyr generics dplyr::intersect(), dplyr::union(), dplyr::setdiff(). translated INTERSECT, UNION, EXCEPT respectively.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/intersect.tbl_lazy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SQL set operations — intersect.tbl_lazy","text":"","code":"# S3 method for class 'tbl_lazy' intersect(x, y, copy = \"none\", ..., all = FALSE)  # S3 method for class 'tbl_lazy' union(x, y, copy = \"none\", ..., all = FALSE)  # S3 method for class 'tbl_lazy' union_all(x, y, copy = \"none\", ...)  # S3 method for class 'tbl_lazy' setdiff(x, y, copy = \"none\", ..., all = FALSE)"},{"path":"https://dbplyr.tidyverse.org/dev/reference/intersect.tbl_lazy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SQL set operations — intersect.tbl_lazy","text":"x, y pair lazy data frames backed database queries. copy x y data source, copy controls y copied source x. three options: \"none\", default, error y needs copied. ensures accidentally copy large datasets R database. \"temp-table\": copies y temporary table database x. *_join() automatically run ANALYZE created table hope make queries efficient possible giving data query planner. \"inline\": y inlined query using copy_inline(). faster small datasets require write access. TRUE (\"temp-table\") FALSE (\"none\") also accepted backward compatibility. ... Must empty. TRUE, includes matches output, just unique rows.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/is_table_path.html","id":null,"dir":"Reference","previous_headings":"","what":"Table paths — is_table_path","title":"Table paths — is_table_path","text":"dbplyr standardises ways referring table (.e. single string, string wrapped (), DBI::Id() results in_schema() in_catalog()) table \"path\" form table, schema.table, catalog.schema.path. table path always suitable inlining query, user input quoted unless wrapped (). primarily internal usage, may need work implementing backend, need compute table path, just pass unchanged dbplyr function. is_table_path() returns TRUE object table_path. as_table_path() coerces known table identifiers table_path. check_table_path() throws error object table_path. table_path_name() returns last component table path (.e. name table). table_path_components() returns list containing components table path. table_path object can technically vector table paths, never see table paths constructed user inputs.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/is_table_path.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Table paths — is_table_path","text":"","code":"is_table_path(x)  table_path_name(x, con)  table_path_components(x, con)  check_table_path(x, error_arg = caller_arg(x), error_call = caller_env())  as_table_path(x, con, error_arg = caller_arg(x), error_call = caller_env())"},{"path":"https://dbplyr.tidyverse.org/dev/reference/join.tbl_sql.html","id":null,"dir":"Reference","previous_headings":"","what":"Join SQL tables — join.tbl_sql","title":"Join SQL tables — join.tbl_sql","text":"methods dplyr dplyr::join generics. translated following SQL queries: inner_join(x, y): SELECT * x JOIN y x.= y.left_join(x, y):  SELECT * x LEFT JOIN y x.= y.right_join(x, y): SELECT * x RIGHT JOIN y x.= y.full_join(x, y):  SELECT * x FULL JOIN y x.= y.semi_join(x, y):  SELECT * x EXISTS (SELECT 1 y x.= y.) anti_join(x, y):  SELECT * x EXISTS (SELECT 1 y x.= y.)","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/join.tbl_sql.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Join SQL tables — join.tbl_sql","text":"","code":"# S3 method for class 'tbl_lazy' inner_join(   x,   y,   by = NULL,   copy = \"none\",   suffix = NULL,   ...,   keep = NULL,   na_matches = c(\"never\", \"na\"),   multiple = NULL,   unmatched = \"drop\",   relationship = NULL,   sql_on = NULL,   auto_index = FALSE,   x_as = NULL,   y_as = NULL )  # S3 method for class 'tbl_lazy' left_join(   x,   y,   by = NULL,   copy = \"none\",   suffix = NULL,   ...,   keep = NULL,   na_matches = c(\"never\", \"na\"),   multiple = NULL,   unmatched = \"drop\",   relationship = NULL,   sql_on = NULL,   auto_index = FALSE,   x_as = NULL,   y_as = NULL )  # S3 method for class 'tbl_lazy' right_join(   x,   y,   by = NULL,   copy = \"none\",   suffix = NULL,   ...,   keep = NULL,   na_matches = c(\"never\", \"na\"),   multiple = NULL,   unmatched = \"drop\",   relationship = NULL,   sql_on = NULL,   auto_index = FALSE,   x_as = NULL,   y_as = NULL )  # S3 method for class 'tbl_lazy' full_join(   x,   y,   by = NULL,   copy = \"none\",   suffix = NULL,   ...,   keep = NULL,   na_matches = c(\"never\", \"na\"),   multiple = NULL,   relationship = NULL,   sql_on = NULL,   auto_index = FALSE,   x_as = NULL,   y_as = NULL )  # S3 method for class 'tbl_lazy' cross_join(   x,   y,   ...,   copy = \"none\",   suffix = c(\".x\", \".y\"),   x_as = NULL,   y_as = NULL )  # S3 method for class 'tbl_lazy' semi_join(   x,   y,   by = NULL,   copy = \"none\",   ...,   na_matches = c(\"never\", \"na\"),   sql_on = NULL,   auto_index = FALSE,   x_as = NULL,   y_as = NULL )  # S3 method for class 'tbl_lazy' anti_join(   x,   y,   by = NULL,   copy = \"none\",   ...,   na_matches = c(\"never\", \"na\"),   sql_on = NULL,   auto_index = FALSE,   x_as = NULL,   y_as = NULL )"},{"path":"https://dbplyr.tidyverse.org/dev/reference/join.tbl_sql.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Join SQL tables — join.tbl_sql","text":"x, y pair lazy data frames backed database queries. join specification created join_by(), character vector variables join . NULL, default, *_join() perform natural join, using variables common across x y. message lists variables can check correct; suppress message supplying explicitly. join different variables x y, use join_by() specification. example, join_by(== b) match x$y$b. join multiple variables, use join_by() specification multiple expressions. example, join_by(== b, c == d) match x$y$b x$c y$d. column names x y, can shorten listing variable names, like join_by(, c). join_by() can also used perform inequality, rolling, overlap joins. See documentation ?join_by details types joins. simple equality joins, can alternatively specify character vector variable names join . example, = c(\"\", \"b\") joins x$y$x$b y$b. variable names differ x y, use named character vector like = c(\"x_a\" = \"y_a\", \"x_b\" = \"y_b\"). perform cross-join, generating combinations x y, see cross_join(). copy x y data source, copy controls y copied source x. three options: \"none\", default, error y needs copied. ensures accidentally copy large datasets R database. \"temp-table\": copies y temporary table database x. *_join() automatically run ANALYZE created table hope make queries efficient possible giving data query planner. \"inline\": y inlined query using copy_inline(). faster small datasets require write access. TRUE (\"temp-table\") FALSE (\"none\") also accepted backward compatibility. suffix non-joined duplicate variables x y, suffixes added output disambiguate . character vector length 2. ... parameters passed onto methods. keep join keys x y preserved output? NULL, default, joins equality retain keys x, joins inequality retain keys inputs. TRUE, keys inputs retained. FALSE, keys x retained. right full joins, data key columns corresponding rows exist y merged key columns x. used joining inequality conditions. na_matches NA (NULL) values match one another? default, \"never\", databases usually work. \"na\" makes joins behave like dplyr join functions, merge(), bit64::match(), %%. multiple, unmatched Unsupported database backends. workaround multiple use unique key unmatched foreign key constraint. relationship Unsupported database backends. sql_on custom join predicate SQL expression. Usually joins use column equality, can perform complex queries supply sql_on SQL expression uses LHS RHS aliases refer left-hand side right-hand side join respectively. auto_index copy TRUE, automatically create indices variables . may speed join matching indexes x. x_as, y_as Alias use x resp. y. Defaults \"LHS\" resp. \"RHS\"","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/join.tbl_sql.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Join SQL tables — join.tbl_sql","text":"Another tbl_lazy. Use show_query() see generated query, use collect() execute query return data R.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/join.tbl_sql.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Join SQL tables — join.tbl_sql","text":"","code":"library(dplyr, warn.conflicts = FALSE)  band_db <- copy_to(memdb(), dplyr::band_members) instrument_db <- copy_to(memdb(), dplyr::band_instruments) band_db |> left_join(instrument_db) |> show_query() #> Joining with `by = join_by(name)` #> <SQL> #> SELECT `dplyr::band_members`.*, `plays` #> FROM `dplyr::band_members` #> LEFT JOIN `dplyr::band_instruments` #>   ON (`dplyr::band_members`.`name` = `dplyr::band_instruments`.`name`)  # Can join with local data frames by setting copy = TRUE band_db |>   left_join(dplyr::band_instruments, copy = TRUE) #> Joining with `by = join_by(name)` #> # A query:  ?? x 3 #> # Database: sqlite 3.51.1 [:memory:] #>   name  band    plays  #>   <chr> <chr>   <chr>  #> 1 Mick  Stones  NA     #> 2 John  Beatles guitar #> 3 Paul  Beatles bass    # Unlike R, joins in SQL don't usually match NAs (NULLs) db <- memdb_frame(x = c(1, 2, NA)) label <- memdb_frame(x = c(1, NA), label = c(\"one\", \"missing\")) db |> left_join(label, by = \"x\") #> # A query:  ?? x 2 #> # Database: sqlite 3.51.1 [:memory:] #>       x label #>   <dbl> <chr> #> 1     1 one   #> 2     2 NA    #> 3    NA NA    # But you can activate R's usual behaviour with the na_matches argument db |> left_join(label, by = \"x\", na_matches = \"na\") #> # A query:  ?? x 2 #> # Database: sqlite 3.51.1 [:memory:] #>       x label   #>   <dbl> <chr>   #> 1     1 one     #> 2     2 NA      #> 3    NA missing  # By default, joins are equijoins, but you can use `sql_on` to # express richer relationships db1 <- memdb_frame(x = 1:5) db2 <- memdb_frame(x = 1:3, y = letters[1:3]) db1 |> left_join(db2) |> show_query() #> Joining with `by = join_by(x)` #> <SQL> #> SELECT `dbplyr_tmp_lGAnL54Xlx`.`x` AS `x`, `y` #> FROM `dbplyr_tmp_lGAnL54Xlx` #> LEFT JOIN `dbplyr_tmp_m9HzOkF05U` #>   ON (`dbplyr_tmp_lGAnL54Xlx`.`x` = `dbplyr_tmp_m9HzOkF05U`.`x`) db1 |> left_join(db2, sql_on = \"LHS.x < RHS.x\") |> show_query() #> <SQL> #> SELECT `LHS`.`x` AS `x.x`, `RHS`.`x` AS `x.y`, `y` #> FROM `dbplyr_tmp_lGAnL54Xlx` AS `LHS` #> LEFT JOIN `dbplyr_tmp_m9HzOkF05U` AS `RHS` #>   ON (LHS.x < RHS.x)"},{"path":"https://dbplyr.tidyverse.org/dev/reference/lahman.html","id":null,"dir":"Reference","previous_headings":"","what":"Cache and retrieve an src_sqlite of the Lahman baseball database. — lahman","title":"Cache and retrieve an src_sqlite of the Lahman baseball database. — lahman","text":"creates interesting database using data Lahman baseball data source, provided Sean Lahman, made easily available R Lahman package Michael Friendly, Dennis Murphy Martin Monkman. See documentation package documentation individual tables.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/lahman.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cache and retrieve an src_sqlite of the Lahman baseball database. — lahman","text":"","code":"lahman_sqlite(path = NULL)  lahman_postgres(dbname = \"lahman\", host = \"localhost\", ...)  lahman_mysql(dbname = \"lahman\", ...)  copy_lahman(con, ...)  has_lahman(type, ...)  lahman_srcs(..., quiet = NULL)"},{"path":"https://dbplyr.tidyverse.org/dev/reference/lahman.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cache and retrieve an src_sqlite of the Lahman baseball database. — lahman","text":"... arguments passed src first load. MySQL PostgreSQL, defaults assume local server lahman database already created. lahman_srcs(), character vector names giving srcs generate. type src type. quiet TRUE, suppress messages databases failing connect.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/lahman.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cache and retrieve an src_sqlite of the Lahman baseball database. — lahman","text":"","code":"# Connect to a local sqlite database, if already created # \\donttest{ library(dplyr)  if (has_lahman(\"sqlite\")) {   lahman_sqlite()   batting <- tbl(lahman_sqlite(), \"Batting\")   batting } #> Creating table: AllstarFull #> Creating table: Appearances #> Creating table: AwardsManagers #> Creating table: AwardsPlayers #> Creating table: AwardsShareManagers #> Creating table: AwardsSharePlayers #> Creating table: Batting #> Creating table: BattingPost #> Creating table: CollegePlaying #> Creating table: Fielding #> Creating table: FieldingOF #> Creating table: FieldingOFsplit #> Creating table: FieldingPost #> Creating table: HallOfFame #> Creating table: HomeGames #> Creating table: LahmanData #> Creating table: Managers #> Creating table: ManagersHalf #> Creating table: Parks #> Creating table: People #> Creating table: Pitching #> Creating table: PitchingPost #> Creating table: Salaries #> Creating table: Schools #> Creating table: SeriesPost #> Creating table: Teams #> Creating table: TeamsFranchises #> Creating table: TeamsHalf #> # A query:  ?? x 22 #> # Database: sqlite 3.51.1 [/tmp/RtmprAtmWP/lahman.sqlite] #>    playerID  yearID stint teamID lgID      G    AB     R     H   X2B #>    <chr>      <int> <int> <chr>  <chr> <int> <int> <int> <int> <int> #>  1 aardsda01   2004     1 SFN    NL       11     0     0     0     0 #>  2 aardsda01   2006     1 CHN    NL       45     2     0     0     0 #>  3 aardsda01   2007     1 CHA    AL       25     0     0     0     0 #>  4 aardsda01   2008     1 BOS    AL       47     1     0     0     0 #>  5 aardsda01   2009     1 SEA    AL       73     0     0     0     0 #>  6 aardsda01   2010     1 SEA    AL       53     0     0     0     0 #>  7 aardsda01   2012     1 NYA    AL        1     0     0     0     0 #>  8 aardsda01   2013     1 NYN    NL       43     0     0     0     0 #>  9 aardsda01   2015     1 ATL    NL       33     1     0     0     0 #> 10 aaronha01   1954     1 ML1    NL      122   468    58   131    27 #> # ℹ more rows #> # ℹ 12 more variables: X3B <int>, HR <int>, RBI <int>, SB <int>, #> #   CS <int>, BB <int>, SO <int>, IBB <int>, HBP <int>, SH <int>, #> #   SF <int>, GIDP <int>  # Connect to a local postgres database with lahman database, if available if (has_lahman(\"postgres\")) {   lahman_postgres()   batting <- tbl(lahman_postgres(), \"Batting\") } #> Error: connection to server at \"localhost\" (::1), port 5432 failed: Connection refused #> \tIs the server running on that host and accepting TCP/IP connections? #> connection to server at \"localhost\" (127.0.0.1), port 5432 failed: Connection refused #> \tIs the server running on that host and accepting TCP/IP connections? # }"},{"path":"https://dbplyr.tidyverse.org/dev/reference/last_sql.html","id":null,"dir":"Reference","previous_headings":"","what":"Retrieve the last SQL query generated — last_sql","title":"Retrieve the last SQL query generated — last_sql","text":"helper function retrieves recent SQL query generated dbplyr, can useful debugging.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/last_sql.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Retrieve the last SQL query generated — last_sql","text":"","code":"last_sql()"},{"path":"https://dbplyr.tidyverse.org/dev/reference/last_sql.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Retrieve the last SQL query generated — last_sql","text":"SQL string, NULL query generated yet.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/last_sql.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Retrieve the last SQL query generated — last_sql","text":"","code":"library(dplyr, warn.conflicts = FALSE)  df <- lazy_frame(x = 1:3) df |> filter(x > 1) #> <SQL> #> SELECT \"df\".* #> FROM \"df\" #> WHERE (\"x\" > 1.0)  last_sql() #> <SQL> SELECT \"df\".* #> FROM \"df\" #> WHERE (\"x\" > 1.0)"},{"path":"https://dbplyr.tidyverse.org/dev/reference/lazy_ops.html","id":null,"dir":"Reference","previous_headings":"","what":"Lazy operations — lazy_ops","title":"Lazy operations — lazy_ops","text":"set S3 classes describe action dplyr verbs. currently used SQL sources separate description operations R computation SQL. API new likely evolve future.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/lazy_ops.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Lazy operations — lazy_ops","text":"","code":"lazy_base_query(x, vars, class = character(), ...)  op_grps(op)  op_vars(op)  op_sort(op)  op_frame(op)"},{"path":"https://dbplyr.tidyverse.org/dev/reference/lazy_ops.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Lazy operations — lazy_ops","text":"op_vars() op_grps() compute variables groups sequence lazy operations. op_sort() op_frame() tracks order frame use window functions.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/memdb.html","id":null,"dir":"Reference","previous_headings":"","what":"A temporary in-memory database — memdb","title":"A temporary in-memory database — memdb","text":"memdb() creates temporary -memory database disappears R session ends. convenient way learn experiment dbplyr without connect \"real\" database. memdb_frame() works like tibble::tibble(), instead creating new data frame R, creates table memdb(). local_memdb_frame() like memdb_frame() table automatically deleted current scope ends. useful tests.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/memdb.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A temporary in-memory database — memdb","text":"","code":"memdb()  memdb_frame(.name = unique_table_name(), ...)  local_memdb_frame(.name = unique_table_name(), ..., frame = caller_env())"},{"path":"https://dbplyr.tidyverse.org/dev/reference/memdb.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A temporary in-memory database — memdb","text":".name Name table database: defaults random name unlikely conflict existing table. ... <dynamic-dots> set name-value pairs. arguments processed rlang::quos() support unquote via rlang::!! unquote-splice via rlang::!!!. Use := create columns start dot. Arguments evaluated sequentially. can refer previously created elements directly using rlang::.data pronoun. refer explicitly objects calling environment, use rlang::!! rlang::.env, e.g. !!.data .env$.data special case object named .data. frame created table bound execution frame deleted ends. expert use .","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/memdb.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A temporary in-memory database — memdb","text":"","code":"library(dplyr)  # use memdb_frame() to create a new database table df <- memdb_frame(x = runif(100), y = runif(100)) df |> arrange(x) #> # A query:    ?? x 2 #> # Database:   sqlite 3.51.1 [:memory:] #> # Ordered by: x #>         x      y #>     <dbl>  <dbl> #>  1 0.0162 0.400  #>  2 0.0181 0.295  #>  3 0.0237 0.830  #>  4 0.0275 0.346  #>  5 0.0406 0.213  #>  6 0.0472 0.931  #>  7 0.0612 0.980  #>  8 0.0701 0.324  #>  9 0.0718 0.346  #> 10 0.0919 0.0265 #> # ℹ more rows df |> arrange(x) |> show_query() #> <SQL> #> SELECT `dbplyr_tmp_KpjGw3nPZi`.* #> FROM `dbplyr_tmp_KpjGw3nPZi` #> ORDER BY `x`  # Use memdb() + copy_to() to copy an existing data frame iris_db <- copy_to(memdb(), iris) iris_db #> # A query:  ?? x 5 #> # Database: sqlite 3.51.1 [:memory:] #>    Sepal.Length Sepal.Width Petal.Length Petal.Width Species #>           <dbl>       <dbl>        <dbl>       <dbl> <chr>   #>  1          5.1         3.5          1.4         0.2 setosa  #>  2          4.9         3            1.4         0.2 setosa  #>  3          4.7         3.2          1.3         0.2 setosa  #>  4          4.6         3.1          1.5         0.2 setosa  #>  5          5           3.6          1.4         0.2 setosa  #>  6          5.4         3.9          1.7         0.4 setosa  #>  7          4.6         3.4          1.4         0.3 setosa  #>  8          5           3.4          1.5         0.2 setosa  #>  9          4.4         2.9          1.4         0.2 setosa  #> 10          4.9         3.1          1.5         0.1 setosa  #> # ℹ more rows"},{"path":"https://dbplyr.tidyverse.org/dev/reference/mutate.tbl_lazy.html","id":null,"dir":"Reference","previous_headings":"","what":"Create, modify, and delete columns — mutate.tbl_lazy","title":"Create, modify, and delete columns — mutate.tbl_lazy","text":"methods dplyr dplyr::mutate() dplyr::transmute() generics. translated computed expressions SELECT clause SQL query.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/mutate.tbl_lazy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create, modify, and delete columns — mutate.tbl_lazy","text":"","code":"# S3 method for class 'tbl_lazy' mutate(   .data,   ...,   .by = NULL,   .order = NULL,   .frame = NULL,   .keep = c(\"all\", \"used\", \"unused\", \"none\"),   .before = NULL,   .after = NULL )"},{"path":"https://dbplyr.tidyverse.org/dev/reference/mutate.tbl_lazy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create, modify, and delete columns — mutate.tbl_lazy","text":".data lazy data frame backed database query. ... <data-masking> Variables, functions variables. Use desc() sort variable descending order. . <tidy-select> Optionally, selection columns group just operation, functioning alternative group_by(). details examples, see ?dplyr_by. .order <data-masking> selection columns control ordering window functions within dplyr::mutate() call. Use c() order multiple columns, e.g. .order = c(x, y). column can wrapped dplyr::desc() specify descending order. Equivalent calling window_order() clearing dplyr::mutate(). .frame length-2 numeric vector specifying bounds window function frames. first element lower bound (use -Inf \"unbounded preceding\") second upper bound (use Inf \"unbounded following\", 0 \"current row\"). Equivalent calling window_frame() clearing dplyr::mutate(). .keep Control columns .data retained output. Grouping columns columns created ... always kept. \"\" retains columns .data. default. \"used\" retains columns used ... create new columns. useful checking work, displays inputs outputs side--side. \"unused\" retains columns used ... create new columns. useful generate new columns, longer need columns used generate . \"none\" retain extra columns .data. grouping variables columns created ... kept. ., .<tidy-select> Optionally, control new columns appear (default add right hand side). See relocate() details.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/mutate.tbl_lazy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create, modify, and delete columns — mutate.tbl_lazy","text":"Another tbl_lazy. Use show_query() see generated query, use collect() execute query return data R.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/mutate.tbl_lazy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create, modify, and delete columns — mutate.tbl_lazy","text":"","code":"library(dplyr, warn.conflicts = FALSE)  db <- memdb_frame(x = 1:5, y = 5:1) db |>   mutate(a = (x + y) / 2, b = sqrt(x^2L + y^2L)) |>   show_query() #> <SQL> #> SELECT #>   `dbplyr_tmp_I6Ojtgl00s`.*, #>   (`x` + `y`) / 2.0 AS `a`, #>   SQRT((POWER(`x`, 2)) + POWER(`y`, 2)) AS `b` #> FROM `dbplyr_tmp_I6Ojtgl00s`  # dbplyr automatically creates subqueries as needed db |>   mutate(x1 = x + 1, x2 = x1 * 2) |>   show_query() #> <SQL> #> SELECT `q01`.*, `x1` * 2.0 AS `x2` #> FROM ( #>   SELECT `dbplyr_tmp_I6Ojtgl00s`.*, `x` + 1.0 AS `x1` #>   FROM `dbplyr_tmp_I6Ojtgl00s` #> ) AS `q01`  # `.order` and `.frame` control window functions db <- memdb_frame(g = c(1, 1, 2, 2, 2), x = c(5, 3, 1, 4, 2)) db |>   mutate(rolling_sum = sum(x), .by = g, .order = x, .frame = c(-2, 2)) |>   show_query() #> Warning: Missing values are always removed in SQL aggregation functions. #> Use `na.rm = TRUE` to silence this warning #> This warning is displayed once every 8 hours. #> <SQL> #> SELECT #>   `dbplyr_tmp_IlBpEtJTVT`.*, #>   SUM(`x`) OVER (PARTITION BY `g` ORDER BY `x` ROWS BETWEEN 2 PRECEDING AND 2 FOLLOWING) AS `rolling_sum` #> FROM `dbplyr_tmp_IlBpEtJTVT`"},{"path":"https://dbplyr.tidyverse.org/dev/reference/named_commas.html","id":null,"dir":"Reference","previous_headings":"","what":"Provides comma-separated string out of the parameters — named_commas","title":"Provides comma-separated string out of the parameters — named_commas","text":"Provides comma-separated string parameters","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/named_commas.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Provides comma-separated string out of the parameters — named_commas","text":"","code":"named_commas(x)"},{"path":"https://dbplyr.tidyverse.org/dev/reference/nycflights13.html","id":null,"dir":"Reference","previous_headings":"","what":"Database versions of the nycflights13 data — nycflights13","title":"Database versions of the nycflights13 data — nycflights13","text":"functions cache data nycflights13 database local database, use examples vignettes. Indexes created making joining tables natural keys efficient.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/nycflights13.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Database versions of the nycflights13 data — nycflights13","text":"","code":"nycflights13_sqlite(path = NULL)  nycflights13_postgres(dbname = \"nycflights13\", ...)  has_nycflights13(type = c(\"sqlite\", \"postgres\"), ...)  copy_nycflights13(con, ...)"},{"path":"https://dbplyr.tidyverse.org/dev/reference/nycflights13.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Database versions of the nycflights13 data — nycflights13","text":"path location SQLite database file dbname, ... Arguments passed dplyr::src_postgres()","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/partial_eval.html","id":null,"dir":"Reference","previous_headings":"","what":"Partially evaluate an expression. — partial_eval","title":"Partially evaluate an expression. — partial_eval","text":"function partially evaluates expression, using information tbl determine whether names refer local expressions remote variables. simplifies SQL translation expressions need carry around environment - relevant information incorporated expression.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/partial_eval.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Partially evaluate an expression. — partial_eval","text":"","code":"partial_eval(call, data, env = caller_env(), error_call = caller_env())"},{"path":"https://dbplyr.tidyverse.org/dev/reference/partial_eval.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Partially evaluate an expression. — partial_eval","text":"call unevaluated expression, produced quote() data lazy data frame backed database query. env environment search local values","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/partial_eval.html","id":"symbol-substitution","dir":"Reference","previous_headings":"","what":"Symbol substitution","title":"Partially evaluate an expression. — partial_eval","text":"partial_eval() needs guess referring variable server (remote), current environment (local). possible 100% perfectly. partial_eval() uses following heuristic: tbl variables known, symbol matches tbl variable, remote. symbol defined locally, local. Otherwise, remote. can override guesses using local() remote() force computation, using .data .env pronouns tidy evaluation, using dbplyr's .sql pronoun.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/partial_eval.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Partially evaluate an expression. — partial_eval","text":"","code":"lf <- lazy_frame(year = 1980, id = 1) partial_eval(quote(year > 1980), data = lf) #> year > 1980  ids <- c(\"ansonca01\", \"forceda01\", \"mathebo01\") partial_eval(quote(id %in% ids), lf) #> id %in% c(\"ansonca01\", \"forceda01\", \"mathebo01\")  # cf. partial_eval(quote(id == .data$id), lf) #> id == id  # You can use local() or .env to disambiguate between local and remote # variables: otherwise remote is always preferred year <- 1980 partial_eval(quote(year > year), lf) #> year > year partial_eval(quote(year > local(year)), lf) #> year > 1980 partial_eval(quote(year > .env$year), lf) #> year > 1980  # Functions are always assumed to be remote. Use local to force evaluation # in R. f <- function(x) x + 1 partial_eval(quote(year > f(1980)), lf) #> year > f(1980) partial_eval(quote(year > local(f(1980))), lf) #> year > 1981  # You can use `.sql` to make it clear that the function comes from SQL, # and inside a package, reduce the number of globalVariables() directives # needed partial_eval(quote(.sql$EXTRACT_YEAR(year)), lf) #> EXTRACT_YEAR(year)"},{"path":"https://dbplyr.tidyverse.org/dev/reference/pivot_longer.tbl_lazy.html","id":null,"dir":"Reference","previous_headings":"","what":"Pivot data from wide to long — pivot_longer.tbl_lazy","title":"Pivot data from wide to long — pivot_longer.tbl_lazy","text":"pivot_longer() \"lengthens\" data, increasing number rows decreasing number columns. inverse transformation tidyr::pivot_wider(). Learn vignette(\"pivot\", \"tidyr\"). functionality identical differences pivot_longer() local data frames: output sorted differently/explicitly, coercion mixed column types left database, values_ptypes supported. Note build_longer_spec() pivot_longer_spec() work remote tables.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/pivot_longer.tbl_lazy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pivot data from wide to long — pivot_longer.tbl_lazy","text":"","code":"# S3 method for class 'tbl_lazy' pivot_longer(   data,   cols,   ...,   cols_vary,   names_to = \"name\",   names_prefix = NULL,   names_sep = NULL,   names_pattern = NULL,   names_ptypes = NULL,   names_transform = NULL,   names_repair = \"check_unique\",   values_to = \"value\",   values_drop_na = FALSE,   values_ptypes,   values_transform = NULL )"},{"path":"https://dbplyr.tidyverse.org/dev/reference/pivot_longer.tbl_lazy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pivot data from wide to long — pivot_longer.tbl_lazy","text":"data data frame pivot. cols Columns pivot longer format. ... Additional arguments passed methods. cols_vary Unsupported; included compatibility generic. names_to string specifying name column create data stored column names data. names_prefix regular expression used remove matching text start variable name. names_sep, names_pattern names_to contains multiple values, arguments control column name broken . names_ptypes list column name-prototype pairs. names_transform, values_transform list column name-function pairs. names_repair happens output invalid column names? values_to string specifying name column create data stored cell values. names_to character containing special .value sentinel, value ignored, name value column derived part existing column names. values_drop_na TRUE, drop rows contain NAs value_to column. values_ptypes supported.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/pivot_longer.tbl_lazy.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Pivot data from wide to long — pivot_longer.tbl_lazy","text":"SQL translation basically works follows: split specification key columns .e. variables crammed column names. part split specification transmute() data following columns id columns .e. columns pivotted key columns value columns .e. columns pivotted combine parts union_all()","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/pivot_longer.tbl_lazy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Pivot data from wide to long — pivot_longer.tbl_lazy","text":"","code":"# See vignette(\"pivot\") for examples and explanation  # Simplest case where column names are character data memdb_frame(   id = c(\"a\", \"b\"),   x = 1:2,   y = 3:4 ) |>   tidyr::pivot_longer(-id) #> # A query:  ?? x 3 #> # Database: sqlite 3.51.1 [:memory:] #>   id    name  value #>   <chr> <chr> <int> #> 1 a     x         1 #> 2 b     x         2 #> 3 a     y         3 #> 4 b     y         4"},{"path":"https://dbplyr.tidyverse.org/dev/reference/pivot_wider.tbl_lazy.html","id":null,"dir":"Reference","previous_headings":"","what":"Pivot data from long to wide — pivot_wider.tbl_lazy","title":"Pivot data from long to wide — pivot_wider.tbl_lazy","text":"pivot_wider() \"widens\" data, increasing number columns decreasing number rows. inverse transformation pivot_longer(). Learn vignette(\"pivot\", \"tidyr\"). pivot_wider() database tables comes caveats, please make sure read details.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/pivot_wider.tbl_lazy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pivot data from long to wide — pivot_wider.tbl_lazy","text":"","code":"# S3 method for class 'tbl_lazy' pivot_wider(   data,   ...,   id_cols = NULL,   id_expand = FALSE,   names_from = name,   names_prefix = \"\",   names_sep = \"_\",   names_glue = NULL,   names_sort = FALSE,   names_vary = \"fastest\",   names_expand = FALSE,   names_repair = \"check_unique\",   values_from = value,   values_fill = NULL,   values_fn = ~max(.x, na.rm = TRUE),   unused_fn = NULL )  dbplyr_pivot_wider_spec(   data,   spec,   ...,   names_repair = \"check_unique\",   id_cols = NULL,   id_expand = FALSE,   values_fill = NULL,   values_fn = ~max(.x, na.rm = TRUE),   unused_fn = NULL,   error_call = current_env() )"},{"path":"https://dbplyr.tidyverse.org/dev/reference/pivot_wider.tbl_lazy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pivot data from long to wide — pivot_wider.tbl_lazy","text":"data lazy data frame backed database query. ... Unused; included compatibility generic. id_cols set columns uniquely identifies observation. id_expand Unused; included compatibility generic. names_from, values_from pair arguments describing column (columns) get name output column (names_from), column (columns) get cell values (values_from). values_from contains multiple values, value added front output column. names_prefix String added start every variable name. names_sep names_from values_from contains multiple variables, used join values together single string use column name. names_glue Instead names_sep names_prefix, can supply glue specification uses names_from columns (special .value) create custom column names. names_sort column names sorted? FALSE, default, column names ordered first appearance. names_vary names_from identifies column (columns) multiple unique values, multiple values_from columns provided, order resulting column names combined? \"fastest\" varies names_from values fastest, resulting column naming scheme form: value1_name1, value1_name2, value2_name1, value2_name2. default. \"slowest\" varies names_from values slowest, resulting column naming scheme form: value1_name1, value2_name1, value1_name2, value2_name2. names_expand values names_from columns expanded tidyr::expand() pivoting? results columns, output contain column names corresponding complete expansion possible values names_from. Additionally, column names sorted, identical names_sort produce. names_repair happens output invalid column names? values_fill Optionally, (scalar) value specifies value filled missing. careful using combination default values_fn. values_fn function, default max(), applied value cell output. contrast local data frames must NULL. unused_fn Optionally, function applied summarize values unused columns (.e. columns identified id_cols, names_from, values_from). default drops unused columns result. can named list want apply different aggregations different unused columns. id_cols must supplied unused_fn useful, since otherwise unspecified columns considered id_cols. similar grouping id_cols summarizing unused columns using unused_fn. spec specification data frame. useful complex pivots gives greater control metadata stored columns become column names result. Must data frame containing character .name .value columns. Additional columns spec named match columns long format dataset contain values corresponding columns pivoted wide format. special .seq variable used disambiguate rows internally; automatically removed pivoting. error_call execution environment currently running function, e.g. caller_env(). function mentioned error messages source error. See call argument abort() information.","code":""},{"path":[]},{"path":"https://dbplyr.tidyverse.org/dev/reference/pivot_wider.tbl_lazy.html","id":"pivot-wider-is-eager","dir":"Reference","previous_headings":"","what":"pivot_wider() is eager","title":"Pivot data from long to wide — pivot_wider.tbl_lazy","text":"Note pivot_wider() lazy need look data figure new column names . long-running query two options: Temporarily store result query via compute(). Create spec use dbplyr_pivot_wider_spec() - dbplyr's version tidyr::pivot_wider_spec().","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/pivot_wider.tbl_lazy.html","id":"you-must-supply-values-fn","dir":"Reference","previous_headings":"","what":"You must supply values_fn","title":"Pivot data from long to wide — pivot_wider.tbl_lazy","text":"big difference pivot_wider() local data frames values_fn must NULL. default max() yields results local data frames three conditions true: combination id_cols value uniquely identify observation. column comparable type (e.g. numeric, date-time, (databases) string). values_fill NULL. either second third condition met, must supply custom values_fn. Unfortunately generally available alternative need look something database specific, like FIRST() ANY_VALUE().","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/pivot_wider.tbl_lazy.html","id":"how-does-it-work-","dir":"Reference","previous_headings":"","what":"How does it work?","title":"Pivot data from long to wide — pivot_wider.tbl_lazy","text":"translation SQL code basically works follows: Get unique keys names_from column. key value generate expression form:   Group data id columns. Summarise grouped data expressions step 2.","code":"values_fn(   CASE WHEN (`names from column` == `key value`) THEN (`value column`) END ) AS `output column`"},{"path":"https://dbplyr.tidyverse.org/dev/reference/pivot_wider.tbl_lazy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Pivot data from long to wide — pivot_wider.tbl_lazy","text":"","code":"memdb_frame(   id = 1,   key = c(\"x\", \"y\"),   value = 1:2 ) |>   tidyr::pivot_wider(     id_cols = id,     names_from = key,     values_from = value   ) #> # A query:  ?? x 3 #> # Database: sqlite 3.51.1 [:memory:] #>      id     x     y #>   <dbl> <int> <int> #> 1     1     1     2"},{"path":"https://dbplyr.tidyverse.org/dev/reference/pull.tbl_sql.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract a single column — pull.tbl_sql","title":"Extract a single column — pull.tbl_sql","text":"method dplyr dplyr::pull() generic. evaluates query retrieving just specified column.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/pull.tbl_sql.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract a single column — pull.tbl_sql","text":"","code":"# S3 method for class 'tbl_sql' pull(.data, var = -1, name = NULL, ...)"},{"path":"https://dbplyr.tidyverse.org/dev/reference/pull.tbl_sql.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract a single column — pull.tbl_sql","text":".data lazy data frame backed database query. var variable specified : literal variable name positive integer, giving position counting left negative integer, giving position counting right. default returns last column (assumption column created recently). argument taken expression supports quasiquotation (can unquote column names column locations). name optional parameter specifies column used names named vector. Specified similar manner var. ... <data-masking> Variables, functions variables. Use desc() sort variable descending order.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/pull.tbl_sql.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract a single column — pull.tbl_sql","text":"vector data.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/pull.tbl_sql.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract a single column — pull.tbl_sql","text":"","code":"library(dplyr, warn.conflicts = FALSE)  db <- memdb_frame(x = 1:5, y = 5:1) db |>   mutate(z = x + y * 2) |>   pull() #> [1] 11 10  9  8  7"},{"path":"https://dbplyr.tidyverse.org/dev/reference/remote_name.html","id":null,"dir":"Reference","previous_headings":"","what":"Metadata about a remote table — remote_name","title":"Metadata about a remote table — remote_name","text":"remote_name() gives unescaped name remote table, NULL query (created sql()) already escape (created ident_q()). remote_table() gives remote table query. remote_query() gives text query, remote_query_plan() query plan (computed remote database). remote_src() remote_con() give dplyr source DBI connection respectively.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/remote_name.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Metadata about a remote table — remote_name","text":"","code":"remote_name(x, null_if_local = TRUE)  remote_table(x, null_if_local = TRUE)  remote_src(x)  remote_con(x)  remote_query(x, cte = FALSE, sql_options = NULL)  remote_query_plan(x, ...)"},{"path":"https://dbplyr.tidyverse.org/dev/reference/remote_name.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metadata about a remote table — remote_name","text":"x Remote table, currently must tbl_sql. null_if_local Return NULL remote table created via tbl_lazy() lazy_frame()? cte Use sql_options argument instead. sql_options SQL rendering options generated sql_options(). ... Additional arguments passed methods.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/remote_name.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Metadata about a remote table — remote_name","text":"string, NULL remote table, applicable. example, computed queries \"name\".","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/remote_name.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Metadata about a remote table — remote_name","text":"","code":"mf <- memdb_frame(x = 1:5, y = 5:1, .name = \"blorp\") remote_name(mf) #> [1] \"blorp\" remote_src(mf) #> <S4 class ‘SQLiteConnection’ [package “RSQLite”] with 8 slots>NULL remote_con(mf) #> <SQLiteConnection> #>   Path: :memory: #>   Extensions: TRUE remote_query(mf) #> <SQL> SELECT * #> FROM `blorp`  mf2 <- dplyr::filter(mf, x > 3) remote_name(mf2) #> NULL remote_src(mf2) #> <S4 class ‘SQLiteConnection’ [package “RSQLite”] with 8 slots>NULL remote_con(mf2) #> <SQLiteConnection> #>   Path: :memory: #>   Extensions: TRUE remote_query(mf2) #> <SQL> SELECT `blorp`.* #> FROM `blorp` #> WHERE (`x` > 3.0)"},{"path":"https://dbplyr.tidyverse.org/dev/reference/replace_na.tbl_lazy.html","id":null,"dir":"Reference","previous_headings":"","what":"Replace NAs with specified values — replace_na.tbl_lazy","title":"Replace NAs with specified values — replace_na.tbl_lazy","text":"method tidyr::replace_na() generic.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/replace_na.tbl_lazy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Replace NAs with specified values — replace_na.tbl_lazy","text":"","code":"# S3 method for class 'tbl_lazy' replace_na(data, replace = list(), ...)"},{"path":"https://dbplyr.tidyverse.org/dev/reference/replace_na.tbl_lazy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Replace NAs with specified values — replace_na.tbl_lazy","text":"data pair lazy data frame backed database queries. replace named list values, one value column NA values replaced. ... Unused; included compatibility generic.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/replace_na.tbl_lazy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Replace NAs with specified values — replace_na.tbl_lazy","text":"Another tbl_lazy. Use show_query() see generated query, use collect() execute query return data R.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/replace_na.tbl_lazy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Replace NAs with specified values — replace_na.tbl_lazy","text":"","code":"df <- memdb_frame(x = c(1, 2, NA), y = c(\"a\", NA, \"b\")) df |> tidyr::replace_na(list(x = 0, y = \"unknown\")) #> # A query:  ?? x 2 #> # Database: sqlite 3.51.1 [:memory:] #>       x y       #>   <dbl> <chr>   #> 1     1 a       #> 2     2 unknown #> 3     0 b"},{"path":"https://dbplyr.tidyverse.org/dev/reference/rows-db.html","id":null,"dir":"Reference","previous_headings":"","what":"Edit individual rows in the underlying database table — rows_insert.tbl_lazy","title":"Edit individual rows in the underlying database table — rows_insert.tbl_lazy","text":"methods dplyr dplyr::rows_insert(), dplyr::rows_append(), dplyr::rows_update(), dplyr::rows_patch(), dplyr::rows_upsert(), dplyr::rows_delete() generics. in_place = TRUE verbs generate SELECT queries, instead directly modify underlying data using INSERT, UPDATE, DELETE operators. require write access database: connection needs permission insert, modify delete rows, alter structure table. default, in_place = FALSE, generates equivalent lazy tables (using SELECT queries) allow previewing result without actually modifying underlying table database.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/rows-db.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Edit individual rows in the underlying database table — rows_insert.tbl_lazy","text":"","code":"# S3 method for class 'tbl_lazy' rows_insert(   x,   y,   by = NULL,   ...,   conflict = c(\"error\", \"ignore\"),   copy = \"none\",   in_place = FALSE,   returning = NULL,   method = NULL )  # S3 method for class 'tbl_lazy' rows_append(x, y, ..., copy = \"none\", in_place = FALSE, returning = NULL)  # S3 method for class 'tbl_lazy' rows_update(   x,   y,   by = NULL,   ...,   unmatched = c(\"error\", \"ignore\"),   copy = \"none\",   in_place = FALSE,   returning = NULL )  # S3 method for class 'tbl_lazy' rows_patch(   x,   y,   by = NULL,   ...,   unmatched = c(\"error\", \"ignore\"),   copy = \"none\",   in_place = FALSE,   returning = NULL )  # S3 method for class 'tbl_lazy' rows_upsert(   x,   y,   by = NULL,   ...,   copy = \"none\",   in_place = FALSE,   returning = NULL,   method = NULL )  # S3 method for class 'tbl_lazy' rows_delete(   x,   y,   by = NULL,   ...,   unmatched = c(\"error\", \"ignore\"),   copy = \"none\",   in_place = FALSE,   returning = NULL )"},{"path":"https://dbplyr.tidyverse.org/dev/reference/rows-db.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Edit individual rows in the underlying database table — rows_insert.tbl_lazy","text":"x lazy table. in_place = TRUE, must table instantiated dplyr::tbl() dplyr::compute(), lazy query. remote_name() function used determine name table updated. y lazy table, data frame, data frame extensions (e.g. tibble). unnamed character vector giving key columns. key columns must exist x y. Keys typically uniquely identify row, enforced key values y rows_update(), rows_patch(), rows_upsert() used. default, use first column y, since first column reasonable place put identifier variable. ... parameters passed onto methods. conflict rows_insert(), keys y conflict keys x handled? conflict arises key y already exists x. One : \"error\", default, supported database tables. get behaviour add unique index columns use rows_append(). \"ignore\" ignore rows y keys conflict keys x. copy x y data source, copy controls y copied source x. three options: \"none\", default, error y needs copied. ensures accidentally copy large datasets R database. \"temp-table\": copies y temporary table database x. *_join() automatically run ANALYZE created table hope make queries efficient possible giving data query planner. \"inline\": y inlined query using copy_inline(). faster small datasets require write access. TRUE (\"temp-table\") FALSE (\"none\") also accepted backward compatibility. in_place x modified place? FALSE generate SELECT query returns modified table; TRUE modify underlying table using DML operation (INSERT, UPDATE, DELETE similar). returning Columns return. See get_returned_rows() details. method string specifying method use. relevant in_place = TRUE. unmatched rows_update(), rows_patch(), rows_delete(), keys y unmatched keys x handled? One : \"error\", default, supported database tables. Add foreign key constraint columns y let database check behaviour . \"ignore\" ignore rows y keys unmatched keys x.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/rows-db.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Edit individual rows in the underlying database table — rows_insert.tbl_lazy","text":"new tbl_lazy modified data. in_place = FALSE, result lazy query prints visibly, purpose operation preview results. in_place = TRUE, x returned invisibly, purpose operation side effect modifying rows table behind x.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/rows-db.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Edit individual rows in the underlying database table — rows_insert.tbl_lazy","text":"","code":"library(dplyr)  con <- DBI::dbConnect(RSQLite::SQLite(), \":memory:\") DBI::dbExecute(con, \"CREATE TABLE Ponies (    id INTEGER PRIMARY KEY AUTOINCREMENT,    name TEXT,    cutie_mark TEXT )\") #> [1] 0  ponies <- tbl(con, \"Ponies\")  applejack <- copy_inline(con, data.frame(   name = \"Apple Jack\",   cutie_mark = \"three apples\" ))  # The default behavior is to generate a SELECT query rows_insert(ponies, applejack, conflict = \"ignore\") #> Matching, by = \"name\" #> # A query:  ?? x 3 #> # Database: sqlite 3.51.1 [:memory:] #>   id    name       cutie_mark   #>   <lgl> <chr>      <chr>        #> 1 NA    Apple Jack three apples # And the original table is left unchanged: ponies #> # A query:  ?? x 3 #> # Database: sqlite 3.51.1 [:memory:] #> # ℹ 3 variables: id <int>, name <chr>, cutie_mark <chr>  # You can also choose to modify the table with in_place = TRUE: rows_insert(ponies, applejack, conflict = \"ignore\", in_place = TRUE) #> Matching, by = \"name\" # In this case `rows_insert()` returns nothing and the underlying # data is modified ponies #> # A query:  ?? x 3 #> # Database: sqlite 3.51.1 [:memory:] #>      id name       cutie_mark   #>   <int> <chr>      <chr>        #> 1     1 Apple Jack three apples"},{"path":"https://dbplyr.tidyverse.org/dev/reference/select.tbl_lazy.html","id":null,"dir":"Reference","previous_headings":"","what":"Subset, rename, and reorder columns using their names — select.tbl_lazy","title":"Subset, rename, and reorder columns using their names — select.tbl_lazy","text":"methods dplyr dplyr::select(), dplyr::rename(), dplyr::relocate() generics. generate SELECT clause SQL query. functions support predicate functions, .e. can use (.numeric) select numeric variables.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/select.tbl_lazy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Subset, rename, and reorder columns using their names — select.tbl_lazy","text":"","code":"# S3 method for class 'tbl_lazy' select(.data, ...)  # S3 method for class 'tbl_lazy' rename(.data, ...)  # S3 method for class 'tbl_lazy' rename_with(.data, .fn, .cols = everything(), ...)  # S3 method for class 'tbl_lazy' relocate(.data, ..., .before = NULL, .after = NULL)"},{"path":"https://dbplyr.tidyverse.org/dev/reference/select.tbl_lazy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Subset, rename, and reorder columns using their names — select.tbl_lazy","text":".data lazy data frame backed database query. ... <data-masking> Variables, functions variables. Use desc() sort variable descending order. .fn function used transform selected .cols. return character vector length input. .cols <tidy-select> Columns rename; defaults columns. ., .<tidy-select> Destination columns selected .... Supplying neither move columns left-hand side; specifying error.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/select.tbl_lazy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Subset, rename, and reorder columns using their names — select.tbl_lazy","text":"","code":"library(dplyr, warn.conflicts = FALSE)  db <- memdb_frame(x = 1, y = 2, z = 3) db |> select(-y) |> show_query() #> <SQL> #> SELECT `x`, `z` #> FROM `dbplyr_tmp_d9QWhdDrot` db |> relocate(z) |> show_query() #> <SQL> #> SELECT `z`, `x`, `y` #> FROM `dbplyr_tmp_d9QWhdDrot` db |> rename(first = x, last = z) |> show_query() #> <SQL> #> SELECT `x` AS `first`, `y`, `z` AS `last` #> FROM `dbplyr_tmp_d9QWhdDrot`"},{"path":"https://dbplyr.tidyverse.org/dev/reference/show_query.html","id":null,"dir":"Reference","previous_headings":"","what":"Show generated SQL and query plan — show_query","title":"Show generated SQL and query plan — show_query","text":"show_sql() displays SQL query dispatched database; explain() displays SQL query query plan.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/show_query.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Show generated SQL and query plan — show_query","text":"","code":"# S3 method for class 'tbl_lazy' show_query(x, ..., use_colour = TRUE, cte = FALSE, sql_options = NULL)  # S3 method for class 'tbl_sql' explain(x, ...)"},{"path":"https://dbplyr.tidyverse.org/dev/reference/show_query.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Show generated SQL and query plan — show_query","text":"x object explain ... explain(), arguments remote_query_plan(). show_query(), ignored. use_colour output coloured? cte Use sql_options argument instead. sql_options SQL rendering options generated sql_options().","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/simulate_dbi.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate database connections — simulate_dbi","title":"Simulate database connections — simulate_dbi","text":"functions generate S3 objects designed simulate action database connection, without actually database available. Obviously, simulation can incomplete, importantly allows us simulate SQL generation database without actually connecting . Simulated SQL quotes identifiers \"x\" (double quotes) default, `x` (backticks) MySQL/MariaDB/SQLite, [x] (square brackets) SQL Server. Strings quoted 'x'.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/simulate_dbi.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate database connections — simulate_dbi","text":"","code":"simulate_dbi(class = character(), ...)"},{"path":"https://dbplyr.tidyverse.org/dev/reference/sql.html","id":null,"dir":"Reference","previous_headings":"","what":"SQL escaping. — sql","title":"SQL escaping. — sql","text":"functions critical writing functions translate R functions sql functions. Typically conversion function escape inputs return sql object.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/sql.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SQL escaping. — sql","text":"","code":"sql(...)  is.sql(x)"},{"path":"https://dbplyr.tidyverse.org/dev/reference/sql.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SQL escaping. — sql","text":"... Character vectors combined single SQL vector. x Object check sql object.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/sql_build.html","id":null,"dir":"Reference","previous_headings":"","what":"Build and render SQL from a sequence of lazy operations — lazy_multi_join_query","title":"Build and render SQL from a sequence of lazy operations — lazy_multi_join_query","text":"sql_build() creates select_query S3 object, rendered SQL string sql_render(). output sql_build() designed easy test, database agnostic, hierarchical structure. Outside testing, however, always call sql_render().","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/sql_build.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build and render SQL from a sequence of lazy operations — lazy_multi_join_query","text":"","code":"lazy_multi_join_query(   x,   joins,   table_names,   vars,   group_vars = op_grps(x),   order_vars = op_sort(x),   frame = op_frame(x),   call = caller_env() )  lazy_rf_join_query(   x,   y,   type,   by,   table_names,   vars,   group_vars = op_grps(x),   order_vars = op_sort(x),   frame = op_frame(x),   call = caller_env() )  lazy_semi_join_query(   x,   y,   vars,   anti,   by,   where,   group_vars = op_grps(x),   order_vars = op_sort(x),   frame = op_frame(x),   call = caller_env() )  lazy_query(   query_type,   x,   ...,   group_vars = op_grps(x),   order_vars = op_sort(x),   frame = op_frame(x) )  lazy_select_query(   x,   select = NULL,   where = NULL,   group_by = NULL,   having = NULL,   order_by = NULL,   limit = NULL,   distinct = FALSE,   group_vars = NULL,   order_vars = NULL,   frame = NULL,   select_operation = c(\"select\", \"mutate\", \"summarise\"),   message_summarise = NULL )  lazy_set_op_query(x, y, type, all, call = caller_env())  lazy_union_query(x, unions, call = caller_env())  sql_build(op, con = NULL, ..., sql_options = NULL)  sql_render(   query,   con = NULL,   ...,   sql_options = NULL,   subquery = FALSE,   lvl = 0 )  sql_optimise(x, con = NULL, ..., subquery = FALSE)  join_query(   x,   y,   select,   ...,   type = \"inner\",   by = NULL,   suffix = c(\".x\", \".y\"),   na_matches = FALSE )  select_query(   from,   select = sql(\"*\"),   where = character(),   group_by = character(),   having = character(),   window = character(),   order_by = character(),   limit = NULL,   distinct = FALSE,   from_alias = NULL )  semi_join_query(   x,   y,   vars,   anti = FALSE,   by = NULL,   where = NULL,   na_matches = FALSE )  set_op_query(x, y, type, all = FALSE)  union_query(x, unions)"},{"path":"https://dbplyr.tidyverse.org/dev/reference/sql_build.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Build and render SQL from a sequence of lazy operations — lazy_multi_join_query","text":"... arguments passed methods. currently used. op sequence lazy operations con database connection. default NULL uses set rules similar ANSI 92, allows testing without active database connection. sql_options SQL rendering options generated sql_options(). subquery SQL going used subquery? important can place bare table name subquery  ORDER work subqueries.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/sql_build.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Build and render SQL from a sequence of lazy operations — lazy_multi_join_query","text":"sql_build() generic lazy operations, lazy_ops, generates S3 object represents query. sql_render() takes query object calls function generic database. example, sql_build.op_mutate() generates select_query, sql_render.select_query() calls sql_select(), different methods different databases. default methods generate ANSI 92 SQL possible, backends need override methods backend ANSI compliant.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/sql_expr.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate SQL from R expressions — sql_expr","title":"Generate SQL from R expressions — sql_expr","text":"sql_expr() sql_call2() superseded favour sql_glue(). Low-level building block generating SQL R expressions. Strings escaped; names become bare SQL identifiers. User infix functions % stripped. Using sql_expr() package require use globalVariables() avoid R CMD check NOTES. small amount additional pain, think worthwhile leads readable translation code.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/sql_expr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate SQL from R expressions — sql_expr","text":"","code":"sql_expr(x, con = sql_current_con())  sql_call2(.fn, ..., con = sql_current_con())"},{"path":"https://dbplyr.tidyverse.org/dev/reference/sql_expr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate SQL from R expressions — sql_expr","text":"x quasiquoted expression con Connection use escaping. set automatically called function translation. .fn Function name (string, call, symbol) ... Arguments function","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/sql_expr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate SQL from R expressions — sql_expr","text":"","code":"con <- simulate_dbi() # not necessary when writing translations  sql_expr(f(x + 1), con = con) #> <SQL> F(x + 1.0) sql_expr(f(\"x\", \"y\"), con = con) #> <SQL> F('x', 'y') sql_expr(f(x, y), con = con) #> <SQL> F(x, y)  x <- ident(\"x\") sql_expr(f(!!x, y), con = con) #> <SQL> F(\"x\", y)  sql_expr(cast(\"x\" %as% DECIMAL), con = con) #> <SQL> CAST('x' AS DECIMAL) sql_expr(round(x) %::% numeric, con = con) #> <SQL> ROUND(x) :: numeric  sql_call2(\"+\", quote(x), 1, con = con) #> <SQL> x + 1.0 sql_call2(\"+\", \"x\", 1, con = con) #> <SQL> 'x' + 1.0"},{"path":"https://dbplyr.tidyverse.org/dev/reference/sql_glue.html","id":null,"dir":"Reference","previous_headings":"","what":"Build SQL strings with glue syntax — sql_glue","title":"Build SQL strings with glue syntax — sql_glue","text":"sql_glue() sql_glue2() designed help dbplyr extenders generate custom SQL. differ whether require connection. sql_glue() retrieves ambient connection, making suitable use inside sql_translation() methods; sql_glue2() requires connection, making suitable use inside sql_ methods. name suggests, functions use glue syntax make easy mix fixed SQL varying user inputs. default glue syntax, {x}, escape x using database connection. multiple values x, collapsed single string ,. want wrapped (), use * suffix, e.g. {x*}. can also use type markers control value treated: {.sql x}: x literal SQL interpolated , without additional escaping. {.tbl x}: x table identifier like string, (), one older forms like DBI::Id() in_schema(). {.id x}: x generic identifier, e.g. column index.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/sql_glue.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build SQL strings with glue syntax — sql_glue","text":"","code":"sql_glue(sql, envir = parent.frame())  sql_glue2(con, sql, envir = parent.frame())"},{"path":"https://dbplyr.tidyverse.org/dev/reference/sql_glue.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Build SQL strings with glue syntax — sql_glue","text":"sql string interpolate. envir Environment evaluate sql . con database connection.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/sql_glue.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Build SQL strings with glue syntax — sql_glue","text":"SQL string.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/sql_glue.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Build SQL strings with glue syntax — sql_glue","text":"","code":"con <- simulate_dbi()  tbl <- \"my_table\" sql_glue2(con, \"SELECT * FROM {.tbl tbl}\") #> <SQL> SELECT * FROM \"my_table\"  # Values are properly escaped name <- \"Robert'); DROP TABLE students;--\" sql_glue2(con, \"INSERT INTO students (name) VALUES ({name})\") #> <SQL> INSERT INTO students (name) VALUES ('Robert''); DROP TABLE students;--')  # Control wrapping with * x <- c(\"name\", \"age\", \"grade\") sql_glue2(con, \"SELECT {.id x} FROM students\") #> <SQL> SELECT \"name\", \"age\", \"grade\" FROM students sql_glue2(con, \"SELECT * WHERE variable IN {x*}\") #> <SQL> SELECT * WHERE variable IN ('name', 'age', 'grade')"},{"path":"https://dbplyr.tidyverse.org/dev/reference/sql_options.html","id":null,"dir":"Reference","previous_headings":"","what":"Options for generating SQL — sql_options","title":"Options for generating SQL — sql_options","text":"Options generating SQL","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/sql_options.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Options for generating SQL — sql_options","text":"","code":"sql_options(cte = FALSE, use_star = TRUE, qualify_all_columns = FALSE)"},{"path":"https://dbplyr.tidyverse.org/dev/reference/sql_options.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Options for generating SQL — sql_options","text":"cte FALSE, default, subqueries used. TRUE common table expressions used. use_star TRUE, default, * used select columns table. FALSE columns explicitly selected. qualify_all_columns FALSE, default, columns qualified table come column name appears multiple tables.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/sql_options.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Options for generating SQL — sql_options","text":"<dbplyr_sql_options> object.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/sql_options.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Options for generating SQL — sql_options","text":"","code":"library(dplyr, warn.conflicts = FALSE) lf1 <- lazy_frame(key = 1, a = 1, b = 2) lf2 <- lazy_frame(key = 1, a = 1, c = 3)  result <- left_join(lf1, lf2, by = \"key\") |>   filter(c >= 3)  show_query(result) #> <SQL> #> SELECT \"q01\".* #> FROM ( #>   SELECT #>     \"df_LHS\".\"key\" AS \"key\", #>     \"df_LHS\".\"a\" AS \"a.x\", #>     \"b\", #>     \"df_RHS\".\"a\" AS \"a.y\", #>     \"c\" #>   FROM \"df\" AS \"df_LHS\" #>   LEFT JOIN \"df\" AS \"df_RHS\" #>     ON (\"df_LHS\".\"key\" = \"df_RHS\".\"key\") #> ) AS \"q01\" #> WHERE (\"c\" >= 3.0) sql_options <- sql_options(cte = TRUE, qualify_all_columns = TRUE) show_query(result, sql_options = sql_options) #> <SQL> #> WITH \"q01\" AS ( #>   SELECT #>     \"df_LHS\".\"key\" AS \"key\", #>     \"df_LHS\".\"a\" AS \"a.x\", #>     \"df_LHS\".\"b\" AS \"b\", #>     \"df_RHS\".\"a\" AS \"a.y\", #>     \"df_RHS\".\"c\" AS \"c\" #>   FROM \"df\" AS \"df_LHS\" #>   LEFT JOIN \"df\" AS \"df_RHS\" #>     ON (\"df_LHS\".\"key\" = \"df_RHS\".\"key\") #> ) #> SELECT \"q01\".* #> FROM \"q01\" #> WHERE (\"c\" >= 3.0)"},{"path":"https://dbplyr.tidyverse.org/dev/reference/sql_query_insert.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate SQL for Insert, Update, Upsert, and Delete — sql_query_insert","title":"Generate SQL for Insert, Update, Upsert, and Delete — sql_query_insert","text":"functions generate SQL used rows_*(in_place = TRUE).","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/sql_query_insert.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate SQL for Insert, Update, Upsert, and Delete — sql_query_insert","text":"","code":"sql_query_insert(   con,   table,   from,   insert_cols,   by,   ...,   conflict = c(\"error\", \"ignore\"),   returning_cols = NULL,   method = NULL )  sql_query_append(con, table, from, insert_cols, ..., returning_cols = NULL)  sql_query_update_from(   con,   table,   from,   by,   update_values,   ...,   returning_cols = NULL )  sql_query_upsert(   con,   table,   from,   by,   update_cols,   ...,   returning_cols = NULL,   method = NULL )  sql_query_delete(con, table, from, by, ..., returning_cols = NULL)"},{"path":"https://dbplyr.tidyverse.org/dev/reference/sql_query_insert.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate SQL for Insert, Update, Upsert, and Delete — sql_query_insert","text":"con Database connection. table Table update. Must table identifier. Use string refer tables current schema/catalog () refer tables schemas/catalogs. Table query contains new data. Either table identifier SQL. insert_cols Names columns insert. unnamed character vector giving key columns. key columns must exist x y. Keys typically uniquely identify row, enforced key values y rows_update(), rows_patch(), rows_upsert() used. default, use first column y, since first column reasonable place put identifier variable. ... parameters passed onto methods. conflict rows_insert(), keys y conflict keys x handled? conflict arises key y already exists x. One : \"error\", default, error keys y conflict keys x. \"ignore\" ignore rows y keys conflict keys x. returning_cols Optional. Names columns return. method Optional. method use. update_values named SQL vector specify update columns. update_cols Names columns update.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/sql_query_insert.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate SQL for Insert, Update, Upsert, and Delete — sql_query_insert","text":"SQL query.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/sql_query_insert.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate SQL for Insert, Update, Upsert, and Delete — sql_query_insert","text":"Insert Methods Upsert Methods","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/sql_query_insert.html","id":"-where-not-exists-","dir":"Reference","previous_headings":"","what":"\"where_not_exists\"","title":"Generate SQL for Insert, Update, Upsert, and Delete — sql_query_insert","text":"default databases.","code":"INSERT INTO x_name SELECT * FROM y WHERE NOT EXISTS <match on by columns>"},{"path":"https://dbplyr.tidyverse.org/dev/reference/sql_query_insert.html","id":"-on-conflict-","dir":"Reference","previous_headings":"","what":"\"on_conflict\"","title":"Generate SQL for Insert, Update, Upsert, and Delete — sql_query_insert","text":"Supported : Postgres SQLite method uses CONFLICT clause therefore requires unique index columns specified .","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/sql_query_insert.html","id":"-merge-","dir":"Reference","previous_headings":"","what":"\"merge\"","title":"Generate SQL for Insert, Update, Upsert, and Delete — sql_query_insert","text":"upsert method according SQL standard. uses MERGE statement","code":"MERGE INTO x_name USING y   ON <match on by columns> WHEN MATCHED THEN   UPDATE SET ... WHEN NOT MATCHED THEN   INSERT ..."},{"path":"https://dbplyr.tidyverse.org/dev/reference/sql_query_insert.html","id":"-on-conflict--1","dir":"Reference","previous_headings":"","what":"\"on_conflict\"","title":"Generate SQL for Insert, Update, Upsert, and Delete — sql_query_insert","text":"Supported : Postgres SQLite method uses CONFLICT clause therefore requires unique index columns specified .","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/sql_query_insert.html","id":"-cte-update-","dir":"Reference","previous_headings":"","what":"\"cte_update\"","title":"Generate SQL for Insert, Update, Upsert, and Delete — sql_query_insert","text":"Supported : Postgres SQLite Oracle classical way upsert Postgres SQLite support CONFLICT added. update done CTE clause unmatched values inserted outside CTE.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/sql_query_insert.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate SQL for Insert, Update, Upsert, and Delete — sql_query_insert","text":"","code":"sql_query_upsert(   con = simulate_postgres(),   table = ident(\"airlines\"),   from = ident(\"df\"),   by = \"carrier\",   update_cols = \"name\" ) #> <SQL> INSERT INTO \"airlines\" (\"carrier\", \"name\") #> SELECT \"carrier\", \"name\" #> FROM \"df\" AS \"...y\" #> WHERE true #> ON CONFLICT  (\"carrier\") #> DO UPDATE #> SET \"name\" = \"excluded\".\"name\""},{"path":"https://dbplyr.tidyverse.org/dev/reference/sql_quote.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper function for quoting sql elements. — sql_quote","title":"Helper function for quoting sql elements. — sql_quote","text":"quote character present string, doubled. NAs replaced NULL.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/sql_quote.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper function for quoting sql elements. — sql_quote","text":"","code":"sql_quote(x, quote)"},{"path":"https://dbplyr.tidyverse.org/dev/reference/sql_quote.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helper function for quoting sql elements. — sql_quote","text":"x Character vector escape. quote Quote character. Either length 1 character vector symmetric quotes (e.g., \"'\" '\"'), length 2 character vector asymmetric quotes (e.g., c(\"[\", \"]\")).","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/sql_quote.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Helper function for quoting sql elements. — sql_quote","text":"","code":"sql_quote(\"abc\", \"'\") #> [1] \"'abc'\" sql_quote(\"I've had a good day\", \"'\") #> [1] \"'I''ve had a good day'\" sql_quote(c(\"abc\", NA), \"'\") #> [1] \"'abc'\" \"NULL\"   sql_quote(c(\"abc\", NA), c(\"[\", \"]\")) #> [1] \"[abc]\" \"NULL\""},{"path":"https://dbplyr.tidyverse.org/dev/reference/sql_translation_agg.html","id":null,"dir":"Reference","previous_headings":"","what":"SQL helpers for aggregate functions — sql_translation_agg","title":"SQL helpers for aggregate functions — sql_translation_agg","text":"functions help create custom aggregate SQL translations implementing new backend. typically used within sql_translator() define R aggregate functions translated SQL. sql_aggregate() creates SQL aggregate function translator functions single argument optional na.rm parameter (e.g., SUM(), AVG()). sql_aggregate_2() creates SQL aggregate function translator functions exactly two arguments (e.g., CORR(), COVAR_SAMP()). sql_aggregate_n() creates SQL aggregate function translator functions number arguments optional na.rm parameter (e.g., LEAST(), GREATEST()). sql_not_supported() creates function throws informative error function supported SQL. sql_check_na_rm() helper can use aggregate functions direct user towards setting na.rm = TRUE.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/sql_translation_agg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SQL helpers for aggregate functions — sql_translation_agg","text":"","code":"sql_aggregate(f, f_r = f)  sql_aggregate_2(f)  sql_aggregate_n(f, f_r = f)  sql_check_na_rm(na.rm)  sql_not_supported(f)"},{"path":"https://dbplyr.tidyverse.org/dev/reference/sql_translation_agg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SQL helpers for aggregate functions — sql_translation_agg","text":"f name SQL function string. f_r name R function translated string. na.rm Logical indicating whether missing values removed. SQL, missing values always removed aggregate functions, function warn na.rm TRUE.","code":""},{"path":[]},{"path":"https://dbplyr.tidyverse.org/dev/reference/sql_translation_scalar.html","id":null,"dir":"Reference","previous_headings":"","what":"SQL helpers for scalar functions — sql_translation_scalar","title":"SQL helpers for scalar functions — sql_translation_scalar","text":"functions help create custom scalar SQL translations implementing new backend. typically used within sql_translator() define R functions translated SQL. sql_infix() creates SQL infix operators like +, -, *, /. sql_prefix() creates SQL prefix functions like ABS(), SQRT(). sql_cast() creates SQL cast expressions like CAST(x type). sql_try_cast() creates SQL try_cast expressions (safe casting). sql_log() creates SQL logarithm function optional base. sql_cot() creates SQL cotangent function (1 / TAN(x)). sql_runif() creates SQL expression generating uniform random numbers.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/sql_translation_scalar.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SQL helpers for scalar functions — sql_translation_scalar","text":"","code":"sql_infix(f, pad = TRUE)  sql_prefix(f, n = NULL)  sql_cast(type)  sql_try_cast(type)  sql_log()  sql_cot()  sql_runif(rand_expr, n = n(), min = 0, max = 1)"},{"path":"https://dbplyr.tidyverse.org/dev/reference/sql_translation_scalar.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SQL helpers for scalar functions — sql_translation_scalar","text":"f name SQL function string. pad TRUE, default, pad infix operator spaces. n sql_prefix(), optional number arguments expect. signal error correct. type SQL type name string. rand_expr string giving SQL expression generates random number 0 1, e.g. \"RANDOM()\". min, max Range random values.","code":""},{"path":[]},{"path":"https://dbplyr.tidyverse.org/dev/reference/sql_translation_string.html","id":null,"dir":"Reference","previous_headings":"","what":"SQL helpers for string functions — sql_translation_string","title":"SQL helpers for string functions — sql_translation_string","text":"functions help create custom string SQL translations implementing new backend. typically used within sql_translator() define R string functions translated SQL. sql_substr() creates SQL substring function translator converts R's substr(x, start, stop) SQL's SUBSTR(x, start, length). sql_str_sub() creates SQL substring function translator handles stringr's str_sub() support negative indices. sql_paste() creates SQL paste function using CONCAT_WS() similar. sql_paste_infix() creates SQL paste function using infix operator like ||.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/sql_translation_string.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SQL helpers for string functions — sql_translation_string","text":"","code":"sql_substr(f = \"SUBSTR\")  sql_str_sub(subset_f = \"SUBSTR\", length_f = \"LENGTH\", optional_length = TRUE)  sql_paste(default_sep, f = \"CONCAT_WS\")  sql_paste_infix(default_sep, op, cast = sql_cast(\"text\"))"},{"path":"https://dbplyr.tidyverse.org/dev/reference/sql_translation_string.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SQL helpers for string functions — sql_translation_string","text":"f name SQL function string. subset_f name SQL substring function. length_f name SQL string length function. optional_length Whether length argument optional SQL substring function. default_sep default separator paste operations. op SQL operator use infix paste operations. cast function cast values strings.","code":""},{"path":[]},{"path":"https://dbplyr.tidyverse.org/dev/reference/sql_translation_window.html","id":null,"dir":"Reference","previous_headings":"","what":"SQL helpers for window functions — sql_translation_window","title":"SQL helpers for window functions — sql_translation_window","text":"functions help create custom window SQL translations implementing new backend. typically used within sql_translator() define R window functions translated SQL. win_over() makes easy generate window function specification. win_absent(), win_rank(), win_aggregate(), win_cumulative() provide helpers constructing common types window functions. win_current_group() win_current_order() allow access grouping order context set dplyr::group_by() dplyr::arrange().","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/sql_translation_window.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SQL helpers for window functions — sql_translation_window","text":"","code":"win_over(   expr,   partition = NULL,   order = NULL,   frame = NULL,   con = sql_current_con() )  win_rank(f, empty_order = FALSE)  win_aggregate(f)  win_aggregate_2(f)  win_cumulative(f)  win_absent(f)  win_current_group()  win_current_order()  win_current_frame()"},{"path":"https://dbplyr.tidyverse.org/dev/reference/sql_translation_window.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SQL helpers for window functions — sql_translation_window","text":"expr window expression. partition Variables partition . order Variables order . frame numeric vector length two defining frame. con Database connection. f name SQL function string. empty_order logical value indicating whether order NULL order specified.","code":""},{"path":[]},{"path":"https://dbplyr.tidyverse.org/dev/reference/sql_translation_window.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"SQL helpers for window functions — sql_translation_window","text":"","code":"con <- simulate_dbi()  win_over(sql(\"avg(x)\"), con = con) #> <SQL> avg(x) OVER () win_over(sql(\"avg(x)\"), \"y\", con = con) #> <SQL> avg(x) OVER (PARTITION BY \"y\") win_over(sql(\"avg(x)\"), order = \"y\", con = con) #> <SQL> avg(x) OVER (ORDER BY \"y\") win_over(sql(\"avg(x)\"), order = c(\"x\", \"y\"), con = con) #> <SQL> avg(x) OVER (ORDER BY \"x\", \"y\") win_over(sql(\"avg(x)\"), frame = c(-Inf, 0), order = \"y\", con = con) #> <SQL> avg(x) OVER (ORDER BY \"y\" ROWS UNBOUNDED PRECEDING)"},{"path":"https://dbplyr.tidyverse.org/dev/reference/sql_variant.html","id":null,"dir":"Reference","previous_headings":"","what":"Create an SQL translator — sql_variant","title":"Create an SQL translator — sql_variant","text":"sql_variant() creates SQL variant, list translators scalar, aggregate, window functions. sql_translator() creates translator, environment containing R SQL translations. creating backend, use functions customize R functions converted SQL.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/sql_variant.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create an SQL translator — sql_variant","text":"","code":"sql_variant(   scalar = sql_translator(),   aggregate = sql_translator(),   window = sql_translator() )  sql_translator(..., .funs = list(), .parent = new.env(parent = emptyenv()))  base_scalar  base_agg  base_win  base_no_win  base_odbc_scalar  base_odbc_agg  base_odbc_win"},{"path":"https://dbplyr.tidyverse.org/dev/reference/sql_variant.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create an SQL translator — sql_variant","text":"scalar, aggregate, window three families functions SQL variant can supply. ..., .funs Named functions, used add custom converters standard R functions SQL functions. Specify individually ..., provide list .funs. .parent SQL variant variant inherit . Defaults base_agg provides standard set mappings common operators functions.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/sql_variant.html","id":"base-translators","dir":"Reference","previous_headings":"","what":"Base translators","title":"Create an SQL translator — sql_variant","text":"dbplyr provides following base translators implement standard SQL semantics: base_scalar - scalar functions operators base_agg - aggregate functions base_win - window functions base_no_win - versions window functions throw errors","code":""},{"path":[]},{"path":"https://dbplyr.tidyverse.org/dev/reference/sql_variant.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create an SQL translator — sql_variant","text":"","code":"# An example of adding some mappings for the statistical functions that # postgresql provides: http://bit.ly/K5EdTn  postgres_agg <- sql_translator(.parent = base_agg,   cor = sql_aggregate_2(\"CORR\"),   cov = sql_aggregate_2(\"COVAR_SAMP\"),   sd =  sql_aggregate(\"STDDEV_SAMP\", \"sd\"),   var = sql_aggregate(\"VAR_SAMP\", \"var\") )  # Next we have to simulate a connection that uses this variant con <- simulate_dbi(\"TestCon\") sql_translation.TestCon <- function(x) {   sql_variant(     base_scalar,     postgres_agg,     base_no_win   ) }  translate_sql(cor(x, y), con = con, window = FALSE) #> Error in cor(x, y): `cor()` is not available in this SQL variant. translate_sql(sd(income / years), con = con, window = FALSE) #> Error in sd(income/years): `sd()` is not available in this SQL variant.  # Any functions not explicitly listed in the converter will be translated # to sql as is, so you don't need to convert all functions. translate_sql(regr_intercept(y, x), con = con) #> <SQL> regr_intercept(\"y\", \"x\")"},{"path":"https://dbplyr.tidyverse.org/dev/reference/src_dbi.html","id":null,"dir":"Reference","previous_headings":"","what":"Database src — src_dbi","title":"Database src — src_dbi","text":"Since can generate tbl() directly DBI connection longer recommend using src_dbi().","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/src_dbi.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Database src — src_dbi","text":"","code":"src_dbi(con, auto_disconnect = FALSE)"},{"path":"https://dbplyr.tidyverse.org/dev/reference/src_dbi.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Database src — src_dbi","text":"con object inherits DBI::DBIConnection, typically generated DBI::dbConnect auto_disconnect connection automatically closed src deleted? Set TRUE initialize connection call src_dbi(). Pass NA auto-disconnect print message happens.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/src_dbi.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Database src — src_dbi","text":"S3 object class src_dbi, src_sql, src.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/src_memdb.html","id":null,"dir":"Reference","previous_headings":"","what":"Deprecated — src_memdb","title":"Deprecated — src_memdb","text":"src_memdb() deprecated; use memdb() instead. tbl_memdb(df) deprecated; use copy_to(memdb(), df) instead.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/src_memdb.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Deprecated — src_memdb","text":"","code":"src_memdb()  tbl_memdb(df, name = deparse(substitute(df)))"},{"path":"https://dbplyr.tidyverse.org/dev/reference/src_memdb.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Deprecated — src_memdb","text":"df Data frame copy. name Name table database.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/summarise.tbl_lazy.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarise each group to one row — summarise.tbl_lazy","title":"Summarise each group to one row — summarise.tbl_lazy","text":"method dplyr dplyr::summarise() generic. generates SELECT clause SQL query, generally needs combined group_by().","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/summarise.tbl_lazy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarise each group to one row — summarise.tbl_lazy","text":"","code":"# S3 method for class 'tbl_lazy' summarise(.data, ..., .by = NULL, .groups = NULL)"},{"path":"https://dbplyr.tidyverse.org/dev/reference/summarise.tbl_lazy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarise each group to one row — summarise.tbl_lazy","text":".data lazy data frame backed database query. ... <data-masking> Variables, functions variables. Use desc() sort variable descending order. . <tidy-select> Optionally, selection columns group just operation, functioning alternative group_by(). details examples, see ?dplyr_by. .groups Grouping structure result. \"drop_last\": dropping last level grouping. supported option version 1.0.0. \"drop\": levels grouping dropped. \"keep\": grouping structure .data. .groups specified, defaults \"drop_last\". addition, message informs choice, unless result ungrouped, option \"dplyr.summarise.inform\" set FALSE, summarise() called function package.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/summarise.tbl_lazy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarise each group to one row — summarise.tbl_lazy","text":"Another tbl_lazy. Use show_query() see generated query, use collect() execute query return data R.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/summarise.tbl_lazy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summarise each group to one row — summarise.tbl_lazy","text":"","code":"library(dplyr, warn.conflicts = FALSE)  db <- memdb_frame(g = c(1, 1, 1, 2, 2), x = c(4, 3, 6, 9, 2)) db |>   summarise(n()) |>   show_query() #> <SQL> #> SELECT COUNT(*) AS `n()` #> FROM `dbplyr_tmp_gkGfyycbFy`  db |>   group_by(g) |>   summarise(n()) |>   show_query() #> <SQL> #> SELECT `g`, COUNT(*) AS `n()` #> FROM `dbplyr_tmp_gkGfyycbFy` #> GROUP BY `g`"},{"path":"https://dbplyr.tidyverse.org/dev/reference/tbl.src_dbi.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a lazy query backed by a database — tbl.src_dbi","title":"Create a lazy query backed by a database — tbl.src_dbi","text":"Use tbl() create SQL query backed database. Manipulating object dplyr verbs builds SQL query executed explicitly ask , either printing object, calling dplyr::collect() bring data back R calling dplyr::compute() create new table database. can see query without executing show_query(). Learn vignette(\"dbplyr\").","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/tbl.src_dbi.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a lazy query backed by a database — tbl.src_dbi","text":"","code":"# S3 method for class 'src_dbi' tbl(src, from, vars = NULL, ...)"},{"path":"https://dbplyr.tidyverse.org/dev/reference/tbl.src_dbi.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a lazy query backed by a database — tbl.src_dbi","text":"src DBIConnection object produced DBI::dbConnect(). Either table identifier literal sql() string. Use string identify table current schema/catalog () table elsewhere, e.g. (\"schema.table\") (\"catalog.schema.table\"). backward compatibility, can also use in_schema()/in_catalog() DBI::Id(). vars Optionally, provide character vector column names. supplied, retrieved database running simple query. argument mainly useful better performance creating many tbls known variables. ... Passed tbl_sql()","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/tbl.src_dbi.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a lazy query backed by a database — tbl.src_dbi","text":"","code":"library(dplyr)  # Connect to a temporary in-memory SQLite database and add some data con <- DBI::dbConnect(RSQLite::SQLite(), \":memory:\") copy_to(con, mtcars)  # To retrieve a single table from a source, use `tbl()` mtcars_db <- con |> tbl(\"mtcars\") mtcars_db #> # A query:  ?? x 11 #> # Database: sqlite 3.51.1 [:memory:] #>      mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb #>    <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> #>  1  21       6  160    110  3.9   2.62  16.5     0     1     4     4 #>  2  21       6  160    110  3.9   2.88  17.0     0     1     4     4 #>  3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1 #>  4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1 #>  5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2 #>  6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1 #>  7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4 #>  8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2 #>  9  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2 #> 10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4 #> # ℹ more rows  # Use `I()` for qualified table names con |> tbl(I(\"temp.mtcars\")) |> head(1) #> # A query:  ?? x 11 #> # Database: sqlite 3.51.1 [:memory:] #>     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb #>   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> #> 1    21     6   160   110   3.9  2.62  16.5     0     1     4     4  # You can also pass raw SQL if you want a more sophisticated query con |> tbl(sql(\"SELECT * FROM mtcars WHERE cyl = 8\")) |> head(1) #> # A query:  ?? x 11 #> # Database: sqlite 3.51.1 [:memory:] #>     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb #>   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> #> 1  18.7     8   360   175  3.15  3.44  17.0     0     0     3     2  # But in most cases, you'll rely on dbplyr to construct the SQL: mtcars_db |>   filter(vs == 1) |>   summarise(mpg = mean(mpg, na.rm = TRUE), .by = cyl) |>   show_query() #> <SQL> #> SELECT `cyl`, AVG(`mpg`) AS `mpg` #> FROM `mtcars` #> WHERE (`vs` = 1.0) #> GROUP BY `cyl`"},{"path":"https://dbplyr.tidyverse.org/dev/reference/tbl_lazy.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a local lazy tibble — tbl_lazy","title":"Create a local lazy tibble — tbl_lazy","text":"functions useful testing SQL generation without active database connection. See simulate_dbi() list available database simulations.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/tbl_lazy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a local lazy tibble — tbl_lazy","text":"","code":"tbl_lazy(df, con = NULL, ..., name = \"df\")  lazy_frame(..., con = NULL, .name = \"df\")"},{"path":"https://dbplyr.tidyverse.org/dev/reference/tbl_lazy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a local lazy tibble — tbl_lazy","text":"","code":"library(dplyr) df <- data.frame(x = 1, y = 2)  df_sqlite <- tbl_lazy(df, con = simulate_sqlite()) df_sqlite |> summarise(x = sd(x, na.rm = TRUE)) #> <SQL> #> SELECT STDEV(`x`) AS `x` #> FROM `df`"},{"path":"https://dbplyr.tidyverse.org/dev/reference/tbl_sql.html","id":null,"dir":"Reference","previous_headings":"","what":"Create an SQL tbl (abstract) — tbl_sql","title":"Create an SQL tbl (abstract) — tbl_sql","text":"function longer needed, since backends need create custom classes. Instead, rely default tbl.DBIConnection() method.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/tbl_sql.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create an SQL tbl (abstract) — tbl_sql","text":"","code":"tbl_sql(subclass, src, from, ..., vars = NULL, check_from = deprecated())"},{"path":"https://dbplyr.tidyverse.org/dev/reference/tbl_sql.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create an SQL tbl (abstract) — tbl_sql","text":"subclass name subclass src DBIConnection object produced DBI::dbConnect(). Either table identifier literal sql() string. Use string identify table current schema/catalog () table elsewhere, e.g. (\"schema.table\") (\"catalog.schema.table\"). backward compatibility, can also use in_schema()/in_catalog() DBI::Id(). ... needed agreement generic. otherwise used. vars Optionally, provide character vector column names. supplied, retrieved database running simple query. argument mainly useful better performance creating many tbls known variables. check_from","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/translate_sql.html","id":null,"dir":"Reference","previous_headings":"","what":"Translate an expression to SQL — translate_sql","title":"Translate an expression to SQL — translate_sql","text":"dbplyr translates commonly used base functions including logical (!, &, |), arithmetic (^), comparison (!=) operators, well common summary (mean(), var()), transformation (log()) functions.  functions preserved . R's infix functions (e.g. %like%) converted SQL equivalents (e.g. LIKE). Learn vignette(\"translation-function\").","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/translate_sql.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Translate an expression to SQL — translate_sql","text":"","code":"translate_sql(   ...,   con,   vars_group = NULL,   vars_order = NULL,   vars_frame = NULL,   window = TRUE )  translate_sql_(   dots,   con,   vars_group = NULL,   vars_order = NULL,   vars_frame = NULL,   window = TRUE,   context = list() )"},{"path":"https://dbplyr.tidyverse.org/dev/reference/translate_sql.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Translate an expression to SQL — translate_sql","text":"..., dots Expressions translate. translate_sql() automatically quotes .  translate_sql_() expects list already quoted objects. con Database connection used determine SQL dialect. vars_group, vars_order, vars_frame Parameters used expression windowed functions. window Use FALSE suppress generation statement used window functions. necessary generating SQL grouped summary. context Use carry information special translation cases. example, MS SQL needs different conversion .na() vs. SELECT clauses.  Expects list.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/translate_sql.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Translate an expression to SQL — translate_sql","text":"","code":"con <- simulate_dbi()  # Regular maths is translated in a very straightforward way translate_sql(x + 1, con = con) #> <SQL> \"x\" + 1.0 translate_sql(sin(x) + tan(y), con = con) #> <SQL> SIN(\"x\") + TAN(\"y\")  # Note that all variable names are escaped translate_sql(like == \"x\", con = con) #> <SQL> \"like\" = 'x' # In ANSI SQL: \"\" quotes variable _names_, '' quotes strings  # Logical operators are converted to their sql equivalents translate_sql(x < 5 & !(y >= 5), con = con) #> <SQL> \"x\" < 5.0 AND NOT((\"y\" >= 5.0)) # xor() doesn't have a direct SQL equivalent translate_sql(xor(x, y), con = con) #> <SQL> \"x\" OR \"y\" AND NOT (\"x\" AND \"y\")  # If is translated into case when translate_sql(if (x > 5) \"big\" else \"small\", con = con) #> <SQL> CASE WHEN (\"x\" > 5.0) THEN 'big' WHEN NOT (\"x\" > 5.0) THEN 'small' END  # Infix functions are passed onto SQL with % removed translate_sql(first %like% \"Had%\", con = con) #> <SQL> \"first\" like 'Had%' translate_sql(first %is% NA, con = con) #> <SQL> \"first\" is NULL translate_sql(first %in% c(\"John\", \"Roger\", \"Robert\"), con = con) #> <SQL> \"first\" IN ('John', 'Roger', 'Robert')  # And be careful if you really want integers translate_sql(x == 1, con = con) #> <SQL> \"x\" = 1.0 translate_sql(x == 1L, con = con) #> <SQL> \"x\" = 1  # If you have an already quoted object, use translate_sql_: x <- quote(y + 1 / sin(t)) translate_sql_(list(x), con = simulate_dbi()) #> <SQL> \"y\" + 1.0 / SIN(\"t\")  # Windowed translation -------------------------------------------- # Known window functions automatically get OVER() translate_sql(mpg > mean(mpg), con = con) #> <SQL> \"mpg\" > AVG(\"mpg\") OVER ()  # Suppress this with window = FALSE translate_sql(mpg > mean(mpg), window = FALSE, con = con) #> <SQL> \"mpg\" > AVG(\"mpg\")  # vars_group controls partition: translate_sql(mpg > mean(mpg), vars_group = \"cyl\", con = con) #> <SQL> \"mpg\" > AVG(\"mpg\") OVER (PARTITION BY \"cyl\")  # and vars_order controls ordering for those functions that need it translate_sql(cumsum(mpg), con = con) #> Warning: Windowed expression `SUM(\"mpg\")` does not have explicit order. #> ℹ Please use `arrange()`, `window_order()`, or `.order` to make #>   deterministic. #> <SQL> SUM(\"mpg\") OVER (ROWS UNBOUNDED PRECEDING) translate_sql(cumsum(mpg), vars_order = \"mpg\", con = con) #> <SQL> SUM(\"mpg\") OVER (ORDER BY \"mpg\" ROWS UNBOUNDED PRECEDING)"},{"path":"https://dbplyr.tidyverse.org/dev/reference/window_order.html","id":null,"dir":"Reference","previous_headings":"","what":"Override window order and frame — window_order","title":"Override window order and frame — window_order","text":"allow override PARTITION ORDER clauses window functions generated grouped mutates.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/window_order.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Override window order and frame — window_order","text":"","code":"window_order(.data, ...)  window_frame(.data, from = -Inf, to = Inf)"},{"path":"https://dbplyr.tidyverse.org/dev/reference/window_order.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Override window order and frame — window_order","text":".data lazy data frame backed database query. ... Variables order , Bounds frame.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/reference/window_order.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Override window order and frame — window_order","text":"","code":"library(dplyr, warn.conflicts = FALSE)  db <- memdb_frame(g = rep(1:2, each = 5), y = runif(10), z = 1:10) db |>   window_order(y) |>   mutate(z = cumsum(y)) |>   show_query() #> <SQL> #> SELECT `g`, `y`, SUM(`y`) OVER (ORDER BY `y` ROWS UNBOUNDED PRECEDING) AS `z` #> FROM `dbplyr_tmp_OwABP7gyCl`  db |>   group_by(g) |>   window_frame(-3, 0) |>   window_order(z) |>   mutate(z = sum(y)) |>   show_query() #> <SQL> #> SELECT #>   `g`, #>   `y`, #>   SUM(`y`) OVER (PARTITION BY `g` ORDER BY `z` ROWS 3 PRECEDING) AS `z` #> FROM `dbplyr_tmp_OwABP7gyCl`"},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"dbplyr-development-version","dir":"Changelog","previous_headings":"","what":"dbplyr (development version)","title":"dbplyr (development version)","text":"slice_*() now handles missing values line documentation, .e. always removed (#1599). Internal testing functions src_test(), test_frame() test_load(), test_register_src() test_register_con() removed. filter() followed summarise() inlined correctly (#1707). src_memdb() tbl_memdb() deprecated; use memdb() copy_to(memdb(), df) instead. New local_memdb_frame() use tests. arrange() now applies consecutively, matching dplyr’s behavior: arrange(y) |> arrange(x) now equivalent arrange(x, y). Empty arrange() now preserves existing ordering instead clearing (#789). distinct() computed columns now ignores grouping, matching dplyr’s behavior (#1081). sql_escape_string() now defaults using '. simulate_*() now uses (approximately) correct quoting backends, generated SQL looks like ’ll actually get connected real database (#1464). sql_infix() longer con argument since connection needs determined call time, definition time. mutate() gains .order .frame arguments specifying window function ordering frame bounds within single mutate call, similar .works grouping (#1542). copy argument join, set, row operations now accepts \"inline\" use copy_inline() instead copying temporary table (#863). .sql() now deprecated part major internal refactoring sql() ident() used. expand() now errors column expressions don’t reference columns data, instead generating invalid SQL (#720). CTEs now correctly quote table names query used multiple times (#1559). New last_sql() retrieves recent SQL query generated dbplyr, useful debugging (#1471). Custom translations functions starting . work (@MichaelChirico, #1529). SQL Server 2025 (version 17.0) now supports stringr regex functions: str_detect(), str_starts(), str_ends(), str_replace(), str_replace_all(), str_remove(), str_remove_all(), str_extract(), str_count(). Fixed pattern versions str_detect(), str_starts(), str_ends() work SQL Server versions (#1671). MS Access now correctly generates SQL multiple joins adding required parentheses (#1576). .data$col, .data[[col]], .env$var, .env$[[var]] now work correctly inside across() (#1520). New .sql pronoun makes little easier use known SQL functions packages, requiring @importFrom dbplyr .sql (#1117). join_by(()) now correctly handles column renames (#1572). SQL Server uses DATEDIFF_BIG instead DATEDIFF work regardless data size (@edward-burn, #1666). na_matches = \"na\" now works correctly inequality overlap joins, preserving comparison operator instead converting equality (#1505). copy_inline() now works blob columns (#1515). tbl_sql() now (soft) deprecated. hasn’t required . print method longer mentions “source” header, ’s outdated dplyr concept (#897). New sql_glue() sql_glue2() provide convenient syntax building SQL strings. functions replace now superseded build_sql(), sql_expr(), sql_call2(). (#1249). fill() now errors attempt rename column, consistency dplyr (#1536) Redshift: fixed syntax error date_build() translation (#1512). dbplyr now longer attempts translate pi PI(). caused problems column called pi (#1531). Ensure str_like() str_ilike() consistent behaviour SQL Server (@edward-burn, #1669). SQL Server: /ifelse(), if_else() now use CASE instead IIF. ensures handling NULLs matches R’s NA handling rules (#1569). if_else() uses simpler translation missing (#1573). New translations stringr function str_ilike() Postgres, Redshift, Snowflake, Spark (@edward-burn, #1628). Argument ignore_case str_like() deprecated (@edward-burn, #1630). Corrected error message quantile() median() mutate() Redshift (@edward-burn, #1571). set operations now error pass extra arguments (instead silently ignoring ) (#1585). str_flatten() (#1540) n_distinct() (#1579) now na.rm argument, regularly warns ’s TRUE. semi_join() anti_join() work filtered windowed values (#1534, #1606). window_order() works dplyr::desc() (just desc()) (#1486). sql_check_na_rm() now exported use backends (#1483). sql_glue2() now exported building SQL strings glue syntax type markers. build_sql() deprecated favor sql_glue2() (#1249). dbplyr 1e interfaces now deprecated (#1197). Backend developers >2 years update. MySQL gains slightly better translation .integer() .integer64() (#1647). Fixed snowflake translations reported unknown (@edward-burn, #1570). Deprecated win_rank_tdata() removed. compute(), collect(), collapse() now documentation pages. dbplyr now uses base pipe (#1626). src_sql() deprecated 1.4.0 (2019-04-23) partial_eval(var) deprecated 2.2.0 (2022-06-05). group_by(add = ) deprecated dplyr 1.1.0 (2020-06-01). show_query() gains use_colour argument (#1590). SQL server: slice_sample() returns different results run (@thomashulst, #1503) Corrected translation stringr::str_like() use case-sensitive LIKE argument ignore_case set FALSE (@edward-burn, #1488). Corrected translation stringr::str_like() use case-sensitive LIKE argument ignore_case set FALSE (@edward-burn, #1488). Fixed overwrite flag copy_to() work source DB destination (@liudvikasakelis, #1535) Snowflake correctly translates $ : (@jsowder, #1608) dbplyr_uncount() now works Redshift (@owenjonesuob, #1601).","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"dbplyr-251","dir":"Changelog","previous_headings":"","what":"dbplyr 2.5.1","title":"dbplyr 2.5.1","text":"CRAN release: 2025-09-10 Improved translations: SQL Server, Redshift, Snowflake, Postgres now correctly translate difftime() (sign now correct) (@edward-burn, #1532). SQL server, Redshift, Snowflake, Postgres, Spark now translate date_count_between() (@edward-burn, #1495). SQL Server now supports pmin() pmax() (@edward-burn, #1602). SQL server uses COUNT_BIG instead COUNT tally() count() work regardless data size (@edward-burn, #1498). Spark correctly translates clock::add_years() (@ablack3, #1510). Teradata now supports .double() .character() (@rplsmn, #1545). Tightened argument checks SQL translations. changes result informative errors cases code already failed, possibly silently; see errors code used run correctly, please report package authors (@simonpcouch, #1554, #1555). across(everything()) doesn’t select grouping columns created via .summarise() (@mgirlich, #1493). Spark SQL backend now supports persisting tables compute(x, name = (\"x.y.z\"), temporary = FALSE) (@zacdav-db, #1502).","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"dbplyr-250","dir":"Changelog","previous_headings":"","what":"dbplyr 2.5.0","title":"dbplyr 2.5.0","text":"CRAN release: 2024-03-19","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"improved-tools-for-qualified-table-names-2-5-0","dir":"Changelog","previous_headings":"","what":"Improved tools for qualified table names","title":"dbplyr 2.5.0","text":"Specification table names schema/catalogs overhauled make simpler. includes following features fixes: simplest way refer qualified table now wrap (), e.g. (\"schema_name.table_name\"). Use sql() ident_q() inside in_catalog() in_schema() supported (#1388). ’s ok use ident_q() (#1413) longer see unsuppressable warnings using in_schema() (#1408). names arguments Id() longer matter, order (#1416). Additionally, thanks changes DBI package, longer need name argument. accidentally pass named vector database identifier functions, names automatically stripped (#1404). tbl_sql(check_from) now deprecated. dbplyr now exports tools work internal table_path class useful certain backends need work data structure (#1300).","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"improved-sql-2-5-0","dir":"Changelog","previous_headings":"","what":"Improved SQL","title":"dbplyr 2.5.0","text":"New translations clock functions add_years(), add_days(), date_build(), get_year(), get_month(), get_day(), base::difftime() SQL server, Redshift, Snowflake, Postgres. select() keep computed columns used arrange() subqueries eliminated subsequent select (@ejneer, #1437). semi_join() longer inline away aggregate filter (.e. clause) followed select() (@ejneer, #1474) Improved function translations: Functions qualified base namespace now also translated, e.g. base::paste0(x, \"_1\") now translated (@mgirlich, #1022). -1 + x now generates translation instead erroring (#1420). x$name never attempts evaluate name (#1368). can use NULL LHS infix operator order generate SQL unusual syntax (#1345). Namespaced calls now error function doesn’t exist, translation available (#1426). lead() translation coerces n integer. Databricks: now supports creating non-temporary tables (#1418). Oracle: db_explain() now works (@thomashulst, #1353). .Date() works applied string (#1389). head() translated FETCH FIRST. require Oracle 12c newer, actually works, compared approach using ROWNUM #1292 (#1436). Added support str_replace() str_replace_all() via REGEXP_REPLACE() (@thomashulst, #1402). Snowflake (@nathanhaigh, #1406) Added support str_starts() str_ends() via REGEXP_INSTR() Refactored str_detect() use REGEXP_INSTR() now supports regular expressions. Refactored grepl() use REGEXP_INSTR() now supports case-insensitive matching grepl(..., ignore.case = TRUE) SQL server: Now products clear error attempt use n_distinct() mutate() filter() (#1366). filter() better job converting logical vectors bit boolean (@ejneer, #1288). MySQL: .integer() gets correct translation (@krlmlr, #1375).","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"minor-improvements-and-bug-fixes-2-5-0","dir":"Changelog","previous_headings":"","what":"Minor improvements and bug fixes","title":"dbplyr 2.5.0","text":"Deprecation status functions deprecated previous versions (least 2 years old) advanced. particular, src_sql() now defunct, use partial_eval() character data. Database errors now show generated SQL, hopefully make faster track problems (#1401). dbplyr creates index table schema (e.g. schema.table), now includes table name index name, schema name. class remote sources now includes S4 class names, just first (#918). compute() passes additional arguments way sql_query_save()-methods (@rsund). db_sql_render() correctly passes ... re-calling sql_options set (#1394). reframe() now gives informative error isn’t supported (#1148). rows_patch(in_place = FALSE) now works one column patched (@gorcha, #1443). New simulate_mariadb() (@krlmlr, #1375). sql_translator() now checks duplicated definitions (@krlmlr, #1374).","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"dbplyr-240","dir":"Changelog","previous_headings":"","what":"dbplyr 2.4.0","title":"dbplyr 2.4.0","text":"CRAN release: 2023-10-26","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"breaking-changes-2-4-0","dir":"Changelog","previous_headings":"","what":"Breaking changes","title":"dbplyr 2.4.0","text":"Using compute(temporary = FALSE) without providing name now deprecated (@mgirlich, #1154). ntile()’s first argument renamed order_by x match interface dplyr::ntile() (@mgirlich, #1242). simulate_vars() simulate_vars_is_typed() removed weren’t used tidyselect now offers tidyselect_data_proxy() tidyselect_data_has_predicates() (@mgirllich, #1199). sql_not_supported() now expects function name without parentheses. sql_query_append(), sql_query_insert(), sql_query_update(), sql_query_upsert(), sql_query_delete() changed arguments make consistent sql_query_*() functions: x_name renamed table. y renamed must now table identifier SQL instead lazy table. sql_query_append() sql_query_insert() gained argument cols. remote_name() now returns string name table. get qualified identifier use newly added remote_table() (@mgirlich, #1280). tbl_lazy() loses src argument deprecated years (@mgirlich, #1208). translate_sql() now requires con argument (@mgirlich, #1311). vars argument removed threw error last 7 years (@mgirlich).","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"improved-sql-2-4-0","dir":"Changelog","previous_headings":"","what":"Improved SQL","title":"dbplyr 2.4.0","text":"Preliminary databricks Spark SQL backend (#1377). Joins *_join() full_join() works (@mgirlich, #1178). *_join() now allows specifying relationship argument. must NULL \"many--many\" (@bairdj, #1305). Queries now qualify * table alias better compatibility (@mgirlich, #1003). full_join() can now handle column names differ case (@ejneer, #1255). na_matches argument semi_join() anti_join() works (@mgirlich, #1211). semi/anti_join() filtered y inlined possible (@mgirlich, #884). Joins now work Pool Oracle connections (@mgirlich, #1177, #1181). sequence union() resp. union_all() now produces flat query instead subqueries (@mgirlich, #1269). Added translations : nzchar() (@MichaelChirico, @mgirlich, #1094). str_detect(), str_starts() str_ends() fixed patterns (@mgirlich, #1009). runif() (@mgirlich, #1200). if_any() if_all() translations now wrapped parentheses. makes sure can combined via & conditions (@mgirlich, #1153). nth(), first(), last() now support na_rm argument (@mgirlich, #1193).","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"minor-improvements-and-bug-fixes-2-4-0","dir":"Changelog","previous_headings":"","what":"Minor improvements and bug fixes","title":"dbplyr 2.4.0","text":"across() now supports namespaced functions, e.g.  across(x, dplyr::dense_rank) (@mgirlich, #1231). db_copy_to(overwrite = TRUE) now actually works. db_copy_to()’s ... now passed db_write_table() (@mgirlich, #1237). Added db_supports_table_alias_with_as() customise whether backend supports specifying table alias (@mgirlich). db_write_table() db_save_query() gain overwrite argument. dbplyr_pivot_wider_spec() now exported. Unlike pivot_wider() can lazy. Note removed soon pivot_wider_spec() becomes generic (@mgirlich). filter()ing window functions now generates columns called col01 rather q01 (@mgirlich, #1258). pivot_wider() now matches tidyr NA column handling (@ejneer #1238). select() can used arrange(desc(x)) (@ejneer, #1240). show_query() remote_query() gain argument sql_options allows control SQL generated. can created via sql_options() following arguments: cte: use common table expressions? use_star: use SELECT * explicitly select every column? qualify_all_columns: qualify columns join ambiguous ones? (@mgirlich, #1146). Consequently cte argument show_query() remote_query() deprecated (@mgirlich, #1146). slice_min/max() can now order multiple variables like dplyr, e.g. use slice_min(lf, tibble(x, y)) (@mgirlich, #1167). slice_*() now supports data masking pronouns .env .data (@mgirlich, #1294). sql_join_suffix() gains argument suffix methods can check whether suffix valid backend (@mgirlich). sql_random() now deprecated. used power slice_sample() now done via translation runif() (@mgirlich, #1200). tbl() now informs user probably forgot wrap table identifier in_schema() sql() (@mgirlich, #1287).","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"backend-specific-improvements-2-4-0","dir":"Changelog","previous_headings":"","what":"Backend specific improvements","title":"dbplyr 2.4.0","text":"Added translation != <> (@erikvona, #1219). now supports returning argument rows_*(). rows_update() rows_patch() now give informative error unsupported returning argument used (@mgirlich, #1279). rows_upsert() now gives informative error isn’t supported (@mgirlich, #1279). rows_*() use column types x auto copying y (@mgirlich, #1327). copy_inline() now works (@mgirlich, #1188). Fix translation .numeric(), .POSIXct(), as_datetime(), .integer64() (@avsdev-cw, #1189). row_number() now works order specified (@ejneer, @fh-mthomson, #1332) Fix translation rows_upsert() (@mgirlich, @TBlackmore, #1286) head(n) now translated ROWNUM <= n also support old versions <= 11.2 (@JeremyPasco, #1292). rows_*() functions now also work inside transaction (@mgirlich, #1183). Subqueries now also get alias. makes consistent backends simplifies implementation. distinct(.keep_all = TRUE) now works (@mgirlich, #1053). translation () now also works used mutate() (@mgirlich, #1241). () () now work (@ejneer, #1273). Fixed negation bit (boolean) fields (@ejneer, #1239) na.rm = TRUE now respected pmin() pmax() instead silently ignored (@fh-mthomson, #1329) row_number() now works order specified (@fh-mthomson, #1332) distinct() + head() now work (@mgirlich, #685). .Date(x) now translate CAST(x DATE) unless x string (@mgirlich, #1285). row_number() longer defaults partitioning groups (now aligned databases order specified: ROW_NUMBER() defaults ORDER (SELECT NULL)) (@fh-mthomson, #1331)","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"dbplyr-234","dir":"Changelog","previous_headings":"","what":"dbplyr 2.3.4","title":"dbplyr 2.3.4","text":"CRAN release: 2023-09-26 Hot patch release resolve R CMD check failures.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"dbplyr-233","dir":"Changelog","previous_headings":"","what":"dbplyr 2.3.3","title":"dbplyr 2.3.3","text":"CRAN release: 2023-07-07 Hot patch fix R CMD check issues","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"dbplyr-232","dir":"Changelog","previous_headings":"","what":"dbplyr 2.3.2","title":"dbplyr 2.3.2","text":"CRAN release: 2023-03-21 Hot patch fix R CMD check issues","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"dbplyr-231","dir":"Changelog","previous_headings":"","what":"dbplyr 2.3.1","title":"dbplyr 2.3.1","text":"CRAN release: 2023-02-24","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"breaking-changes-2-3-1","dir":"Changelog","previous_headings":"","what":"Breaking changes","title":"dbplyr 2.3.1","text":"window_order() now accepts bare symbols symbols wrapped desc(). breaking change necessary allow select() drop rename variables used window_order() (@mgirlich, #1103).","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"improved-error-messages-2-3-1","dir":"Changelog","previous_headings":"","what":"Improved error messages","title":"dbplyr 2.3.1","text":"quantile() median() now error SQL Server used summarise() PostgreSQL used mutate() can’t properly translated (@mgirlich, #1110). Added informative error unsupported join arguments unmatched multiple (@mgirlich). Using predicates, e.g. (.integer), across() now produces error never worked anyway (@mgirlich, #1169). Catch unsupported argument pivot_wider(id_expand = TRUE) pivot_longer(cols_vary) (@mgirlich, #1109).","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"bug-fixes-in-sql-generation-2-3-1","dir":"Changelog","previous_headings":"","what":"Bug fixes in SQL generation","title":"dbplyr 2.3.1","text":"Fixed issue using window function summarise() select() (@mgirlich, #1104). Fixed issue least 3 joins renamed variables (@mgirlich, #1101). mutate() select() distinct() now produce subquery generate correct translation (@mgirlich, #1119, #1141). Fixed issue using filter() summarised variable (@mgirlich, #1128). mutate() + filter() now produces new query mutate() uses window function SQL (@mgirlich, #1135). across() pick() can used () distinct() (@mgirlich, #1125). rows_*() function work tables schema PostgreSQL (@mgirlich, #1133).","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"minor-improvements-and-bug-fixes-2-3-1","dir":"Changelog","previous_headings":"","what":"Minor improvements and bug fixes","title":"dbplyr 2.3.1","text":"sql() now evaluates arguments locally also used across() (@mgirlich, #1039). rank functions (row_number(), min_rank(), rank(), dense_rank(), percent_rank(), cume_dist()) now support multiple variables wrapping tibble(), e.g. rank(tibble(x, y)) (@mgirlich, #1118). pull() now supports argument name (@mgirlich, #1136). Added support join_by() added dplyr 1.1.0 (@mgirlich, #1074). Using = character() perform cross join now soft-deprecated favor cross_join(). full_join() right_join() now translated directly FULL JOIN RIGHT JOIN SQLite native support finally added (@mgirlich, #1150). case_match() now works strings left hand side (@mgirlich, #1143). rank functions (row_number(), min_rank(), rank(), dense_rank(), percent_rank(), cume_dist()) now work variables wrapped desc(), e.g. row_number(desc(x)) (@mgirlich, #1118). Moved argument auto_index ... *_join() (@mgirlich, #1115). Removed dependency assertthat (@mgirlich, #1112). across() now uses original value column overridden match behaviour dplyr. example mutate(df, across(c(x, y), ~ .x / x)) now produces instead (@mgirlich, #1015). Restricted length table aliases avoid truncation certain backends (e.g., Postgres) (@fh-mthomson, #1096)","code":"SELECT `x` / `x` AS `x`, `y` / `x` AS `y` FROM `df` SELECT `x`, `y` / `x` AS `y` FROM (   SELECT `x` / `x` AS `x`, `y`   FROM `df` )"},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"dbplyr-230","dir":"Changelog","previous_headings":"","what":"dbplyr 2.3.0","title":"dbplyr 2.3.0","text":"CRAN release: 2023-01-16 Compatibility purrr 1.0.0 (@mgirlich, #1085).","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"new-features-2-3-0","dir":"Changelog","previous_headings":"","what":"New features","title":"dbplyr 2.3.0","text":"stringr::str_like() (new 1.5.0) translated closest LIKE equivalent (@rjpat, #509) preparation dplyr 1.1.0: .argument supported (@mgirlich, #1051). Passing ... across() deprecated evaluation timing ... ambiguous. Now instead (e.g.) across(:b, mean, na.rm = TRUE) use across(:b, \\(x) mean(x, na.rm = TRUE) pick() translated (@mgirlich, #1044). case_match() translated (@mgirlich, #1020). case_when() now supports .default argument (@mgirlich, #1017). Variables aren’t found either data environment now produce error (@mgirlich, #907).","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"sql-optimisation-2-3-0","dir":"Changelog","previous_headings":"","what":"SQL optimisation","title":"dbplyr 2.3.0","text":"dbplyr now produces fewer subqueries resulting shorter, readable, , cases, faster SQL. following combination verbs now avoids subquery possible: *_join() + select() (@mgirlich, #876). select() + *_join() (@mgirlich, #875). mutate() + filter() filter() + filter() (@mgirlich, #792). distinct() (@mgirlich, #880). summarise() + filter() now translates (@mgirlich, #877). left/inner_join() + left/inner_join() (@mgirlich, #865). dbplyr now uses SELECT * join instead explicitly selecting every column, possible (@mgirlich, #898). Joins use table aliases (“LHS” “RHS”) necessary (@mgirlich). using common table expressions, results joins set operations now reused (@mgirlich, #978).","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"improved-error-messages-2-3-0","dir":"Changelog","previous_headings":"","what":"Improved error messages","title":"dbplyr 2.3.0","text":"Many errors improved now show function error happened instead helper function (@mgirlich, #907). Errors produced database, e.g. collect() rows_*(), now show verb error happened (@mgirlich). window_order() now produces better error message applied data frame (@mgirlich, #947). Using named across() now gives clear error message (@mgirlich, #761).","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"minor-improvements-and-bug-fixes-2-3-0","dir":"Changelog","previous_headings":"","what":"Minor improvements and bug fixes","title":"dbplyr 2.3.0","text":"Keyword highlighting can now customised via option dbplyr_highlight. Turn via options(dbplyr_highlight = FALSE) pass custom ansi style, e.g. options(dbplyr_highlight = cli::combine_ansi_styles(\"bold\", \"cyan\")) (@mgirlich, #974). rank functions (row_number(), min_rank(), rank(), dense_rank(), percent_rank(), cume_dist()) now give missing values rank NA match behaviour dplyr (@mgirlich, #991). NAs blob()s correctly translated NULL (#983). copy_inline() gains types argument specify SQL column types (@mgirlich, #963). cur_column() now supported (@mgirlich, #951). distinct() returns columns ordered way request, input data (@mgirlich). fill() can now fill “downup” “updown” (@mgirlich, #1057), now order non-numeric columns also direction (@mgirlich, #1057). filter() now works using window function external vector (#1048). group_by() + renamed columns works (@mgirlich, #928). last() correctly translated window frame specified (@mgirlich, #1063). setOldClass() uses namespace, fixing installation issue (@mgirlich, #927). sql() now translated differently. ... now evaluated locally instead translated translate_sql() (@mgirlich, #952).","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"backend-specific-improvements-2-3-0","dir":"Changelog","previous_headings":"","what":"Backend specific improvements","title":"dbplyr 2.3.0","text":"HANA: Correctly translates .character() (#1027). copy_inline() now works Hana (#950) MySQL: str_flatten() uses collapse = \"\" default (@fh-afrachioni, #993) Oracle: slice_sample() now works Oracle (@mgirlich, #986). copy_inline() now works Oracle (#972) PostgreSQL: Generates correct literals Dates (#727). str_flatten() uses collapse = \"\" default (@fh-afrachioni, #993) rows_*() use column types x auto copying (@mgirlich, #909). Redshift: round() now respects digits argument (@owenjonesuob, #1033). longer tries use named windows anymore (@owenjonesuob, #1035). copy_inline() now works Redshift (#949, thanks @ejneer initial implementation). str_flatten() uses collapse = \"\" default (@fh-afrachioni, #993) Snowflake: numeric functions: (), (), log10(), round(), cor(), cov() sd(). date functions: day(), mday(), wday(), yday(), week(), isoweek(), month(), quarter(), isoyear(), seconds(), minutes(), hours(), days(), weeks(), months(), years() floor_date(). string functions: grepl(), paste(), paste0(), str_c(), str_locate(), str_detect(), str_replace(), str_replace_all(), str_remove(), str_remove_all(), str_trim(), str_squish() str_flatten() (@fh-afrachioni, #860). str_flatten() uses collapse = \"\" default (@fh-afrachioni, #993) SQLite: quantile() gives better error saying supported (@mgirlich, #1000). SQL server: .POSIXct() now translated correctly (@krlmlr, #1011). median() now translated correctly (#1008). pivot_wider() works MS SQL (@mgirlich, #929). Always use 1 0 literals logicals (@krlmlr, #934). Teradata: Querying works . Unfortunately, fix requires every column explicitly selected (@mgirlich, #966). New translations .Date(), week(), quarter(), paste(), startsWith(), row_number(), weighted.mean(), lead(), lag(), cumsum() (@overmar, #913).","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"dbplyr-221","dir":"Changelog","previous_headings":"","what":"dbplyr 2.2.1","title":"dbplyr 2.2.1","text":"CRAN release: 2022-06-27 Querying Oracle databases works . Unfortunately, fix requires every column explicitly selected (@mgirlich, #908). semi_join() anti_join() work Spark (@mgirlich, #915). str_c() now translated || Oracle (@mgirlich, #921). sd(), var(), cor() cov() now give clear error messages databases don’t support . () () gain default translations backends.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"dbplyr-220","dir":"Changelog","previous_headings":"","what":"dbplyr 2.2.0","title":"dbplyr 2.2.0","text":"CRAN release: 2022-06-05","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"new-features-2-2-0","dir":"Changelog","previous_headings":"","what":"New features","title":"dbplyr 2.2.0","text":"SQL formatting considerably improved new wrapping indenting. show_query() creates readable queries printing keywords blue (@mgirlich, #644). possible dbplyr now uses SELECT * instead explicitly selecting every column (@mgirlich). Added support rows_insert(), rows_append(), rows_update(), rows_patch(), rows_upsert(), rows_delete() (@mgirlich, #736). Added copy_inline() copy_to() equivalent need write access (@mgirlich, #628). remote_query(), show_query(), compute() collect() experimental cte argument. TRUE SQL query use common table expressions instead nested queries (@mgirlich, #638). New in_catalog(), works like in_schema(), allows creation table identifiers consisting three components: catalog, schema, name (#806, @krlmlr).","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"improvements-to-sql-generation-2-2-0","dir":"Changelog","previous_headings":"","what":"Improvements to SQL generation","title":"dbplyr 2.2.0","text":"possible, dbplyr now uses SELECT * instead explicitly selecting every column (@mgirlich). New translation cut() (@mgirlich, #697). Improved translations specific backends: .Date() Oracle (@mgirlich, #661). case_when() final clause form TRUE ~ ... uses ELSE ... SQLite (@mgirlich, #754). day(), week(), isoweek(), isoyear() Postgres (@mgirlich, #675). explain() ROracle (@mgirlich). fill() SQL Server (#651, @mgirlich) RPostgreSQL (@mgirlich). quantile() SQL Server (@mgirlich, #620). str_flatten() Redshift (@hdplsa, #804) slice_sample() MySQL/MariaDB SQL Server (@mgirlich, #617). union() Hive (@mgirlich, #663). backend function dbplyr_fill0() (used databases lack IGNORE NULLS support) now respects database specific translations (@rsund, #753). Calls form stringr::foo() lubridate::foo() now evaluated database, rather locally (#197). Unary plus (e.g. db %>% filter(x == +1)) now works (@mgirlich, #674). .na(), ifelse(), if_else(), case_when(), () generate slightly compact SQL (@mgirlich, #738). if_else() now supports missing argument (@mgirlich, #641). n() now respects window frame (@mgirlich, #700). quantile() longer errors using na.rm argument (@mgirlich, #600). remote_name() now returns name cases makes sense (@mgirlich, #850). partial evaluation code now aligned dtplyr. makes easier transfer bug fixes new features one package . process second argument partial_eval() changed lazy frame instead character vector variables (@mgirlich, #766). Partially evaluated expressions infix operations now correctly translated. example translate_sql(!!expr(2 - 1) * x) now works (@mgirlich, #634).","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"minor-improvements-and-bug-fixes-2-2-0","dir":"Changelog","previous_headings":"","what":"Minor improvements and bug fixes","title":"dbplyr 2.2.0","text":"New pillar::tbl_format_header() method lazy tables: Printing lazy table rows displayed also shows exact number rows header. threshold controlled getOption(\"pillar.print_min\"), default 10 (#796, @krlmlr). 1st edition extension mechanism formally deprecated (#507). across(), if_any() if_all() now defaults .cols = everything() (@mgirlich, #760). .fns provided if_any() if_all() work like parallel version ()/() (@mgirlich, #734). across(), if_any(), if_all() can now translate evaluated lists functions (@mgirlich, #796), accept name list functions (@mgirlich, #817). Multiple across() calls mutate() transmute() can now access freshly created variables (@mgirlich, #802). add_count() now doesn’t change groups input (@mgirlich, #614). compute() can now handle name named unnaming first (@mgirlich, #623), now works temporary = TRUE Oracle (@mgirlich, #621). distinct() now supports .keep_all = TRUE (@mgirlich, #756). expand() now works DuckDB (@mgirlich, #712). explain() passes ... methods (@mgirlich, #783), works Redshift (@mgirlich, #740). filter() throws error supply named argument (@mgirlich, #764). Joins disambiguates columns differ case (@mgirlich, #702). New arguments x_as y_as allow control table alias used SQL query (@mgirlich, #637). Joins na_matches = \"na\" now work DuckDB (@mgirlich, #704). mutate() transmute() use named windows window definition used least twice backend supports named windows (@mgirlich, #624). mutate() now supports arguments .keep, ., .(@mgirlich, #802). na.rm = FALSE warns every 8 hours across functions (#899). nesting() now supports .name_repair argument (@mgirlich, #654). pivot_longer() can now pivot column named name (@mgirlich, #692), can repair names (@mgirlich, #694), can work multiple names_from columns (@mgirlich, #693). pivot_wider(values_fn = ) pivot_longer(values_transform = ) can now formulas (@mgirlich, #745). pivot_wider() now supports arguments names_vary, names_expand, unused_fn (@mgirlich, #774). remote_name() now returns name cases makes sense (@mgirlich, #850). sql_random() now exported. ungroup() removes variables ... grouping (@mgirlich, #689). transmute() now keeps grouping variables (@mgirlich, #802).","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"dbplyr-211","dir":"Changelog","previous_headings":"","what":"dbplyr 2.1.1","title":"dbplyr 2.1.1","text":"CRAN release: 2021-04-06 New support Snowflake (@edgararuiz) compute(), sql_table_index(), sql_query_wrap() now work schemas (@mgirlich, #595). if_any() if_all() now translated. group_by() now ungroups dots argument empty .add FALSE (@mgirlich, #615). sql_escape_date() sql_escape_datetime gain methods MS Access (@erikvona, #608).","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"dbplyr-210","dir":"Changelog","previous_headings":"","what":"dbplyr 2.1.0","title":"dbplyr 2.1.0","text":"CRAN release: 2021-02-03","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"new-features-2-1-0","dir":"Changelog","previous_headings":"","what":"New features","title":"dbplyr 2.1.0","text":"Thanks @mgirlich, dbplyr gains support key verbs tidyr: pivot_longer() (#532), pivot_wider() (#543), expand() (#538), complete() (#538), replace_na() (#538), fill() (#566). @mgirlich now dbplyr author recognition significant sustained contributions. across() implementation rewritten support inputs: now translates formulas (#525), works SQL functions don’t R translations (#534), work NULL (#554) summarise() now supports argument .groups (@mgirlich, #584).","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"sql-translation-2-1-0","dir":"Changelog","previous_headings":"","what":"SQL translation","title":"dbplyr 2.1.0","text":"backends: str_sub(), substr() substring() get better translations (#577). importantly, results using negative locations match underlying R implementations closely. MS SQL: .integer() .integer64() translations cast first NUMERIC avoid CASTing weirdness (@DavidPatShuiFong, #496). Assumes boolean context inside [ (#546) str_sub() end = -1 now works (#577). Redshift: lag() lead() lose default parameter since ’s supported (@hdplsa, #548). SQLite: custom translation full_join() right_join() (@mgirlich, #536).","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"minor-improvements-and-bug-fixes-2-1-0","dir":"Changelog","previous_headings":"","what":"Minor improvements and bug fixes","title":"dbplyr 2.1.0","text":"RPostgreSQL backend warns temporary = TRUE since temporary tables supported RPostgreSQL::dbWriteTable() (#574). count() method provides closer match dplyr semantics (#347). distinct() now respects grouping (@mgirlich, #535). db_connection_describe() longer uses partial matching (@mgirlich, #564). pull() longer select()s result ’s already one variable (#562). select() longer relocates grouping variables front (@mgirlich, #568). informs adding missing grouping variables (@mgirlich, #559). tbl.src_dbi(...) now passed tbl_sql() (#530).","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"dbplyr-200","dir":"Changelog","previous_headings":"","what":"dbplyr 2.0.0","title":"dbplyr 2.0.0","text":"CRAN release: 2020-11-03","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"dplyr-compatibility-2-0-0","dir":"Changelog","previous_headings":"","what":"dplyr 1.0.0 compatibility","title":"dbplyr 2.0.0","text":"across() now translated individual SQL statements (#480). rename() select() support dplyr 1.0.0 tidyselect syntax (apart predicate functions can’t easily work computed queries) (#502). relocate() makes easy move columns (#494) rename_with() makes easy rename columns programmatically (#502). slice_min(), slice_max(), slice_order() now supported. slice_head() slice_tail() throw clear error messages (#394)","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"sql-generation-2-0-0","dir":"Changelog","previous_headings":"","what":"SQL generation","title":"dbplyr 2.0.0","text":"Documentation radically improved new topics major verb backend giving details SQL translation. intersect(), union() setdiff() gain argument add argument (#414). Join functions gains na_matches argument allows control whether NA (NULL) values match NA values. default \"never\", usual behaviour databases. can set na_matches = \"na\" match R’s usual join behaviour (#180). Additional arguments error (instead silently swallowed) (#382). Joins now use aliases needed disambiguate columns; make generated queries readable. Subqueries longer include ORDER clause. part SQL spec, limited support across databases. Now queries generate warning suggesting move arrange() call later pipeline (#276). (’s one exception: ORDER still generated LIMIT present; tends affect returns rows necessarily order). Subquery names now scoped within query. makes query text deterministic helps query optimisers/cachers (#336). sql_optimise() now can partially optimise pipeline; due unfortunate bug previously gave easily. in_schema() quotes input individually (#287) (use sql() opt quoting, needed). DBI::Id() work anywhere in_schema() .","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"sql-translation-2-0-0","dir":"Changelog","previous_headings":"","what":"SQL translation","title":"dbplyr 2.0.0","text":"Experimental new SAP HANA backend (#233). Requires latest version odbc. backends: can now use :: translations, (e.g.) dbplyr::n() translated count(*) (#207). [[ can now also translate numeric indices (#520). %/% now generates clear error message; previously translated / correct (#108). n() translated count(*) instead count() (#343). sub_str() translation consistent edge cases (@ianmcook). median() (@lorenzwalthert, #483), pmin(), pmax() (#479), sd() var() functions na.rm argument warns TRUE. makes consistent mean() sum(). substring() now translated way substr() (#378). blob vectors can now used !! !!! operators, example filter() (@okhoma, #433) MySQL uses standard SQL index creation. MS SQL translation better distinguishing bit boolean (#377, #318). ifelse generate IIF, creating simpler expressions. .*() function uses TRY_CAST() instead CAST() version 11+ (2012+) (@DavidPatShuiFong, #380). odbc longer translates count(); accidental inclusion. Oracle translation now depends Oracle 12c, uses “row-limiting” clause head(). gains translations today() now(), improved .Date() translation (@rlh1994, #267). PostgreSQL: new translations lubridate period functions years(), months(), days(), floor_date() (@bkkkk, #333) stringr functions str_squish(), str_remove(), str_remove_all() (@shosaco). New RedShift translations used RPostgres::Redshift(). str_replace() errors since ’s Redshift translation, str_replace_all() uses REGEXP_REPLACE() (#446). paste() paste0() use || (#458). .numeric() .double() cast FLOAT (#408). substr() str_sub() use SUBSTRING() (#327). SQLite gains translations lubridate functions today(), now(), year(), month(), day(), hour(), minute(), second(),yday() (#262), correct translation median() (#357).","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"extensibility-2-0-0","dir":"Changelog","previous_headings":"","what":"Extensibility","title":"dbplyr 2.0.0","text":"author dbplyr backend, please see vignette(\"backend-2\") details. New dbplyr_edition() generic allows opt-2nd edition dbplyr API. db_write_table() now calls DBI::dbWriteTable() instead nine generics formerly small part: db_create_indexes(), db_begin(), db_rollback(), db_commit(), db_list_tables(), drop_drop_table(), db_has_table(), db_create_table(), db_data_types(). can now delete methods generics. db_query_rows() longer used; appears hasn’t used time, method, can delete . DBI::dbQuoteIdentifier() now used instead sql_escape_ident() DBI::dbQuoteString() instead sql_escape_string(). number db_* generics replaced new SQL generation generics: dplyr::db_analyze() -> dbplyr::sql_table_analyze() dplyr::db_create_index() -> dbplyr::sql_table_index() dplyr::db_explain() -> dbplyr::sql_queriy_explain() dplyr::db_query_fields() -> dbplyr::sql_query_fields() dplyr::db_save_query() -> dbplyr::sql_query_save() makes easier test important part process moving database generics dbplyr (#284). number generics renamed facilitate move dplyr dbplyr: dplyr::sql_select() -> dbplyr::sql_query_select() dplyr::sql_join() -> dbplyr::sql_query_join() dplyr::sql_semi_join() -> dbplyr::sql_query_semi_join() dplyr::sql_set_op() -> dbplyr::sql_query_set_op() dplyr::sql_subquery() -> dbplyr::sql_query_wrap() dplyr::db_desc() -> dbplyr::db_connection_describe() New db_temporary_table() generic makes easier work databases require temporary tables specially named. New sql_expr_matches() generic allows databases use efficient alternatives determine two values “match” (.e. like equality pair NULLs also match). details, see https://modern-sql.com/feature/-distinct-New sql_join_suffix() allows backends control default suffixes used (#254).","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"minor-improvements-and-bug-fixes-2-0-0","dir":"Changelog","previous_headings":"","what":"Minor improvements and bug fixes","title":"dbplyr 2.0.0","text":"old lazy eval shims removed. deprecated time. Date-time escaping methods Athena Presto moved packages belong. Attempting embed Shiny reactive query now gives helpful error (#439). copy_lahman() copy_nycflights13() (hence nycflights13_sqlite()) friends now return DBI connections rather now deprecated src_dbi() (#440). copy_to() can now overwrite table specified schema (#489), gains in_transaction argument used optionally suppress transaction wrapper (#368). distinct() longer duplicates column grouped (#354). transmute() now correctly tracks variables needs creating subqueries (#313). mutate() grouping variables longer generates downstream error (#396) mutate() correctly generates subqueries re-use variable three times (#412). window_order() overrides ordering, rather appending .","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"dbplyr-144","dir":"Changelog","previous_headings":"","what":"dbplyr 1.4.4","title":"dbplyr 1.4.4","text":"CRAN release: 2020-05-27 Internally DBI::dbExecute() now uses immediate = TRUE; improves support session-scoped temporary tables MS SQL (@krlmlr, #438). Subqueries ORDER use TOP 9223372036854775807 instead TOP 100 PERCENT SQL Server compatibility Azure Data Warehouse (#337, @alexkyllo). escape() now supports blob vectors using new sql_escape_raw() generic. enables using blob variables dplyr verbs, example filter nvarchar values UTF-16 blobs (see https://github.com/r-dbi/DBI/issues/215#issuecomment-356376133). (@okhoma, #433) Added setOldClass() calls \"ident\" \"ident_q\" classes compatibility dplyr 1.0.0 (#448, @krlmlr). Postgres str_detect() translation uses argument names stringr, gains negate argument (#444). semi_join() anti_join() now correctly support sql_on argument (#443, @krlmlr).","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"dbplyr-143","dir":"Changelog","previous_headings":"","what":"dbplyr 1.4.3","title":"dbplyr 1.4.3","text":"CRAN release: 2020-04-19 dbplyr now uses RPostgres (instead RPostgreSQL) RMariaDB (instead RMySQL) internal tests data functions (#427). Date POSIXt methods escape() now use exported sql_escape_date() sql_escape_datetime() generics allow backend specific formatting date datetime literals. used provide methods Athena Presto backends (@OssiLehtinen, #384, #391). first(), last(), nth(), lead() lag() now respect window_frame() (@krlmlr, #366). SQL server: new translations str_flatten() (@PauloJhonny, #405). SQL server: temporary datasets now session-local, global (#401). Postgres: correct str_detect(), str_replace() str_replace_all() translation (@shosaco, #362).","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"dbplyr-142","dir":"Changelog","previous_headings":"","what":"dbplyr 1.4.2","title":"dbplyr 1.4.2","text":"CRAN release: 2019-06-17 Fix bug partially evaluating unquoting quosure containing single symbol (#317) Fixes rlang dpylr compatibility.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"dbplyr-141","dir":"Changelog","previous_headings":"","what":"dbplyr 1.4.1","title":"dbplyr 1.4.1","text":"CRAN release: 2019-06-05 Minor improvements SQL generation x %% y strips names y (#269). Enhancements scoped verbs (mutate_all(), summarise_if(), filter_at() etc) (#296, #306). MS SQL use TOP 100 PERCENT stop-gap allow subqueries ORDER (#277). Window functions now translated correctly Hive (#293, @cderv).","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"dbplyr-140","dir":"Changelog","previous_headings":"","what":"dbplyr 1.4.0","title":"dbplyr 1.4.0","text":"CRAN release: 2019-04-23","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"breaking-changes-1-4-0","dir":"Changelog","previous_headings":"","what":"Breaking changes","title":"dbplyr 1.4.0","text":"Error: `con` must NULL: see error, probably means forgotten pass con dbplyr function. Previously, dbplyr defaulted using simulate_dbi() introduced subtle escaping bugs. (’s also possible forgotten pass somewhere dbplyr tests don’t pick , can’t figure , please let know). Subsetting ([[, $, [) functions longer evaluated locally. makes translation consistent enables useful new idioms modern databases (#200).","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"new-features-1-4-0","dir":"Changelog","previous_headings":"","what":"New features","title":"dbplyr 1.4.0","text":"MySQL/MariaDB (https://mariadb.com/kb/en/library/window-functions/) SQLite (https://www.sqlite.org/windowfunctions.html) translations gain support window functions, available Maria DB 10.2, MySQL 8.0, SQLite 3.25 (#191). Overall, dplyr generates many fewer subqueries: Joins semi-joins longer add unneeded subquery (#236). facilitated new bare_identifier_ok argument sql_render(); previous argument called root confused . Many sequences select(), rename(), mutate(), transmute() can collapsed single query, instead always generating subquery (#213). New vignette(\"sql\") describes advantages dbplyr SQL (#205) gives advice writing literal SQL inside dplyr, need (#196). New vignette(\"reprex\") gives hints creating reprexes work anywhere (#117). supported new tbl_memdb() matches existing tbl_lazy(). ..._join() functions gain sql_on argument allows specifying arbitrary join predicates SQL code (#146, @krlmlr).","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"sql-translations-1-4-0","dir":"Changelog","previous_headings":"","what":"SQL translations","title":"dbplyr 1.4.0","text":"New translations lubridate functions: today(), now(), year(), month(), day(), hour(), minute(), second(), quarter(), yday() (@colearendt, @derekmorr). Also added new translation .POSIXct(). New translations stringr functions: str_c(), str_sub(), str_length(), str_to_upper(), str_to_lower(), str_to_title() (@colearendt). Non-translated stringr functions throw clear error. New translations bitwise operations: bitwNot(), bitwAnd(), bitwOr(), bitwXor(), bitwShiftL(), bitwShiftR(). Unlike base R functions, translations coerce arguments integers (@davidchall, #235). New translation x[y] CASE y x END. enables sum([b == 0]) work expect R (#202). y needs logical expression; likely get type error database. New translations x$y x[[\"y\"]] x.y, enabling index nested fields databases provide (#158). .data .env pronouns tidy evaluation correctly translated (#132). New translation median() quantile(). Works ANSI compliant databases (SQL Server, Postgres, MariaDB, Teradata) custom translations Hive. Thanks @edavidaja researching SQL variants! (#169) na_if() correct translated NULLIF() (rather NULL_IF) (#211). n_distinct() translation throws error given one argument. (#101, #133). New default translations paste(), paste0(), hyperbolic functions (previously available ODBC databases). Corrected translations pmin() pmax() LEAST() GREATEST() ANSI compliant databases (#118), MIN() MAX() SQLite, error SQL server. New translation switch() simple form CASE (#192).","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"sql-simulation-1-4-0","dir":"Changelog","previous_headings":"SQL translations","what":"SQL simulation","title":"dbplyr 1.4.0","text":"SQL simulation makes possible see dbplyr translate SQL , without active database connection, used testing generating reprexes. SQL simulation overhauled. now works reliably, better documented, always uses ANSI escaping (.e. ` field names ' strings). tbl_lazy() now actually puts dbplyr::src $src field. shouldn’t affect downstream code unless previously working around weird difference tbl_lazy tbl_sql classes. also includes src class class, printed, shows generated SQL (#111).","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"database-specific-improvements-1-4-0","dir":"Changelog","previous_headings":"","what":"Database specific improvements","title":"dbplyr 1.4.0","text":"MySQL/MariaDB Translations also applied connections via odbc package (@colearendt, #238) Basic support regular expressions via str_detect() andstr_replace_all() (@colearendt, #168). Improved translation .logical(x) (x, TRUE, FALSE). Oracle New custom translation paste() paste0() (@cderv, #221) Postgres Basic support regular expressions via str_detect() andstr_replace_all() (@colearendt, #168). SQLite explain() translation now generates EXPLAIN QUERY PLAN generates higher-level, human friendly explanation. SQL server Improved translation .logical(x) CAST(x BIT) (#250). Translates paste(), paste0(), str_c() +. copy_to() method applies temporary table name transformation earlier can now overwrite temporary tables (#258). db_write_table() method uses correct argument name passing along field types (#251).","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"minor-improvements-and-bug-fixes-1-4-0","dir":"Changelog","previous_headings":"","what":"Minor improvements and bug fixes","title":"dbplyr 1.4.0","text":"Aggregation functions warn per session use na.rm = TRUE (#216). table names generated random_table_name() prefix “dbplyr_”, makes easier find programmatically (@mattle24, #111) Functions available windowed (mutate()) query now throw error called aggregate (summarise()) query (#129) arrange() understands .by_group argument, making possible sort groups desired. default FALSE (#115) distinct() now handles computed variables like distinct(df, y = x + y) (#154). escape(), sql_expr() build_sql() longer accept con = NULL shortcut con = simulate_dbi(). made easy forget pass con along, introducing extremely subtle escaping bugs. win_over() gains con argument reason. New escape_ansi() always uses ANSI SQL 92 standard escaping (use examples documentation). mutate(df, x = NULL) drops x output, just like working local data frames (#194). partial_eval() processes inlined functions (including rlang lambda functions). makes dbplyr work forms scoped verbs like df %>% summarise_all(~ mean(.)), df %>% summarise_all(list(mean)) (#134). sql_aggregate() now takes optional argument f_r passing check_na_rm(). allows warning show R function name rather SQL function name (@sverchkov, #153). sql_infix() gains pad argument rare operator doesn’t need surrounded spaces. sql_prefix() longer turns SQL functions uppercase, allowing correct translation case-sensitive SQL functions (#181, @mtoto). summarise() gives clear error message refer variable created summarise() (#114). New sql_call2() rlang::call2() sql_expr() rlang::expr(). show_query() explain() use cat() rather message. union(), union_all(), setdiff() intersect() better job matching columns across backends (#183).","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"dbplyr-130","dir":"Changelog","previous_headings":"","what":"dbplyr 1.3.0","title":"dbplyr 1.3.0","text":"CRAN release: 2019-01-09 Now supports dplyr 0.8.0 (#190) R 3.1.0","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"api-changes-1-3-0","dir":"Changelog","previous_headings":"","what":"API changes","title":"dbplyr 1.3.0","text":"Calls form dplyr::foo() now evaluated database, rather locally (#197). vars argument tbl_sql() formally deprecated; hasn’t actually done anything (#3254). src tbl objects now include class generated class underlying connection object. makes possible dplyr backends implement different behaviour dplyr level, needed. (#2293)","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"sql-translation-1-3-0","dir":"Changelog","previous_headings":"","what":"SQL translation","title":"dbplyr 1.3.0","text":"x %% y now translated FALSE y empty (@mgirlich, #160). New .integer64(x) translation CAST(x BIGINT) (#3305) case_when now translates ELSE clause formula form TRUE~<RHS> provided . (@cderv, #112) cummean() now generates AVG() MEAN() (#157) str_detect() now uses correct parameter order (#3397) MS SQL Cumulative summary functions now work (#157) ifelse() uses CASE instead IIF; allows complex operations, %%, work properly (#93) Oracle Custom db_drop_table() now drops tables exist (#3306) Custom setdiff() translation (#3493) Custom db_explain() translation (#3471) SQLite Correct translation .numeric()/.double() (@chris-park, #171). Redshift substr() translation improved (#3339)","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"minor-improvements-and-bug-fixes-1-3-0","dir":"Changelog","previous_headings":"","what":"Minor improvements and bug fixes","title":"dbplyr 1.3.0","text":"copy_to() remove existing table overwrite = TRUE table already exists, eliminating confusing “NOTICE” PostgreSQL (#3197). partial_eval() handles unevaluated formulas (#184). pull.tbl_sql() now extracts correctly grouped tables (#3562). sql_render.op() now correctly forwards con argument (@kevinykuo, #73).","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"dbplyr-122","dir":"Changelog","previous_headings":"","what":"dbplyr 1.2.2","title":"dbplyr 1.2.2","text":"CRAN release: 2018-07-25 R CMD check fixes","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"dbplyr-121","dir":"Changelog","previous_headings":"","what":"dbplyr 1.2.1","title":"dbplyr 1.2.1","text":"CRAN release: 2018-02-19 Forward compatibility fixes rlang 0.2.0","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"dbplyr-120","dir":"Changelog","previous_headings":"","what":"dbplyr 1.2.0","title":"dbplyr 1.2.0","text":"CRAN release: 2018-01-03","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"new-top-level-translations-1-2-0","dir":"Changelog","previous_headings":"","what":"New top-level translations","title":"dbplyr 1.2.0","text":"New translations MS Access (#2946) (@DavisVaughan) Oracle, via odbc ROracle (#2928, #2732, @edgararuiz) Teradata. Redshift. dbplyr now supplies appropriate translations RMariaDB RPostgres packages (#3154). generally recommend using packages favour older RMySQL RPostgreSQL packages fully DBI compliant tested DBItest.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"new-features-1-2-0","dir":"Changelog","previous_headings":"","what":"New features","title":"dbplyr 1.2.0","text":"copy_to() can now “copy” tbl_sql src, providing another way cache query temporary table (#3064). can also copy_to tbl_sqls another source, copy_to() automatically collect copy. Initial support stringr functions: str_length(), str_to_upper(), str_to_lower(), str_replace_all(), str_detect(), str_trim(). Regular expression support varies database database, simple regular expressions ok.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"tools-for-developers-1-2-0","dir":"Changelog","previous_headings":"","what":"Tools for developers","title":"dbplyr 1.2.0","text":"db_compute() gains analyze argument match db_copy_to(). New remote_name(), remote_con(), remote_src(), remote_query() remote_query_plan() provide standard API get metadata remote tbl (#3130, #2923, #2824). New sql_expr() convenient building block low-level SQL translation (#3169). New sql_aggregate() win_aggregate() generating SQL windowed SQL functions aggregates. take one argument, x, warn na.rm TRUE (#3155). win_recycled() equivalent win_aggregate() soft-deprecated. db_write_table now needs return table name","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"minor-improvements-and-bug-fixes-1-2-0","dir":"Changelog","previous_headings":"","what":"Minor improvements and bug fixes","title":"dbplyr 1.2.0","text":"Multiple head() calls row now collapse single call. avoids printing problem MS SQL (#3084). escape() now works integer64 values bit64 package (#3230) , ifelse(), if_else() now correctly scope false condition applies non-NULL conditions (#3157) ident() ident_q() handle 0-length inputs better, easier use S3 (#3212) in_schema() now work places, particularly copy_to() (#3013, @baileych) SQL generation joins longer gets stuck endless loop request empty suffix (#3220). mutate() better logic splitting single mutate multiple subqueries (#3095). Improved paste() paste0() support MySQL, PostgreSQL (#3168), RSQLite (#3176). MySQL PostgreSQL gain support str_flatten() behaves like paste(x, collapse = \"-\") (technical reasons can’t implemented straightforward translation paste()). same_src.tbl_sql() now performs correct comparison instead always returning TRUE. means copy = TRUE allows perform cross-database joins (#3002). select() queries longer alias column names unnecessarily (#2968, @DavisVaughan). select() rename() now powered tidyselect, fixing renaming bugs (#3132, #2943, #2860). summarise() performs partial evaluation database submission (#3148). test_src() makes easier access single test source.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"database-specific-improvements-1-2-0","dir":"Changelog","previous_headings":"","what":"Database specific improvements","title":"dbplyr 1.2.0","text":"MS SQL Better support temporary tables (@Hong-Revo) Different translations filter/mutate contexts : NULL evaluation (.na(), .null()), logical operators (!, &, &&, |, ||), comparison operators (==, !=, <, >, >=, <=) MySQL: copy_to() (via db_write_table()) correctly translates logical variables integers (#3151). odbc: improved n() translation windowed context. SQLite: improved na_if translation (@cwarden) PostgreSQL: translation grepl() added (@zozlak) Oracle: changed VARVHAR VARCHAR2 datatype (@washcycle, #66)","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"dbplyr-110","dir":"Changelog","previous_headings":"","what":"dbplyr 1.1.0","title":"dbplyr 1.1.0","text":"CRAN release: 2017-06-27","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"new-features-1-1-0","dir":"Changelog","previous_headings":"","what":"New features","title":"dbplyr 1.1.0","text":"full_join() non-overlapping columns = character() translated CROSS JOIN (#2924). case_when() now translates SQL “CASE ” (#2894) x %% c(1) now generates SQL x %% 1 (#2898). New window_order() window_frame() give finer control window functions dplyr creates (#2874, #2593). Added SQL translations Oracle (@edgararuiz).","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"minor-improvements-and-bug-fixes-1-1-0","dir":"Changelog","previous_headings":"","what":"Minor improvements and bug fixes","title":"dbplyr 1.1.0","text":"x %% c(1) now generates SQL x %% 1 (#2898). head(tbl, 0) now supported (#2863). select()ing zero columns gives information error message (#2863). Variables created join now disambiguated variables table, just variables table (#2823). PostgreSQL gains better translation round() (#60). Added custom db_analyze_table() MS SQL, Oracle, Hive Impala (@edgararuiz) Added support sd() aggregate window functions (#2887) (@edgararuiz) can now use magrittr pipe within expressions, e.g. mutate(mtcars, cyl %>% .character()). translation supplied summarise function, equivalent windowed variant, expression translated NULL warning. Now sql_variant() checks aggregate functions matching window functions correct translations clean errors generated (#2887)","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"dbplyr-100","dir":"Changelog","previous_headings":"","what":"dbplyr 1.0.0","title":"dbplyr 1.0.0","text":"CRAN release: 2017-06-09","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"new-features-1-0-0","dir":"Changelog","previous_headings":"","what":"New features","title":"dbplyr 1.0.0","text":"tbl() copy_to() now work directly DBI connections (#2423, #2576), longer need generate dplyr src. glimpse() now works remote tables (#2665) dplyr gained basic SQL optimiser, collapses certain nested SELECT queries single query (#1979). improve query execution performance databases less sophisticated query optimisers, fixes certain problems ordering limits subqueries (#1979). big thanks goes @hhoeflin figuring optimisation. compute() collapse() now preserve “ordering” rows. affects computation window functions, rest SQL care row order (#2281). copy_to() gains overwrite argument allows overwrite existing table. Use care! (#2296) New in_schema() function makes easy refer tables schema: in_schema(\"my_schema_name\", \"my_table_name\").","code":"library(dplyr)  con <- DBI::dbConnect(RSQLite::SQLite(), \":memory:\") copy_to(con, mtcars)  mtcars2 <- tbl(con, \"mtcars\") mtcars2"},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"deprecated-and-defunct-1-0-0","dir":"Changelog","previous_headings":"","what":"Deprecated and defunct","title":"dbplyr 1.0.0","text":"query() longer exported. hasn’t useful shouldn’t break code.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"verb-level-sql-generation-1-0-0","dir":"Changelog","previous_headings":"","what":"Verb-level SQL generation","title":"dbplyr 1.0.0","text":"Partial evaluation occurs immediately execute verb (like filter() mutate()) rather happening query executed (#2370). mutate.tbl_sql() now generate many subqueries necessary can refer variables just created (like mutate regular dataframes) (#2481, #2483). SQL joins improved: SQL joins always use ... syntax, avoiding USING ... even natural joins. Improved handling tables columns name (#1997, @javierluraschi). now generate SQL similar ’d write hand, eliminating layer two subqueries (#2333) [API] now follow rules including duplicated key variables data frame methods , namely key variables kept x, never y (#2410) [API] sql_join() generic now gains vars argument lists variables taken left right sides join. custom sql_join() method, ’ll need update code generates joins, following template sql_join.generic(). full_join() throws clear error attempt use MySQL backend (#2045) right_join() full_join() now return results consistent local data frame sources records right table match left table. right_join() returns values columns right table. full_join() returns coalesced values columns left right tables (#2578, @ianmcook) group_by() can now perform inline mutate database backends (#2422). SQL generation set operations (intersect(), setdiff(), union(), union_all()) considerably improved. default, component SELECT surrounded parentheses, except SQLite. SQLite backend now throw error attempt set operation query contains LIMIT, supported SQLite (#2270). set operations match column names across inputs, filling non-matching variables NULL (#2556). rename() group_by() now combine correctly (#1962) tbl_lazy() lazy_tbl() exported. help test generated SQL active database connection. ungroup() correctly resets grouping variables (#2704).","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"vector-level-sql-generation-1-0-0","dir":"Changelog","previous_headings":"","what":"Vector-level SQL generation","title":"dbplyr 1.0.0","text":"New .sql() safely coerces input SQL. translators .character(), .integer() .double() (#2775). New ident_q() makes possible specifier identifiers need quoted. Translation inline scalars: Logical values now translated differently depending backend. default use “true” “false” SQL-99 standard, widely support. SQLite translates “0” “1” (#2052). Inf -Inf correctly escaped Better test whether double similar integer hence needs trailing 0.0 added (#2004). Quoting defaults DBI::dbEscapeString() DBI::dbQuoteIdentifier() respectively. :: ::: handled correctly (#2321) x %% 1 now correctly translated x (1) (#511). ifelse() if_else() use correct argument names SQL translation (#2225). ident() now returns object class c(\"ident\", \"character\"). longer contains “sql” indicate already escaped. .na() .null() gain extra parens SQL translation preserve correct precedence (#2302). [API] log(x, b) now correctly translated SQL log(b, x) (#2288). SQLite support 2-argument log function translated log(x) / log(b). nth(x, ) now correctly translated nth_value(x, ). n_distinct() now accepts multiple variables (#2148). [API] substr() now translated SQL, correcting difference third argument. R, ’s position last character, SQL ’s length string (#2536). win_over() escapes expression using current database rules.","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"backends-1-0-0","dir":"Changelog","previous_headings":"","what":"Backends","title":"dbplyr 1.0.0","text":"copy_to() now uses db_write_table() instead db_create_table() db_insert_into(). db_write_table.DBIConnection() uses dbWriteTable(). New db_copy_to(), db_compute() db_collect() allow backends override entire database process behind copy_to(), compute() collect(). db_sql_render() allow additional control SQL rendering process. generics whose behaviour can vary database database now provide DBIConnection method. means can easily scan NAMESPACE see extension points. sql_escape_logical() allows control translation literal logicals (#2614). src_desc() replaced db_desc() now dispatches connection, eliminating last method required dispatch class src. win_over(), win_rank(), win_recycled(), win_cumulative(), win_current_group() win_current_order() now exported. make easier provide customised SQL window functions (#2051, #2126). SQL translation Microsoft SQL Server (@edgararuiz) SQL translation Apache Hive (@edgararuiz) SQL translation Apache Impala (@edgararuiz)","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"minor-bug-fixes-and-improvements-1-0-0","dir":"Changelog","previous_headings":"","what":"Minor bug fixes and improvements","title":"dbplyr 1.0.0","text":"collect() defaults return rows data (#1968). makes behave .data.frame() as_tibble(). collect() regroups variables present data (#2156) collect() automatically LIMIT result n, number rows requested. provide query planner information may able use improve execution time (#2083). common_by() gets better error message unexpected inputs (#2091) copy_to() longer checks table doesn’t exist creation, instead preferring fall back database error messages. reduce false positives false negative (#1470) copy_to() now succeeds MySQL character column contains NA (#1975, #2256, #2263, #2381, @demorenoc, @eduardgrebe). copy_to() now returns output invisibly (since ’re often just calling side-effect). distinct() reports improved variable information SQL backends. means likely work middle pipeline (#2359). Ungrouped () database backends now collects data locally first (#2392). Call dbFetch() instead deprecated fetch() (#2134). Use DBI::dbExecute() non-query SQL commands (#1912) explain() show_query() now invisibly return first argument, making easier use inside pipeline. print.tbl_sql() displays ordering (#2287) prints table name, known. print(df, n = Inf) head(df, n = Inf) now work remote tables (#2580). db_desc() sql_translate_env() get defaults DBIConnection. Formatting now works overriding tbl_sum() generic instead print(). means output consistent tibble, format() now supported also SQL sources (tidyverse/dbplyr#14).","code":""},{"path":"https://dbplyr.tidyverse.org/dev/news/index.html","id":"lazy-ops-1-0-0","dir":"Changelog","previous_headings":"","what":"Lazy ops","title":"dbplyr 1.0.0","text":"[API] signature op_base changed op_base(x, vars, class) [API] translate_sql() partial_eval() refined: translate_sql() longer takes vars argument; instead call partial_eval() . longer needs environment translate_sql()_ now works list dots, rather lazy_dots. partial_eval() now takes character vector variable names rather tbl. leads simplification op data structure: dots now list expressions rather lazy_dots. [API] op_vars() now returns list quoted expressions. enables escaping happen correct time (.e. connection known).","code":""}]
